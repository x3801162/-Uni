/**
 * tdesign v1.11.1
 * (c) 2025 TDesign Group
 * @license MIT
 */

import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import { ref, watch, onUnmounted, reactive } from 'vue';
import { createGesture, dragAction, pinchAction } from '@use-gesture/vanilla';

var Gesture = createGesture([dragAction, pinchAction]);
function useGesture(config) {
  var gesture = ref(null);
  var destroy = function destroy() {
    var _gesture$value, _gesture$value$destro;
    return (_gesture$value = gesture.value) === null || _gesture$value === void 0 || (_gesture$value$destro = _gesture$value.destroy) === null || _gesture$value$destro === void 0 ? void 0 : _gesture$value$destro.call(_gesture$value);
  };
  watch(function () {
    return [config === null || config === void 0 ? void 0 : config.destroyInvisible, config === null || config === void 0 ? void 0 : config.visible];
  }, function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
      destroyInvisible = _ref2[0],
      visible = _ref2[1];
    if (destroyInvisible && !visible) {
      destroy();
    }
  });
  onUnmounted(function () {
    var _gesture$value2, _gesture$value2$destr;
    (_gesture$value2 = gesture.value) === null || _gesture$value2 === void 0 || (_gesture$value2$destr = _gesture$value2.destroy) === null || _gesture$value2$destr === void 0 || _gesture$value2$destr.call(_gesture$value2);
  });
  var create = function create(target, handler) {
    var config2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    gesture.value = new Gesture(target, handler, config2);
    returns.gesture = gesture.value;
  };
  var returns = reactive({
    gesture: gesture.value,
    destroy: destroy,
    create: create
  });
  return returns;
}

export { useGesture as default };
//# sourceMappingURL=useGesture.js.map
