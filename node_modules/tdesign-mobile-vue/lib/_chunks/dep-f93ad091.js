/**
 * tdesign v1.11.1
 * (c) 2025 TDesign Group
 * @license MIT
 */

import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import _construct from '@babel/runtime/helpers/construct';
import _assertThisInitialized from '@babel/runtime/helpers/assertThisInitialized';
import _possibleConstructorReturn from '@babel/runtime/helpers/possibleConstructorReturn';
import _getPrototypeOf from '@babel/runtime/helpers/getPrototypeOf';
import _inherits from '@babel/runtime/helpers/inherits';
import _classCallCheck from '@babel/runtime/helpers/classCallCheck';
import _createClass from '@babel/runtime/helpers/createClass';
import _typeof from '@babel/runtime/helpers/typeof';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';
import _regeneratorRuntime from '@babel/runtime/regenerator';
import _wrapNativeSuper from '@babel/runtime/helpers/wrapNativeSuper';
import _objectWithoutProperties from '@babel/runtime/helpers/objectWithoutProperties';
import _get from '@babel/runtime/helpers/get';

function _createForOfIteratorHelper$9(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$9(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray$9(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray$9(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$9(r, a) : void 0; } }
function _arrayLikeToArray$9(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
// src/index.ts
var f$2 = {
    reset: [0, 0],
    bold: [1, 22, "\x1B[22m\x1B[1m"],
    dim: [2, 22, "\x1B[22m\x1B[2m"],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29],
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    gray: [90, 39],
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    blackBright: [90, 39],
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39],
    bgBlackBright: [100, 49],
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  },
  h$2 = Object.entries(f$2);
function a$1(n) {
  return String(n);
}
a$1.open = "";
a$1.close = "";
function C$1() {
  var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;
  var e = typeof process != "undefined" ? process : void 0,
    i = (e == null ? void 0 : e.env) || {},
    g = (e == null ? void 0 : e.argv) || [];
  return !("NO_COLOR" in i || g.includes("--no-color")) && ("FORCE_COLOR" in i || g.includes("--color") || (e == null ? void 0 : e.platform) === "win32" || n && i.TERM !== "dumb" || "CI" in i) || typeof window != "undefined" && !!window.chrome;
}
function p$1() {
  var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;
  var e = C$1(n),
    i = function i(r, t, c, o) {
      var l = "",
        s = 0;
      do l += r.substring(s, o) + c, s = o + t.length, o = r.indexOf(t, s); while (~o);
      return l + r.substring(s);
    },
    g = function g(r, t) {
      var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : r;
      var o = function o(l) {
        var s = String(l),
          b = s.indexOf(t, r.length);
        return ~b ? r + i(s, t, c, b) + t : r + s + t;
      };
      return o.open = r, o.close = t, o;
    },
    u = {
      isColorSupported: e
    },
    d = function d(r) {
      return "\x1B[".concat(r, "m");
    };
  var _iterator = _createForOfIteratorHelper$9(h$2),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _slicedToArray(_step.value, 2),
        r = _step$value[0],
        t = _step$value[1];
      u[r] = e ? g(d(t[0]), d(t[1]), t[2]) : a$1;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return u;
}

var s = p$1();

var _excluded$2 = ["message", "cause"];
function _callSuper$6(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$6() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$6() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$6 = function _isNativeReflectConstruct() { return !!t; })(); }
function ownKeys$9(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$9(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$9(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$9(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _createForOfIteratorHelper$8(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$8(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray$8(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray$8(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$8(r, a) : void 0; } }
function _arrayLikeToArray$8(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _mergeNamespaces(n, m) {
  m.forEach(function (e) {
    e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
      if (k !== 'default' && !(k in n)) {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function get() {
            return e[k];
          }
        });
      }
    });
  });
  return Object.freeze(n);
}
function getKeysOfEnumerableProperties(object, compareKeys) {
  var rawKeys = Object.keys(object);
  var keys = compareKeys === null ? rawKeys : rawKeys.sort(compareKeys);
  if (Object.getOwnPropertySymbols) {
    var _iterator = _createForOfIteratorHelper$8(Object.getOwnPropertySymbols(object)),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var symbol = _step.value;
        if (Object.getOwnPropertyDescriptor(object, symbol).enumerable) {
          keys.push(symbol);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  return keys;
}
/**
* Return entries (for example, of a map)
* with spacing, indentation, and comma
* without surrounding punctuation (for example, braces)
*/
function printIteratorEntries(iterator, config, indentation, depth, refs, printer) {
  var separator = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : ": ";
  var result = "";
  var width = 0;
  var current = iterator.next();
  if (!current.done) {
    result += config.spacingOuter;
    var indentationNext = indentation + config.indent;
    while (!current.done) {
      result += indentationNext;
      if (width++ === config.maxWidth) {
        result += "…";
        break;
      }
      var name = printer(current.value[0], config, indentationNext, depth, refs);
      var value = printer(current.value[1], config, indentationNext, depth, refs);
      result += name + separator + value;
      current = iterator.next();
      if (!current.done) {
        result += ",".concat(config.spacingInner);
      } else if (!config.min) {
        result += ",";
      }
    }
    result += config.spacingOuter + indentation;
  }
  return result;
}
/**
* Return values (for example, of a set)
* with spacing, indentation, and comma
* without surrounding punctuation (braces or brackets)
*/
function printIteratorValues(iterator, config, indentation, depth, refs, printer) {
  var result = "";
  var width = 0;
  var current = iterator.next();
  if (!current.done) {
    result += config.spacingOuter;
    var indentationNext = indentation + config.indent;
    while (!current.done) {
      result += indentationNext;
      if (width++ === config.maxWidth) {
        result += "…";
        break;
      }
      result += printer(current.value, config, indentationNext, depth, refs);
      current = iterator.next();
      if (!current.done) {
        result += ",".concat(config.spacingInner);
      } else if (!config.min) {
        result += ",";
      }
    }
    result += config.spacingOuter + indentation;
  }
  return result;
}
/**
* Return items (for example, of an array)
* with spacing, indentation, and comma
* without surrounding punctuation (for example, brackets)
*/
function printListItems(list, config, indentation, depth, refs, printer) {
  var result = "";
  list = list instanceof ArrayBuffer ? new DataView(list) : list;
  var isDataView = function isDataView(l) {
    return l instanceof DataView;
  };
  var length = isDataView(list) ? list.byteLength : list.length;
  if (length > 0) {
    result += config.spacingOuter;
    var indentationNext = indentation + config.indent;
    for (var i = 0; i < length; i++) {
      result += indentationNext;
      if (i === config.maxWidth) {
        result += "…";
        break;
      }
      if (isDataView(list) || i in list) {
        result += printer(isDataView(list) ? list.getInt8(i) : list[i], config, indentationNext, depth, refs);
      }
      if (i < length - 1) {
        result += ",".concat(config.spacingInner);
      } else if (!config.min) {
        result += ",";
      }
    }
    result += config.spacingOuter + indentation;
  }
  return result;
}
/**
* Return properties of an object
* with spacing, indentation, and comma
* without surrounding punctuation (for example, braces)
*/
function printObjectProperties(val, config, indentation, depth, refs, printer) {
  var result = "";
  var keys = getKeysOfEnumerableProperties(val, config.compareKeys);
  if (keys.length > 0) {
    result += config.spacingOuter;
    var indentationNext = indentation + config.indent;
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var name = printer(key, config, indentationNext, depth, refs);
      var value = printer(val[key], config, indentationNext, depth, refs);
      result += "".concat(indentationNext + name, ": ").concat(value);
      if (i < keys.length - 1) {
        result += ",".concat(config.spacingInner);
      } else if (!config.min) {
        result += ",";
      }
    }
    result += config.spacingOuter + indentation;
  }
  return result;
}
var asymmetricMatcher = typeof Symbol === "function" && Symbol.for ? Symbol.for("jest.asymmetricMatcher") : 1267621;
var SPACE$2 = " ";
var serialize$5 = function serialize$5(val, config, indentation, depth, refs, printer) {
  var stringedValue = val.toString();
  if (stringedValue === "ArrayContaining" || stringedValue === "ArrayNotContaining") {
    if (++depth > config.maxDepth) {
      return "[".concat(stringedValue, "]");
    }
    return "".concat(stringedValue + SPACE$2, "[").concat(printListItems(val.sample, config, indentation, depth, refs, printer), "]");
  }
  if (stringedValue === "ObjectContaining" || stringedValue === "ObjectNotContaining") {
    if (++depth > config.maxDepth) {
      return "[".concat(stringedValue, "]");
    }
    return "".concat(stringedValue + SPACE$2, "{").concat(printObjectProperties(val.sample, config, indentation, depth, refs, printer), "}");
  }
  if (stringedValue === "StringMatching" || stringedValue === "StringNotMatching") {
    return stringedValue + SPACE$2 + printer(val.sample, config, indentation, depth, refs);
  }
  if (stringedValue === "StringContaining" || stringedValue === "StringNotContaining") {
    return stringedValue + SPACE$2 + printer(val.sample, config, indentation, depth, refs);
  }
  if (typeof val.toAsymmetricMatcher !== "function") {
    throw new TypeError("Asymmetric matcher ".concat(val.constructor.name, " does not implement toAsymmetricMatcher()"));
  }
  return val.toAsymmetricMatcher();
};
var test$5 = function test$5(val) {
  return val && val.$$typeof === asymmetricMatcher;
};
var plugin$5 = {
  serialize: serialize$5,
  test: test$5
};
var SPACE$1 = " ";
var OBJECT_NAMES = new Set(["DOMStringMap", "NamedNodeMap"]);
var ARRAY_REGEXP = /^(?:HTML\w*Collection|NodeList)$/;
function testName(name) {
  return OBJECT_NAMES.has(name) || ARRAY_REGEXP.test(name);
}
var test$4 = function test$4(val) {
  return val && val.constructor && !!val.constructor.name && testName(val.constructor.name);
};
function isNamedNodeMap(collection) {
  return collection.constructor.name === "NamedNodeMap";
}
var serialize$4 = function serialize$4(collection, config, indentation, depth, refs, printer) {
  var name = collection.constructor.name;
  if (++depth > config.maxDepth) {
    return "[".concat(name, "]");
  }
  return (config.min ? "" : name + SPACE$1) + (OBJECT_NAMES.has(name) ? "{".concat(printObjectProperties(isNamedNodeMap(collection) ? _toConsumableArray(collection).reduce(function (props, attribute) {
    props[attribute.name] = attribute.value;
    return props;
  }, {}) : _objectSpread$9({}, collection), config, indentation, depth, refs, printer), "}") : "[".concat(printListItems(_toConsumableArray(collection), config, indentation, depth, refs, printer), "]"));
};
var plugin$4 = {
  serialize: serialize$4,
  test: test$4
};

/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
function escapeHTML(str) {
  return str.replaceAll("<", "&lt;").replaceAll(">", "&gt;");
}

// Return empty string if keys is empty.
function printProps(keys, props, config, indentation, depth, refs, printer) {
  var indentationNext = indentation + config.indent;
  var colors = config.colors;
  return keys.map(function (key) {
    var value = props[key];
    var printed = printer(value, config, indentationNext, depth, refs);
    if (typeof value !== "string") {
      if (printed.includes("\n")) {
        printed = config.spacingOuter + indentationNext + printed + config.spacingOuter + indentation;
      }
      printed = "{".concat(printed, "}");
    }
    return "".concat(config.spacingInner + indentation + colors.prop.open + key + colors.prop.close, "=").concat(colors.value.open).concat(printed).concat(colors.value.close);
  }).join("");
}
// Return empty string if children is empty.
function printChildren(children, config, indentation, depth, refs, printer) {
  return children.map(function (child) {
    return config.spacingOuter + indentation + (typeof child === "string" ? printText(child, config) : printer(child, config, indentation, depth, refs));
  }).join("");
}
function printText(text, config) {
  var contentColor = config.colors.content;
  return contentColor.open + escapeHTML(text) + contentColor.close;
}
function printComment(comment, config) {
  var commentColor = config.colors.comment;
  return "".concat(commentColor.open, "<!--").concat(escapeHTML(comment), "-->").concat(commentColor.close);
}
// Separate the functions to format props, children, and element,
// so a plugin could override a particular function, if needed.
// Too bad, so sad: the traditional (but unnecessary) space
// in a self-closing tagColor requires a second test of printedProps.
function printElement(type, printedProps, printedChildren, config, indentation) {
  var tagColor = config.colors.tag;
  return "".concat(tagColor.open, "<").concat(type).concat(printedProps && tagColor.close + printedProps + config.spacingOuter + indentation + tagColor.open).concat(printedChildren ? ">".concat(tagColor.close).concat(printedChildren).concat(config.spacingOuter).concat(indentation).concat(tagColor.open, "</").concat(type) : "".concat(printedProps && !config.min ? "" : " ", "/"), ">").concat(tagColor.close);
}
function printElementAsLeaf(type, config) {
  var tagColor = config.colors.tag;
  return "".concat(tagColor.open, "<").concat(type).concat(tagColor.close, " \u2026").concat(tagColor.open, " />").concat(tagColor.close);
}
var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var COMMENT_NODE = 8;
var FRAGMENT_NODE = 11;
var ELEMENT_REGEXP = /^(?:(?:HTML|SVG)\w*)?Element$/;
function testHasAttribute(val) {
  try {
    return typeof val.hasAttribute === "function" && val.hasAttribute("is");
  } catch (_unused) {
    return false;
  }
}
function testNode(val) {
  var constructorName = val.constructor.name;
  var nodeType = val.nodeType,
    tagName = val.tagName;
  var isCustomElement = typeof tagName === "string" && tagName.includes("-") || testHasAttribute(val);
  return nodeType === ELEMENT_NODE && (ELEMENT_REGEXP.test(constructorName) || isCustomElement) || nodeType === TEXT_NODE && constructorName === "Text" || nodeType === COMMENT_NODE && constructorName === "Comment" || nodeType === FRAGMENT_NODE && constructorName === "DocumentFragment";
}
var test$3 = function test$3(val) {
  var _val$constructor;
  return (val === null || val === void 0 || (_val$constructor = val.constructor) === null || _val$constructor === void 0 ? void 0 : _val$constructor.name) && testNode(val);
};
function nodeIsText(node) {
  return node.nodeType === TEXT_NODE;
}
function nodeIsComment(node) {
  return node.nodeType === COMMENT_NODE;
}
function nodeIsFragment(node) {
  return node.nodeType === FRAGMENT_NODE;
}
var serialize$3 = function serialize$3(node, config, indentation, depth, refs, printer) {
  if (nodeIsText(node)) {
    return printText(node.data, config);
  }
  if (nodeIsComment(node)) {
    return printComment(node.data, config);
  }
  var type = nodeIsFragment(node) ? "DocumentFragment" : node.tagName.toLowerCase();
  if (++depth > config.maxDepth) {
    return printElementAsLeaf(type, config);
  }
  return printElement(type, printProps(nodeIsFragment(node) ? [] : Array.from(node.attributes, function (attr) {
    return attr.name;
  }).sort(), nodeIsFragment(node) ? {} : _toConsumableArray(node.attributes).reduce(function (props, attribute) {
    props[attribute.name] = attribute.value;
    return props;
  }, {}), config, indentation + config.indent, depth, refs, printer), printChildren(Array.prototype.slice.call(node.childNodes || node.children), config, indentation + config.indent, depth, refs, printer), config, indentation);
};
var plugin$3 = {
  serialize: serialize$3,
  test: test$3
};

// SENTINEL constants are from https://github.com/facebook/immutable-js
var IS_ITERABLE_SENTINEL = "@@__IMMUTABLE_ITERABLE__@@";
var IS_LIST_SENTINEL$1 = "@@__IMMUTABLE_LIST__@@";
var IS_KEYED_SENTINEL$1 = "@@__IMMUTABLE_KEYED__@@";
var IS_MAP_SENTINEL = "@@__IMMUTABLE_MAP__@@";
var IS_ORDERED_SENTINEL$1 = "@@__IMMUTABLE_ORDERED__@@";
var IS_RECORD_SENTINEL = "@@__IMMUTABLE_RECORD__@@";
var IS_SEQ_SENTINEL = "@@__IMMUTABLE_SEQ__@@";
var IS_SET_SENTINEL$1 = "@@__IMMUTABLE_SET__@@";
var IS_STACK_SENTINEL = "@@__IMMUTABLE_STACK__@@";
var getImmutableName = function getImmutableName(name) {
  return "Immutable.".concat(name);
};
var printAsLeaf = function printAsLeaf(name) {
  return "[".concat(name, "]");
};
var SPACE = " ";
var LAZY = "…";
function printImmutableEntries(val, config, indentation, depth, refs, printer, type) {
  return ++depth > config.maxDepth ? printAsLeaf(getImmutableName(type)) : "".concat(getImmutableName(type) + SPACE, "{").concat(printIteratorEntries(val.entries(), config, indentation, depth, refs, printer), "}");
}
// Record has an entries method because it is a collection in immutable v3.
// Return an iterator for Immutable Record from version v3 or v4.
function getRecordEntries(val) {
  var i = 0;
  return {
    next: function next() {
      if (i < val._keys.length) {
        var key = val._keys[i++];
        return {
          done: false,
          value: [key, val.get(key)]
        };
      }
      return {
        done: true,
        value: undefined
      };
    }
  };
}
function printImmutableRecord(val, config, indentation, depth, refs, printer) {
  // _name property is defined only for an Immutable Record instance
  // which was constructed with a second optional descriptive name arg
  var name = getImmutableName(val._name || "Record");
  return ++depth > config.maxDepth ? printAsLeaf(name) : "".concat(name + SPACE, "{").concat(printIteratorEntries(getRecordEntries(val), config, indentation, depth, refs, printer), "}");
}
function printImmutableSeq(val, config, indentation, depth, refs, printer) {
  var name = getImmutableName("Seq");
  if (++depth > config.maxDepth) {
    return printAsLeaf(name);
  }
  if (val[IS_KEYED_SENTINEL$1]) {
    return "".concat(name + SPACE, "{").concat(val._iter || val._object ? printIteratorEntries(val.entries(), config, indentation, depth, refs, printer) : LAZY, "}");
  }
  return "".concat(name + SPACE, "[").concat(val._iter || val._array || val._collection || val._iterable ? printIteratorValues(val.values(), config, indentation, depth, refs, printer) : LAZY, "]");
}
function printImmutableValues(val, config, indentation, depth, refs, printer, type) {
  return ++depth > config.maxDepth ? printAsLeaf(getImmutableName(type)) : "".concat(getImmutableName(type) + SPACE, "[").concat(printIteratorValues(val.values(), config, indentation, depth, refs, printer), "]");
}
var serialize$2 = function serialize$2(val, config, indentation, depth, refs, printer) {
  if (val[IS_MAP_SENTINEL]) {
    return printImmutableEntries(val, config, indentation, depth, refs, printer, val[IS_ORDERED_SENTINEL$1] ? "OrderedMap" : "Map");
  }
  if (val[IS_LIST_SENTINEL$1]) {
    return printImmutableValues(val, config, indentation, depth, refs, printer, "List");
  }
  if (val[IS_SET_SENTINEL$1]) {
    return printImmutableValues(val, config, indentation, depth, refs, printer, val[IS_ORDERED_SENTINEL$1] ? "OrderedSet" : "Set");
  }
  if (val[IS_STACK_SENTINEL]) {
    return printImmutableValues(val, config, indentation, depth, refs, printer, "Stack");
  }
  if (val[IS_SEQ_SENTINEL]) {
    return printImmutableSeq(val, config, indentation, depth, refs, printer);
  }
  // For compatibility with immutable v3 and v4, let record be the default.
  return printImmutableRecord(val, config, indentation, depth, refs, printer);
};
// Explicitly comparing sentinel properties to true avoids false positive
// when mock identity-obj-proxy returns the key as the value for any key.
var test$2 = function test$2(val) {
  return val && (val[IS_ITERABLE_SENTINEL] === true || val[IS_RECORD_SENTINEL] === true);
};
var plugin$2 = {
  serialize: serialize$2,
  test: test$2
};
function getDefaultExportFromCjs$3(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}
var reactIs$1 = {
  exports: {}
};
var reactIs_production = {};

/**
 * @license React
 * react-is.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_production;
function requireReactIs_production() {
  if (hasRequiredReactIs_production) return reactIs_production;
  hasRequiredReactIs_production = 1;
  var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
    REACT_PORTAL_TYPE = Symbol.for("react.portal"),
    REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
    REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
    REACT_PROFILER_TYPE = Symbol.for("react.profiler");
  var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
    REACT_CONTEXT_TYPE = Symbol.for("react.context"),
    REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
    REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
    REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
    REACT_MEMO_TYPE = Symbol.for("react.memo"),
    REACT_LAZY_TYPE = Symbol.for("react.lazy"),
    REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"),
    REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
  function typeOf(object) {
    if ("object" === _typeof(object) && null !== object) {
      var $$typeof = object.$$typeof;
      switch ($$typeof) {
        case REACT_ELEMENT_TYPE:
          switch (object = object.type, object) {
            case REACT_FRAGMENT_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_SUSPENSE_TYPE:
            case REACT_SUSPENSE_LIST_TYPE:
            case REACT_VIEW_TRANSITION_TYPE:
              return object;
            default:
              switch (object = object && object.$$typeof, object) {
                case REACT_CONTEXT_TYPE:
                case REACT_FORWARD_REF_TYPE:
                case REACT_LAZY_TYPE:
                case REACT_MEMO_TYPE:
                  return object;
                case REACT_CONSUMER_TYPE:
                  return object;
                default:
                  return $$typeof;
              }
          }
        case REACT_PORTAL_TYPE:
          return $$typeof;
      }
    }
  }
  reactIs_production.ContextConsumer = REACT_CONSUMER_TYPE;
  reactIs_production.ContextProvider = REACT_CONTEXT_TYPE;
  reactIs_production.Element = REACT_ELEMENT_TYPE;
  reactIs_production.ForwardRef = REACT_FORWARD_REF_TYPE;
  reactIs_production.Fragment = REACT_FRAGMENT_TYPE;
  reactIs_production.Lazy = REACT_LAZY_TYPE;
  reactIs_production.Memo = REACT_MEMO_TYPE;
  reactIs_production.Portal = REACT_PORTAL_TYPE;
  reactIs_production.Profiler = REACT_PROFILER_TYPE;
  reactIs_production.StrictMode = REACT_STRICT_MODE_TYPE;
  reactIs_production.Suspense = REACT_SUSPENSE_TYPE;
  reactIs_production.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
  reactIs_production.isContextConsumer = function (object) {
    return typeOf(object) === REACT_CONSUMER_TYPE;
  };
  reactIs_production.isContextProvider = function (object) {
    return typeOf(object) === REACT_CONTEXT_TYPE;
  };
  reactIs_production.isElement = function (object) {
    return "object" === _typeof(object) && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
  };
  reactIs_production.isForwardRef = function (object) {
    return typeOf(object) === REACT_FORWARD_REF_TYPE;
  };
  reactIs_production.isFragment = function (object) {
    return typeOf(object) === REACT_FRAGMENT_TYPE;
  };
  reactIs_production.isLazy = function (object) {
    return typeOf(object) === REACT_LAZY_TYPE;
  };
  reactIs_production.isMemo = function (object) {
    return typeOf(object) === REACT_MEMO_TYPE;
  };
  reactIs_production.isPortal = function (object) {
    return typeOf(object) === REACT_PORTAL_TYPE;
  };
  reactIs_production.isProfiler = function (object) {
    return typeOf(object) === REACT_PROFILER_TYPE;
  };
  reactIs_production.isStrictMode = function (object) {
    return typeOf(object) === REACT_STRICT_MODE_TYPE;
  };
  reactIs_production.isSuspense = function (object) {
    return typeOf(object) === REACT_SUSPENSE_TYPE;
  };
  reactIs_production.isSuspenseList = function (object) {
    return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
  };
  reactIs_production.isValidElementType = function (type) {
    return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || "object" === _typeof(type) && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? true : false;
  };
  reactIs_production.typeOf = typeOf;
  return reactIs_production;
}
var reactIs_development$1 = {};

/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_development$1;
function requireReactIs_development$1() {
  if (hasRequiredReactIs_development$1) return reactIs_development$1;
  hasRequiredReactIs_development$1 = 1;
  "production" !== process.env.NODE_ENV && function () {
    function typeOf(object) {
      if ("object" === _typeof(object) && null !== object) {
        var $$typeof = object.$$typeof;
        switch ($$typeof) {
          case REACT_ELEMENT_TYPE:
            switch (object = object.type, object) {
              case REACT_FRAGMENT_TYPE:
              case REACT_PROFILER_TYPE:
              case REACT_STRICT_MODE_TYPE:
              case REACT_SUSPENSE_TYPE:
              case REACT_SUSPENSE_LIST_TYPE:
              case REACT_VIEW_TRANSITION_TYPE:
                return object;
              default:
                switch (object = object && object.$$typeof, object) {
                  case REACT_CONTEXT_TYPE:
                  case REACT_FORWARD_REF_TYPE:
                  case REACT_LAZY_TYPE:
                  case REACT_MEMO_TYPE:
                    return object;
                  case REACT_CONSUMER_TYPE:
                    return object;
                  default:
                    return $$typeof;
                }
            }
          case REACT_PORTAL_TYPE:
            return $$typeof;
        }
      }
    }
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
      REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
      REACT_MEMO_TYPE = Symbol.for("react.memo"),
      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
      REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"),
      REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
    reactIs_development$1.ContextConsumer = REACT_CONSUMER_TYPE;
    reactIs_development$1.ContextProvider = REACT_CONTEXT_TYPE;
    reactIs_development$1.Element = REACT_ELEMENT_TYPE;
    reactIs_development$1.ForwardRef = REACT_FORWARD_REF_TYPE;
    reactIs_development$1.Fragment = REACT_FRAGMENT_TYPE;
    reactIs_development$1.Lazy = REACT_LAZY_TYPE;
    reactIs_development$1.Memo = REACT_MEMO_TYPE;
    reactIs_development$1.Portal = REACT_PORTAL_TYPE;
    reactIs_development$1.Profiler = REACT_PROFILER_TYPE;
    reactIs_development$1.StrictMode = REACT_STRICT_MODE_TYPE;
    reactIs_development$1.Suspense = REACT_SUSPENSE_TYPE;
    reactIs_development$1.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
    reactIs_development$1.isContextConsumer = function (object) {
      return typeOf(object) === REACT_CONSUMER_TYPE;
    };
    reactIs_development$1.isContextProvider = function (object) {
      return typeOf(object) === REACT_CONTEXT_TYPE;
    };
    reactIs_development$1.isElement = function (object) {
      return "object" === _typeof(object) && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    };
    reactIs_development$1.isForwardRef = function (object) {
      return typeOf(object) === REACT_FORWARD_REF_TYPE;
    };
    reactIs_development$1.isFragment = function (object) {
      return typeOf(object) === REACT_FRAGMENT_TYPE;
    };
    reactIs_development$1.isLazy = function (object) {
      return typeOf(object) === REACT_LAZY_TYPE;
    };
    reactIs_development$1.isMemo = function (object) {
      return typeOf(object) === REACT_MEMO_TYPE;
    };
    reactIs_development$1.isPortal = function (object) {
      return typeOf(object) === REACT_PORTAL_TYPE;
    };
    reactIs_development$1.isProfiler = function (object) {
      return typeOf(object) === REACT_PROFILER_TYPE;
    };
    reactIs_development$1.isStrictMode = function (object) {
      return typeOf(object) === REACT_STRICT_MODE_TYPE;
    };
    reactIs_development$1.isSuspense = function (object) {
      return typeOf(object) === REACT_SUSPENSE_TYPE;
    };
    reactIs_development$1.isSuspenseList = function (object) {
      return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
    };
    reactIs_development$1.isValidElementType = function (type) {
      return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || "object" === _typeof(type) && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? true : false;
    };
    reactIs_development$1.typeOf = typeOf;
  }();
  return reactIs_development$1;
}
var hasRequiredReactIs$1;
function requireReactIs$1() {
  if (hasRequiredReactIs$1) return reactIs$1.exports;
  hasRequiredReactIs$1 = 1;
  if (process.env.NODE_ENV === 'production') {
    reactIs$1.exports = requireReactIs_production();
  } else {
    reactIs$1.exports = requireReactIs_development$1();
  }
  return reactIs$1.exports;
}
var reactIsExports$1 = requireReactIs$1();
var index$1 = /*@__PURE__*/getDefaultExportFromCjs$3(reactIsExports$1);
var ReactIs19 = /*#__PURE__*/_mergeNamespaces({
  __proto__: null,
  default: index$1
}, [reactIsExports$1]);
var reactIs = {
  exports: {}
};
var reactIs_production_min = {};

/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min) return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var b = Symbol.for("react.element"),
    c = Symbol.for("react.portal"),
    d = Symbol.for("react.fragment"),
    e = Symbol.for("react.strict_mode"),
    f = Symbol.for("react.profiler"),
    g = Symbol.for("react.provider"),
    h = Symbol.for("react.context"),
    k = Symbol.for("react.server_context"),
    l = Symbol.for("react.forward_ref"),
    m = Symbol.for("react.suspense"),
    n = Symbol.for("react.suspense_list"),
    p = Symbol.for("react.memo"),
    q = Symbol.for("react.lazy"),
    t = Symbol.for("react.offscreen"),
    u;
  u = Symbol.for("react.module.reference");
  function v(a) {
    if ("object" === _typeof(a) && null !== a) {
      var r = a.$$typeof;
      switch (r) {
        case b:
          switch (a = a.type, a) {
            case d:
            case f:
            case e:
            case m:
            case n:
              return a;
            default:
              switch (a = a && a.$$typeof, a) {
                case k:
                case h:
                case l:
                case q:
                case p:
                case g:
                  return a;
                default:
                  return r;
              }
          }
        case c:
          return r;
      }
    }
  }
  reactIs_production_min.ContextConsumer = h;
  reactIs_production_min.ContextProvider = g;
  reactIs_production_min.Element = b;
  reactIs_production_min.ForwardRef = l;
  reactIs_production_min.Fragment = d;
  reactIs_production_min.Lazy = q;
  reactIs_production_min.Memo = p;
  reactIs_production_min.Portal = c;
  reactIs_production_min.Profiler = f;
  reactIs_production_min.StrictMode = e;
  reactIs_production_min.Suspense = m;
  reactIs_production_min.SuspenseList = n;
  reactIs_production_min.isAsyncMode = function () {
    return false;
  };
  reactIs_production_min.isConcurrentMode = function () {
    return false;
  };
  reactIs_production_min.isContextConsumer = function (a) {
    return v(a) === h;
  };
  reactIs_production_min.isContextProvider = function (a) {
    return v(a) === g;
  };
  reactIs_production_min.isElement = function (a) {
    return "object" === _typeof(a) && null !== a && a.$$typeof === b;
  };
  reactIs_production_min.isForwardRef = function (a) {
    return v(a) === l;
  };
  reactIs_production_min.isFragment = function (a) {
    return v(a) === d;
  };
  reactIs_production_min.isLazy = function (a) {
    return v(a) === q;
  };
  reactIs_production_min.isMemo = function (a) {
    return v(a) === p;
  };
  reactIs_production_min.isPortal = function (a) {
    return v(a) === c;
  };
  reactIs_production_min.isProfiler = function (a) {
    return v(a) === f;
  };
  reactIs_production_min.isStrictMode = function (a) {
    return v(a) === e;
  };
  reactIs_production_min.isSuspense = function (a) {
    return v(a) === m;
  };
  reactIs_production_min.isSuspenseList = function (a) {
    return v(a) === n;
  };
  reactIs_production_min.isValidElementType = function (a) {
    return "string" === typeof a || "function" === typeof a || a === d || a === f || a === e || a === m || a === n || a === t || "object" === _typeof(a) && null !== a && (a.$$typeof === q || a.$$typeof === p || a.$$typeof === g || a.$$typeof === h || a.$$typeof === l || a.$$typeof === u || void 0 !== a.getModuleId) ? true : false;
  };
  reactIs_production_min.typeOf = v;
  return reactIs_production_min;
}
var reactIs_development = {};

/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_development;
function requireReactIs_development() {
  if (hasRequiredReactIs_development) return reactIs_development;
  hasRequiredReactIs_development = 1;
  if (process.env.NODE_ENV !== "production") {
    (function () {
      // ATTENTION
      // When adding new symbols to this file,
      // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
      // The Symbol used to tag the ReactElement-like types.
      var REACT_ELEMENT_TYPE = Symbol.for('react.element');
      var REACT_PORTAL_TYPE = Symbol.for('react.portal');
      var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
      var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
      var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
      var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
      var REACT_CONTEXT_TYPE = Symbol.for('react.context');
      var REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');
      var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
      var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
      var REACT_MEMO_TYPE = Symbol.for('react.memo');
      var REACT_LAZY_TYPE = Symbol.for('react.lazy');
      var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');

      // -----------------------------------------------------------------------------

      var enableScopeAPI = false; // Experimental Create Event Handle API.
      var enableCacheElement = false;
      var enableTransitionTracing = false; // No known bugs, but needs performance testing

      var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber
      // stuff. Intended to enable React core members to more easily debug scheduling
      // issues in DEV builds.

      var enableDebugTracing = false; // Track which Fiber(s) schedule render work.

      var REACT_MODULE_REFERENCE;
      {
        REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
      }
      function isValidElementType(type) {
        if (typeof type === 'string' || typeof type === 'function') {
          return true;
        } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).

        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
          return true;
        }
        if (_typeof(type) === 'object' && type !== null) {
          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE ||
          // This needs to include all possible module reference object
          // types supported by any Flight configuration anywhere since
          // we don't know which Flight build this will end up being used
          // with.
          type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
            return true;
          }
        }
        return false;
      }
      function typeOf(object) {
        if (_typeof(object) === 'object' && object !== null) {
          var $$typeof = object.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              var type = object.type;
              switch (type) {
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                case REACT_SUSPENSE_LIST_TYPE:
                  return type;
                default:
                  var $$typeofType = type && type.$$typeof;
                  switch ($$typeofType) {
                    case REACT_SERVER_CONTEXT_TYPE:
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                    case REACT_PROVIDER_TYPE:
                      return $$typeofType;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
        return undefined;
      }
      var ContextConsumer = REACT_CONTEXT_TYPE;
      var ContextProvider = REACT_PROVIDER_TYPE;
      var Element = REACT_ELEMENT_TYPE;
      var ForwardRef = REACT_FORWARD_REF_TYPE;
      var Fragment = REACT_FRAGMENT_TYPE;
      var Lazy = REACT_LAZY_TYPE;
      var Memo = REACT_MEMO_TYPE;
      var Portal = REACT_PORTAL_TYPE;
      var Profiler = REACT_PROFILER_TYPE;
      var StrictMode = REACT_STRICT_MODE_TYPE;
      var Suspense = REACT_SUSPENSE_TYPE;
      var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
      var hasWarnedAboutDeprecatedIsAsyncMode = false;
      var hasWarnedAboutDeprecatedIsConcurrentMode = false; // AsyncMode should be deprecated

      function isAsyncMode(object) {
        {
          if (!hasWarnedAboutDeprecatedIsAsyncMode) {
            hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

            console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
          }
        }
        return false;
      }
      function isConcurrentMode(object) {
        {
          if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
            hasWarnedAboutDeprecatedIsConcurrentMode = true; // Using console['warn'] to evade Babel and ESLint

            console['warn']('The ReactIs.isConcurrentMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
          }
        }
        return false;
      }
      function isContextConsumer(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
      }
      function isContextProvider(object) {
        return typeOf(object) === REACT_PROVIDER_TYPE;
      }
      function isElement(object) {
        return _typeof(object) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function isForwardRef(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      }
      function isFragment(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      }
      function isLazy(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      }
      function isMemo(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      }
      function isPortal(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      }
      function isProfiler(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      }
      function isStrictMode(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      }
      function isSuspense(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      }
      function isSuspenseList(object) {
        return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
      }
      reactIs_development.ContextConsumer = ContextConsumer;
      reactIs_development.ContextProvider = ContextProvider;
      reactIs_development.Element = Element;
      reactIs_development.ForwardRef = ForwardRef;
      reactIs_development.Fragment = Fragment;
      reactIs_development.Lazy = Lazy;
      reactIs_development.Memo = Memo;
      reactIs_development.Portal = Portal;
      reactIs_development.Profiler = Profiler;
      reactIs_development.StrictMode = StrictMode;
      reactIs_development.Suspense = Suspense;
      reactIs_development.SuspenseList = SuspenseList;
      reactIs_development.isAsyncMode = isAsyncMode;
      reactIs_development.isConcurrentMode = isConcurrentMode;
      reactIs_development.isContextConsumer = isContextConsumer;
      reactIs_development.isContextProvider = isContextProvider;
      reactIs_development.isElement = isElement;
      reactIs_development.isForwardRef = isForwardRef;
      reactIs_development.isFragment = isFragment;
      reactIs_development.isLazy = isLazy;
      reactIs_development.isMemo = isMemo;
      reactIs_development.isPortal = isPortal;
      reactIs_development.isProfiler = isProfiler;
      reactIs_development.isStrictMode = isStrictMode;
      reactIs_development.isSuspense = isSuspense;
      reactIs_development.isSuspenseList = isSuspenseList;
      reactIs_development.isValidElementType = isValidElementType;
      reactIs_development.typeOf = typeOf;
    })();
  }
  return reactIs_development;
}
var hasRequiredReactIs;
function requireReactIs() {
  if (hasRequiredReactIs) return reactIs.exports;
  hasRequiredReactIs = 1;
  if (process.env.NODE_ENV === 'production') {
    reactIs.exports = requireReactIs_production_min();
  } else {
    reactIs.exports = requireReactIs_development();
  }
  return reactIs.exports;
}
var reactIsExports = requireReactIs();
var index = /*@__PURE__*/getDefaultExportFromCjs$3(reactIsExports);
var ReactIs18 = /*#__PURE__*/_mergeNamespaces({
  __proto__: null,
  default: index
}, [reactIsExports]);
var reactIsMethods = ["isAsyncMode", "isConcurrentMode", "isContextConsumer", "isContextProvider", "isElement", "isForwardRef", "isFragment", "isLazy", "isMemo", "isPortal", "isProfiler", "isStrictMode", "isSuspense", "isSuspenseList", "isValidElementType"];
var ReactIs = Object.fromEntries(reactIsMethods.map(function (m) {
  return [m, function (v) {
    return ReactIs18[m](v) || ReactIs19[m](v);
  }];
}));
// Given element.props.children, or subtree during recursive traversal,
// return flattened array of children.
function getChildren(arg) {
  var children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  if (Array.isArray(arg)) {
    var _iterator2 = _createForOfIteratorHelper$8(arg),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var item = _step2.value;
        getChildren(item, children);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  } else if (arg != null && arg !== false && arg !== "") {
    children.push(arg);
  }
  return children;
}
function getType$2(element) {
  var type = element.type;
  if (typeof type === "string") {
    return type;
  }
  if (typeof type === "function") {
    return type.displayName || type.name || "Unknown";
  }
  if (ReactIs.isFragment(element)) {
    return "React.Fragment";
  }
  if (ReactIs.isSuspense(element)) {
    return "React.Suspense";
  }
  if (_typeof(type) === "object" && type !== null) {
    if (ReactIs.isContextProvider(element)) {
      return "Context.Provider";
    }
    if (ReactIs.isContextConsumer(element)) {
      return "Context.Consumer";
    }
    if (ReactIs.isForwardRef(element)) {
      if (type.displayName) {
        return type.displayName;
      }
      var functionName = type.render.displayName || type.render.name || "";
      return functionName === "" ? "ForwardRef" : "ForwardRef(".concat(functionName, ")");
    }
    if (ReactIs.isMemo(element)) {
      var _functionName = type.displayName || type.type.displayName || type.type.name || "";
      return _functionName === "" ? "Memo" : "Memo(".concat(_functionName, ")");
    }
  }
  return "UNDEFINED";
}
function getPropKeys$1(element) {
  var props = element.props;
  return Object.keys(props).filter(function (key) {
    return key !== "children" && props[key] !== undefined;
  }).sort();
}
var serialize$1$1 = function serialize$1(element, config, indentation, depth, refs, printer) {
  return ++depth > config.maxDepth ? printElementAsLeaf(getType$2(element), config) : printElement(getType$2(element), printProps(getPropKeys$1(element), element.props, config, indentation + config.indent, depth, refs, printer), printChildren(getChildren(element.props.children), config, indentation + config.indent, depth, refs, printer), config, indentation);
};
var test$1$1 = function test$1(val) {
  return val != null && ReactIs.isElement(val);
};
var plugin$1 = {
  serialize: serialize$1$1,
  test: test$1$1
};
var testSymbol = typeof Symbol === "function" && Symbol.for ? Symbol.for("react.test.json") : 245830487;
function getPropKeys(object) {
  var props = object.props;
  return props ? Object.keys(props).filter(function (key) {
    return props[key] !== undefined;
  }).sort() : [];
}
var serialize$6 = function serialize(object, config, indentation, depth, refs, printer) {
  return ++depth > config.maxDepth ? printElementAsLeaf(object.type, config) : printElement(object.type, object.props ? printProps(getPropKeys(object), object.props, config, indentation + config.indent, depth, refs, printer) : "", object.children ? printChildren(object.children, config, indentation + config.indent, depth, refs, printer) : "", config, indentation);
};
var test$6 = function test(val) {
  return val && val.$$typeof === testSymbol;
};
var plugin$6 = {
  serialize: serialize$6,
  test: test$6
};
var toString$2 = Object.prototype.toString;
var toISOString = Date.prototype.toISOString;
var errorToString = Error.prototype.toString;
var regExpToString = RegExp.prototype.toString;
/**
* Explicitly comparing typeof constructor to function avoids undefined as name
* when mock identity-obj-proxy returns the key as the value for any key.
*/
function getConstructorName(val) {
  return typeof val.constructor === "function" && val.constructor.name || "Object";
}
/** Is val is equal to global window object? Works even if it does not exist :) */
function isWindow(val) {
  return typeof window !== "undefined" && val === window;
}
// eslint-disable-next-line regexp/no-super-linear-backtracking
var SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
var NEWLINE_REGEXP = /\n/g;
var PrettyFormatPluginError = /*#__PURE__*/function (_Error) {
  function PrettyFormatPluginError(message, stack) {
    var _this;
    _classCallCheck(this, PrettyFormatPluginError);
    _this = _callSuper$6(this, PrettyFormatPluginError, [message]);
    _this.stack = stack;
    _this.name = _this.constructor.name;
    return _this;
  }
  _inherits(PrettyFormatPluginError, _Error);
  return _createClass(PrettyFormatPluginError);
}(/*#__PURE__*/_wrapNativeSuper(Error));
function isToStringedArrayType(toStringed) {
  return toStringed === "[object Array]" || toStringed === "[object ArrayBuffer]" || toStringed === "[object DataView]" || toStringed === "[object Float32Array]" || toStringed === "[object Float64Array]" || toStringed === "[object Int8Array]" || toStringed === "[object Int16Array]" || toStringed === "[object Int32Array]" || toStringed === "[object Uint8Array]" || toStringed === "[object Uint8ClampedArray]" || toStringed === "[object Uint16Array]" || toStringed === "[object Uint32Array]";
}
function printNumber(val) {
  return Object.is(val, -0) ? "-0" : String(val);
}
function printBigInt(val) {
  return String("".concat(val, "n"));
}
function printFunction(val, printFunctionName) {
  if (!printFunctionName) {
    return "[Function]";
  }
  return "[Function ".concat(val.name || "anonymous", "]");
}
function printSymbol(val) {
  return String(val).replace(SYMBOL_REGEXP, "Symbol($1)");
}
function printError(val) {
  return "[".concat(errorToString.call(val), "]");
}
/**
* The first port of call for printing an object, handles most of the
* data-types in JS.
*/
function printBasicValue(val, printFunctionName, escapeRegex, escapeString) {
  if (val === true || val === false) {
    return "".concat(val);
  }
  if (val === undefined) {
    return "undefined";
  }
  if (val === null) {
    return "null";
  }
  var typeOf = _typeof(val);
  if (typeOf === "number") {
    return printNumber(val);
  }
  if (typeOf === "bigint") {
    return printBigInt(val);
  }
  if (typeOf === "string") {
    if (escapeString) {
      return "\"".concat(val.replaceAll(/"|\\/g, "\\$&"), "\"");
    }
    return "\"".concat(val, "\"");
  }
  if (typeOf === "function") {
    return printFunction(val, printFunctionName);
  }
  if (typeOf === "symbol") {
    return printSymbol(val);
  }
  var toStringed = toString$2.call(val);
  if (toStringed === "[object WeakMap]") {
    return "WeakMap {}";
  }
  if (toStringed === "[object WeakSet]") {
    return "WeakSet {}";
  }
  if (toStringed === "[object Function]" || toStringed === "[object GeneratorFunction]") {
    return printFunction(val, printFunctionName);
  }
  if (toStringed === "[object Symbol]") {
    return printSymbol(val);
  }
  if (toStringed === "[object Date]") {
    return Number.isNaN(+val) ? "Date { NaN }" : toISOString.call(val);
  }
  if (toStringed === "[object Error]") {
    return printError(val);
  }
  if (toStringed === "[object RegExp]") {
    if (escapeRegex) {
      // https://github.com/benjamingr/RegExp.escape/blob/main/polyfill.js
      return regExpToString.call(val).replaceAll(/[$()*+.?[\\\]^{|}]/g, "\\$&");
    }
    return regExpToString.call(val);
  }
  if (val instanceof Error) {
    return printError(val);
  }
  return null;
}
/**
* Handles more complex objects ( such as objects with circular references.
* maps and sets etc )
*/
function printComplexValue(val, config, indentation, depth, refs, hasCalledToJSON) {
  if (refs.includes(val)) {
    return "[Circular]";
  }
  refs = _toConsumableArray(refs);
  refs.push(val);
  var hitMaxDepth = ++depth > config.maxDepth;
  var min = config.min;
  if (config.callToJSON && !hitMaxDepth && val.toJSON && typeof val.toJSON === "function" && !hasCalledToJSON) {
    return printer(val.toJSON(), config, indentation, depth, refs, true);
  }
  var toStringed = toString$2.call(val);
  if (toStringed === "[object Arguments]") {
    return hitMaxDepth ? "[Arguments]" : "".concat(min ? "" : "Arguments ", "[").concat(printListItems(val, config, indentation, depth, refs, printer), "]");
  }
  if (isToStringedArrayType(toStringed)) {
    return hitMaxDepth ? "[".concat(val.constructor.name, "]") : "".concat(min ? "" : !config.printBasicPrototype && val.constructor.name === "Array" ? "" : "".concat(val.constructor.name, " "), "[").concat(printListItems(val, config, indentation, depth, refs, printer), "]");
  }
  if (toStringed === "[object Map]") {
    return hitMaxDepth ? "[Map]" : "Map {".concat(printIteratorEntries(val.entries(), config, indentation, depth, refs, printer, " => "), "}");
  }
  if (toStringed === "[object Set]") {
    return hitMaxDepth ? "[Set]" : "Set {".concat(printIteratorValues(val.values(), config, indentation, depth, refs, printer), "}");
  }
  // Avoid failure to serialize global window object in jsdom test environment.
  // For example, not even relevant if window is prop of React element.
  return hitMaxDepth || isWindow(val) ? "[".concat(getConstructorName(val), "]") : "".concat(min ? "" : !config.printBasicPrototype && getConstructorName(val) === "Object" ? "" : "".concat(getConstructorName(val), " "), "{").concat(printObjectProperties(val, config, indentation, depth, refs, printer), "}");
}
var ErrorPlugin = {
  test: function test(val) {
    return val && val instanceof Error;
  },
  serialize: function serialize(val, config, indentation, depth, refs, printer) {
    if (refs.includes(val)) {
      return "[Circular]";
    }
    refs = [].concat(_toConsumableArray(refs), [val]);
    var hitMaxDepth = ++depth > config.maxDepth;
    var message = val.message,
      cause = val.cause,
      rest = _objectWithoutProperties(val, _excluded$2);
    var entries = _objectSpread$9(_objectSpread$9(_objectSpread$9({
      message: message
    }, typeof cause !== "undefined" ? {
      cause: cause
    } : {}), val instanceof AggregateError ? {
      errors: val.errors
    } : {}), rest);
    var name = val.name !== "Error" ? val.name : getConstructorName(val);
    return hitMaxDepth ? "[".concat(name, "]") : "".concat(name, " {").concat(printIteratorEntries(Object.entries(entries).values(), config, indentation, depth, refs, printer), "}");
  }
};
function isNewPlugin(plugin) {
  return plugin.serialize != null;
}
function printPlugin(plugin, val, config, indentation, depth, refs) {
  var printed;
  try {
    printed = isNewPlugin(plugin) ? plugin.serialize(val, config, indentation, depth, refs, printer) : plugin.print(val, function (valChild) {
      return printer(valChild, config, indentation, depth, refs);
    }, function (str) {
      var indentationNext = indentation + config.indent;
      return indentationNext + str.replaceAll(NEWLINE_REGEXP, "\n".concat(indentationNext));
    }, {
      edgeSpacing: config.spacingOuter,
      min: config.min,
      spacing: config.spacingInner
    }, config.colors);
  } catch (error) {
    throw new PrettyFormatPluginError(error.message, error.stack);
  }
  if (typeof printed !== "string") {
    throw new TypeError("pretty-format: Plugin must return type \"string\" but instead returned \"".concat(_typeof(printed), "\"."));
  }
  return printed;
}
function findPlugin(plugins, val) {
  var _iterator3 = _createForOfIteratorHelper$8(plugins),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _plugin = _step3.value;
      try {
        if (_plugin.test(val)) {
          return _plugin;
        }
      } catch (error) {
        throw new PrettyFormatPluginError(error.message, error.stack);
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  return null;
}
function printer(val, config, indentation, depth, refs, hasCalledToJSON) {
  var plugin = findPlugin(config.plugins, val);
  if (plugin !== null) {
    return printPlugin(plugin, val, config, indentation, depth, refs);
  }
  var basicResult = printBasicValue(val, config.printFunctionName, config.escapeRegex, config.escapeString);
  if (basicResult !== null) {
    return basicResult;
  }
  return printComplexValue(val, config, indentation, depth, refs, hasCalledToJSON);
}
var DEFAULT_THEME = {
  comment: "gray",
  content: "reset",
  prop: "yellow",
  tag: "cyan",
  value: "green"
};
var DEFAULT_THEME_KEYS = Object.keys(DEFAULT_THEME);
var DEFAULT_OPTIONS = {
  callToJSON: true,
  compareKeys: undefined,
  escapeRegex: false,
  escapeString: true,
  highlight: false,
  indent: 2,
  maxDepth: Number.POSITIVE_INFINITY,
  maxWidth: Number.POSITIVE_INFINITY,
  min: false,
  plugins: [],
  printBasicPrototype: true,
  printFunctionName: true,
  theme: DEFAULT_THEME
};
function validateOptions(options) {
  for (var _i = 0, _Object$keys = Object.keys(options); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    if (!Object.prototype.hasOwnProperty.call(DEFAULT_OPTIONS, key)) {
      throw new Error("pretty-format: Unknown option \"".concat(key, "\"."));
    }
  }
  if (options.min && options.indent !== undefined && options.indent !== 0) {
    throw new Error("pretty-format: Options \"min\" and \"indent\" cannot be used together.");
  }
}
function getColorsHighlight() {
  return DEFAULT_THEME_KEYS.reduce(function (colors, key) {
    var value = DEFAULT_THEME[key];
    var color = value && s[value];
    if (color && typeof color.close === "string" && typeof color.open === "string") {
      colors[key] = color;
    } else {
      throw new Error("pretty-format: Option \"theme\" has a key \"".concat(key, "\" whose value \"").concat(value, "\" is undefined in ansi-styles."));
    }
    return colors;
  }, Object.create(null));
}
function getColorsEmpty() {
  return DEFAULT_THEME_KEYS.reduce(function (colors, key) {
    colors[key] = {
      close: "",
      open: ""
    };
    return colors;
  }, Object.create(null));
}
function getPrintFunctionName(options) {
  var _ref;
  return (_ref = options === null || options === void 0 ? void 0 : options.printFunctionName) !== null && _ref !== void 0 ? _ref : DEFAULT_OPTIONS.printFunctionName;
}
function getEscapeRegex(options) {
  var _ref2;
  return (_ref2 = options === null || options === void 0 ? void 0 : options.escapeRegex) !== null && _ref2 !== void 0 ? _ref2 : DEFAULT_OPTIONS.escapeRegex;
}
function getEscapeString(options) {
  var _ref3;
  return (_ref3 = options === null || options === void 0 ? void 0 : options.escapeString) !== null && _ref3 !== void 0 ? _ref3 : DEFAULT_OPTIONS.escapeString;
}
function getConfig(options) {
  var _ref4, _ref5, _ref6, _ref7, _ref8, _ref9, _ref0;
  return {
    callToJSON: (_ref4 = options === null || options === void 0 ? void 0 : options.callToJSON) !== null && _ref4 !== void 0 ? _ref4 : DEFAULT_OPTIONS.callToJSON,
    colors: (options === null || options === void 0 ? void 0 : options.highlight) ? getColorsHighlight() : getColorsEmpty(),
    compareKeys: typeof (options === null || options === void 0 ? void 0 : options.compareKeys) === "function" || (options === null || options === void 0 ? void 0 : options.compareKeys) === null ? options.compareKeys : DEFAULT_OPTIONS.compareKeys,
    escapeRegex: getEscapeRegex(options),
    escapeString: getEscapeString(options),
    indent: (options === null || options === void 0 ? void 0 : options.min) ? "" : createIndent((_ref5 = options === null || options === void 0 ? void 0 : options.indent) !== null && _ref5 !== void 0 ? _ref5 : DEFAULT_OPTIONS.indent),
    maxDepth: (_ref6 = options === null || options === void 0 ? void 0 : options.maxDepth) !== null && _ref6 !== void 0 ? _ref6 : DEFAULT_OPTIONS.maxDepth,
    maxWidth: (_ref7 = options === null || options === void 0 ? void 0 : options.maxWidth) !== null && _ref7 !== void 0 ? _ref7 : DEFAULT_OPTIONS.maxWidth,
    min: (_ref8 = options === null || options === void 0 ? void 0 : options.min) !== null && _ref8 !== void 0 ? _ref8 : DEFAULT_OPTIONS.min,
    plugins: (_ref9 = options === null || options === void 0 ? void 0 : options.plugins) !== null && _ref9 !== void 0 ? _ref9 : DEFAULT_OPTIONS.plugins,
    printBasicPrototype: (_ref0 = options === null || options === void 0 ? void 0 : options.printBasicPrototype) !== null && _ref0 !== void 0 ? _ref0 : true,
    printFunctionName: getPrintFunctionName(options),
    spacingInner: (options === null || options === void 0 ? void 0 : options.min) ? " " : "\n",
    spacingOuter: (options === null || options === void 0 ? void 0 : options.min) ? "" : "\n"
  };
}
function createIndent(indent) {
  return Array.from({
    length: indent + 1
  }).join(" ");
}
/**
* Returns a presentation string of your `val` object
* @param val any potential JavaScript object
* @param options Custom settings
*/
function format$1(val, options) {
  if (options) {
    validateOptions(options);
    if (options.plugins) {
      var _plugin2 = findPlugin(options.plugins, val);
      if (_plugin2 !== null) {
        return printPlugin(_plugin2, val, getConfig(options), "", 0, []);
      }
    }
  }
  var basicResult = printBasicValue(val, getPrintFunctionName(options), getEscapeRegex(options), getEscapeString(options));
  if (basicResult !== null) {
    return basicResult;
  }
  return printComplexValue(val, getConfig(options), "", 0, []);
}
var plugins = {
  AsymmetricMatcher: plugin$5,
  DOMCollection: plugin$4,
  DOMElement: plugin$3,
  Immutable: plugin$2,
  ReactElement: plugin$1,
  ReactTestComponent: plugin$6,
  Error: ErrorPlugin
};

var ansiColors$1 = {
  bold: ['1', '22'],
  dim: ['2', '22'],
  italic: ['3', '23'],
  underline: ['4', '24'],
  // 5 & 6 are blinking
  inverse: ['7', '27'],
  hidden: ['8', '28'],
  strike: ['9', '29'],
  // 10-20 are fonts
  // 21-29 are resets for 1-9
  black: ['30', '39'],
  red: ['31', '39'],
  green: ['32', '39'],
  yellow: ['33', '39'],
  blue: ['34', '39'],
  magenta: ['35', '39'],
  cyan: ['36', '39'],
  white: ['37', '39'],
  brightblack: ['30;1', '39'],
  brightred: ['31;1', '39'],
  brightgreen: ['32;1', '39'],
  brightyellow: ['33;1', '39'],
  brightblue: ['34;1', '39'],
  brightmagenta: ['35;1', '39'],
  brightcyan: ['36;1', '39'],
  brightwhite: ['37;1', '39'],
  grey: ['90', '39']
};
var styles$1 = {
  special: 'cyan',
  number: 'yellow',
  bigint: 'yellow',
  boolean: 'yellow',
  undefined: 'grey',
  null: 'bold',
  string: 'green',
  symbol: 'green',
  date: 'magenta',
  regexp: 'red'
};
var truncator$1 = '…';
function colorise$1(value, styleType) {
  var color = ansiColors$1[styles$1[styleType]] || ansiColors$1[styleType] || '';
  if (!color) {
    return String(value);
  }
  return "\x1B[".concat(color[0], "m").concat(String(value), "\x1B[").concat(color[1], "m");
}
function normaliseOptions$1() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    _ref$showHidden = _ref.showHidden,
    showHidden = _ref$showHidden === void 0 ? false : _ref$showHidden,
    _ref$depth = _ref.depth,
    depth = _ref$depth === void 0 ? 2 : _ref$depth,
    _ref$colors = _ref.colors,
    colors = _ref$colors === void 0 ? false : _ref$colors,
    _ref$customInspect = _ref.customInspect,
    customInspect = _ref$customInspect === void 0 ? true : _ref$customInspect,
    _ref$showProxy = _ref.showProxy,
    showProxy = _ref$showProxy === void 0 ? false : _ref$showProxy,
    _ref$maxArrayLength = _ref.maxArrayLength,
    maxArrayLength = _ref$maxArrayLength === void 0 ? Infinity : _ref$maxArrayLength,
    _ref$breakLength = _ref.breakLength,
    breakLength = _ref$breakLength === void 0 ? Infinity : _ref$breakLength,
    _ref$seen = _ref.seen,
    seen = _ref$seen === void 0 ? [] : _ref$seen,
    _ref$truncate = _ref.truncate,
    truncate = _ref$truncate === void 0 ? Infinity : _ref$truncate,
    _ref$stylize = _ref.stylize,
    stylize = _ref$stylize === void 0 ? String : _ref$stylize;
  var inspect = arguments.length > 1 ? arguments[1] : undefined;
  var options = {
    showHidden: Boolean(showHidden),
    depth: Number(depth),
    colors: Boolean(colors),
    customInspect: Boolean(customInspect),
    showProxy: Boolean(showProxy),
    maxArrayLength: Number(maxArrayLength),
    breakLength: Number(breakLength),
    truncate: Number(truncate),
    seen: seen,
    inspect: inspect,
    stylize: stylize
  };
  if (options.colors) {
    options.stylize = colorise$1;
  }
  return options;
}
function isHighSurrogate$1(char) {
  return char >= "\uD800" && char <= "\uDBFF";
}
function truncate$1(string, length) {
  var tail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : truncator$1;
  string = String(string);
  var tailLength = tail.length;
  var stringLength = string.length;
  if (tailLength > length && stringLength > tailLength) {
    return tail;
  }
  if (stringLength > length && stringLength > tailLength) {
    var end = length - tailLength;
    if (end > 0 && isHighSurrogate$1(string[end - 1])) {
      end = end - 1;
    }
    return "".concat(string.slice(0, end)).concat(tail);
  }
  return string;
}
// eslint-disable-next-line complexity
function inspectList$1(list, options, inspectItem) {
  var separator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ', ';
  inspectItem = inspectItem || options.inspect;
  var size = list.length;
  if (size === 0) return '';
  var originalLength = options.truncate;
  var output = '';
  var peek = '';
  var truncated = '';
  for (var i = 0; i < size; i += 1) {
    var last = i + 1 === list.length;
    var secondToLast = i + 2 === list.length;
    truncated = "".concat(truncator$1, "(").concat(list.length - i, ")");
    var value = list[i];
    // If there is more than one remaining we need to account for a separator of `, `
    options.truncate = originalLength - output.length - (last ? 0 : separator.length);
    var string = peek || inspectItem(value, options) + (last ? '' : separator);
    var nextLength = output.length + string.length;
    var truncatedLength = nextLength + truncated.length;
    // If this is the last element, and adding it would
    // take us over length, but adding the truncator wouldn't - then break now
    if (last && nextLength > originalLength && output.length + truncated.length <= originalLength) {
      break;
    }
    // If this isn't the last or second to last element to scan,
    // but the string is already over length then break here
    if (!last && !secondToLast && truncatedLength > originalLength) {
      break;
    }
    // Peek at the next string to determine if we should
    // break early before adding this item to the output
    peek = last ? '' : inspectItem(list[i + 1], options) + (secondToLast ? '' : separator);
    // If we have one element left, but this element and
    // the next takes over length, the break early
    if (!last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength) {
      break;
    }
    output += string;
    // If the next element takes us to length -
    // but there are more after that, then we should truncate now
    if (!last && !secondToLast && nextLength + peek.length >= originalLength) {
      truncated = "".concat(truncator$1, "(").concat(list.length - i - 1, ")");
      break;
    }
    truncated = '';
  }
  return "".concat(output).concat(truncated);
}
function quoteComplexKey$1(key) {
  if (key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)) {
    return key;
  }
  return JSON.stringify(key).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
function inspectProperty$1(_ref2, options) {
  var _ref3 = _slicedToArray(_ref2, 2),
    key = _ref3[0],
    value = _ref3[1];
  options.truncate -= 2;
  if (typeof key === 'string') {
    key = quoteComplexKey$1(key);
  } else if (typeof key !== 'number') {
    key = "[".concat(options.inspect(key, options), "]");
  }
  options.truncate -= key.length;
  value = options.inspect(value, options);
  return "".concat(key, ": ").concat(value);
}

function inspectArray$1(array, options) {
  // Object.keys will always output the Array indices first, so we can slice by
  // `array.length` to get non-index properties
  var nonIndexProperties = Object.keys(array).slice(array.length);
  if (!array.length && !nonIndexProperties.length) return '[]';
  options.truncate -= 4;
  var listContents = inspectList$1(array, options);
  options.truncate -= listContents.length;
  var propertyContents = '';
  if (nonIndexProperties.length) {
    propertyContents = inspectList$1(nonIndexProperties.map(function (key) {
      return [key, array[key]];
    }), options, inspectProperty$1);
  }
  return "[ ".concat(listContents).concat(propertyContents ? ", ".concat(propertyContents) : '', " ]");
}

var getArrayName$1 = function getArrayName(array) {
  // We need to special case Node.js' Buffers, which report to be Uint8Array
  // @ts-ignore
  if (typeof Buffer === 'function' && array instanceof Buffer) {
    return 'Buffer';
  }
  if (array[Symbol.toStringTag]) {
    return array[Symbol.toStringTag];
  }
  return array.constructor.name;
};
function inspectTypedArray$1(array, options) {
  var name = getArrayName$1(array);
  options.truncate -= name.length + 4;
  // Object.keys will always output the Array indices first, so we can slice by
  // `array.length` to get non-index properties
  var nonIndexProperties = Object.keys(array).slice(array.length);
  if (!array.length && !nonIndexProperties.length) return "".concat(name, "[]");
  // As we know TypedArrays only contain Unsigned Integers, we can skip inspecting each one and simply
  // stylise the toString() value of them
  var output = '';
  for (var i = 0; i < array.length; i++) {
    var string = "".concat(options.stylize(truncate$1(array[i], options.truncate), 'number')).concat(i === array.length - 1 ? '' : ', ');
    options.truncate -= string.length;
    if (array[i] !== array.length && options.truncate <= 3) {
      output += "".concat(truncator$1, "(").concat(array.length - array[i] + 1, ")");
      break;
    }
    output += string;
  }
  var propertyContents = '';
  if (nonIndexProperties.length) {
    propertyContents = inspectList$1(nonIndexProperties.map(function (key) {
      return [key, array[key]];
    }), options, inspectProperty$1);
  }
  return "".concat(name, "[ ").concat(output).concat(propertyContents ? ", ".concat(propertyContents) : '', " ]");
}

function inspectDate$1(dateObject, options) {
  var stringRepresentation = dateObject.toJSON();
  if (stringRepresentation === null) {
    return 'Invalid Date';
  }
  var split = stringRepresentation.split('T');
  var date = split[0];
  // If we need to - truncate the time portion, but never the date
  return options.stylize("".concat(date, "T").concat(truncate$1(split[1], options.truncate - date.length - 1)), 'date');
}

function inspectFunction$1(func, options) {
  var functionType = func[Symbol.toStringTag] || 'Function';
  var name = func.name;
  if (!name) {
    return options.stylize("[".concat(functionType, "]"), 'special');
  }
  return options.stylize("[".concat(functionType, " ").concat(truncate$1(name, options.truncate - 11), "]"), 'special');
}

function inspectMapEntry$1(_ref, options) {
  var _ref2 = _slicedToArray(_ref, 2),
    key = _ref2[0],
    value = _ref2[1];
  options.truncate -= 4;
  key = options.inspect(key, options);
  options.truncate -= key.length;
  value = options.inspect(value, options);
  return "".concat(key, " => ").concat(value);
}
// IE11 doesn't support `map.entries()`
function mapToEntries$1(map) {
  var entries = [];
  map.forEach(function (value, key) {
    entries.push([key, value]);
  });
  return entries;
}
function inspectMap$1(map, options) {
  if (map.size === 0) return 'Map{}';
  options.truncate -= 7;
  return "Map{ ".concat(inspectList$1(mapToEntries$1(map), options, inspectMapEntry$1), " }");
}

var isNaN$1 = Number.isNaN || function (i) {
  return i !== i;
}; // eslint-disable-line no-self-compare
function inspectNumber$1(number, options) {
  if (isNaN$1(number)) {
    return options.stylize('NaN', 'number');
  }
  if (number === Infinity) {
    return options.stylize('Infinity', 'number');
  }
  if (number === -Infinity) {
    return options.stylize('-Infinity', 'number');
  }
  if (number === 0) {
    return options.stylize(1 / number === Infinity ? '+0' : '-0', 'number');
  }
  return options.stylize(truncate$1(String(number), options.truncate), 'number');
}

function inspectBigInt$1(number, options) {
  var nums = truncate$1(number.toString(), options.truncate - 1);
  if (nums !== truncator$1) nums += 'n';
  return options.stylize(nums, 'bigint');
}

function inspectRegExp$1(value, options) {
  var flags = value.toString().split('/')[2];
  var sourceLength = options.truncate - (2 + flags.length);
  var source = value.source;
  return options.stylize("/".concat(truncate$1(source, sourceLength), "/").concat(flags), 'regexp');
}

// IE11 doesn't support `Array.from(set)`
function arrayFromSet$1(set) {
  var values = [];
  set.forEach(function (value) {
    values.push(value);
  });
  return values;
}
function inspectSet$1(set, options) {
  if (set.size === 0) return 'Set{}';
  options.truncate -= 7;
  return "Set{ ".concat(inspectList$1(arrayFromSet$1(set), options), " }");
}

var stringEscapeChars$1 = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5" + "\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", 'g');
var escapeCharacters$1 = {
  '\b': '\\b',
  '\t': '\\t',
  '\n': '\\n',
  '\f': '\\f',
  '\r': '\\r',
  "'": "\\'",
  '\\': '\\\\'
};
var hex$1 = 16;
var unicodeLength$1 = 4;
function escape$1(char) {
  return escapeCharacters$1[char] || "\\u".concat("0000".concat(char.charCodeAt(0).toString(hex$1)).slice(-unicodeLength$1));
}
function inspectString$1(string, options) {
  if (stringEscapeChars$1.test(string)) {
    string = string.replace(stringEscapeChars$1, escape$1);
  }
  return options.stylize("'".concat(truncate$1(string, options.truncate - 2), "'"), 'string');
}

function inspectSymbol$1(value) {
  if ('description' in Symbol.prototype) {
    return value.description ? "Symbol(".concat(value.description, ")") : 'Symbol()';
  }
  return value.toString();
}

var getPromiseValue$2 = function getPromiseValue() {
  return 'Promise{…}';
};

function inspectObject$2(object, options) {
  var properties = Object.getOwnPropertyNames(object);
  var symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : [];
  if (properties.length === 0 && symbols.length === 0) {
    return '{}';
  }
  options.truncate -= 4;
  options.seen = options.seen || [];
  if (options.seen.includes(object)) {
    return '[Circular]';
  }
  options.seen.push(object);
  var propertyContents = inspectList$1(properties.map(function (key) {
    return [key, object[key]];
  }), options, inspectProperty$1);
  var symbolContents = inspectList$1(symbols.map(function (key) {
    return [key, object[key]];
  }), options, inspectProperty$1);
  options.seen.pop();
  var sep = '';
  if (propertyContents && symbolContents) {
    sep = ', ';
  }
  return "{ ".concat(propertyContents).concat(sep).concat(symbolContents, " }");
}

var toStringTag$1 = typeof Symbol !== 'undefined' && Symbol.toStringTag ? Symbol.toStringTag : false;
function inspectClass$1(value, options) {
  var name = '';
  if (toStringTag$1 && toStringTag$1 in value) {
    name = value[toStringTag$1];
  }
  name = name || value.constructor.name;
  // Babel transforms anonymous classes to the name `_class`
  if (!name || name === '_class') {
    name = '<Anonymous Class>';
  }
  options.truncate -= name.length;
  return "".concat(name).concat(inspectObject$2(value, options));
}

function inspectArguments$1(args, options) {
  if (args.length === 0) return 'Arguments[]';
  options.truncate -= 13;
  return "Arguments[ ".concat(inspectList$1(args, options), " ]");
}

var errorKeys$1 = ['stack', 'line', 'column', 'name', 'message', 'fileName', 'lineNumber', 'columnNumber', 'number', 'description', 'cause'];
function inspectObject$1(error, options) {
  var properties = Object.getOwnPropertyNames(error).filter(function (key) {
    return errorKeys$1.indexOf(key) === -1;
  });
  var name = error.name;
  options.truncate -= name.length;
  var message = '';
  if (typeof error.message === 'string') {
    message = truncate$1(error.message, options.truncate);
  } else {
    properties.unshift('message');
  }
  message = message ? ": ".concat(message) : '';
  options.truncate -= message.length + 5;
  options.seen = options.seen || [];
  if (options.seen.includes(error)) {
    return '[Circular]';
  }
  options.seen.push(error);
  var propertyContents = inspectList$1(properties.map(function (key) {
    return [key, error[key]];
  }), options, inspectProperty$1);
  return "".concat(name).concat(message).concat(propertyContents ? " { ".concat(propertyContents, " }") : '');
}

function inspectAttribute$1(_ref, options) {
  var _ref2 = _slicedToArray(_ref, 2),
    key = _ref2[0],
    value = _ref2[1];
  options.truncate -= 3;
  if (!value) {
    return "".concat(options.stylize(String(key), 'yellow'));
  }
  return "".concat(options.stylize(String(key), 'yellow'), "=").concat(options.stylize("\"".concat(value, "\""), 'string'));
}
function inspectNodeCollection$1(collection, options) {
  return inspectList$1(collection, options, inspectNode$1, '\n');
}
function inspectNode$1(node, options) {
  switch (node.nodeType) {
    case 1:
      return inspectHTML$1(node, options);
    case 3:
      return options.inspect(node.data, options);
    default:
      return options.inspect(node, options);
  }
}
// @ts-ignore (Deno doesn't have Element)
function inspectHTML$1(element, options) {
  var properties = element.getAttributeNames();
  var name = element.tagName.toLowerCase();
  var head = options.stylize("<".concat(name), 'special');
  var headClose = options.stylize(">", 'special');
  var tail = options.stylize("</".concat(name, ">"), 'special');
  options.truncate -= name.length * 2 + 5;
  var propertyContents = '';
  if (properties.length > 0) {
    propertyContents += ' ';
    propertyContents += inspectList$1(properties.map(function (key) {
      return [key, element.getAttribute(key)];
    }), options, inspectAttribute$1, ' ');
  }
  options.truncate -= propertyContents.length;
  var truncate = options.truncate;
  var children = inspectNodeCollection$1(element.children, options);
  if (children && children.length > truncate) {
    children = "".concat(truncator$1, "(").concat(element.children.length, ")");
  }
  return "".concat(head).concat(propertyContents).concat(headClose).concat(children).concat(tail);
}

var symbolsSupported$1 = typeof Symbol === 'function' && typeof Symbol.for === 'function';
var chaiInspect$1 = symbolsSupported$1 ? Symbol.for('chai/inspect') : '@@chai/inspect';
var nodeInspect$1 = Symbol.for('nodejs.util.inspect.custom');
var constructorMap$1 = new WeakMap();
var stringTagMap$1 = {};
var baseTypesMap$1 = {
  undefined: function undefined$1(value, options) {
    return options.stylize('undefined', 'undefined');
  },
  null: function _null(value, options) {
    return options.stylize('null', 'null');
  },
  boolean: function boolean(value, options) {
    return options.stylize(String(value), 'boolean');
  },
  Boolean: function Boolean(value, options) {
    return options.stylize(String(value), 'boolean');
  },
  number: inspectNumber$1,
  Number: inspectNumber$1,
  bigint: inspectBigInt$1,
  BigInt: inspectBigInt$1,
  string: inspectString$1,
  String: inspectString$1,
  function: inspectFunction$1,
  Function: inspectFunction$1,
  symbol: inspectSymbol$1,
  // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
  Symbol: inspectSymbol$1,
  Array: inspectArray$1,
  Date: inspectDate$1,
  Map: inspectMap$1,
  Set: inspectSet$1,
  RegExp: inspectRegExp$1,
  Promise: getPromiseValue$2,
  // WeakSet, WeakMap are totally opaque to us
  WeakSet: function WeakSet(value, options) {
    return options.stylize('WeakSet{…}', 'special');
  },
  WeakMap: function WeakMap(value, options) {
    return options.stylize('WeakMap{…}', 'special');
  },
  Arguments: inspectArguments$1,
  Int8Array: inspectTypedArray$1,
  Uint8Array: inspectTypedArray$1,
  Uint8ClampedArray: inspectTypedArray$1,
  Int16Array: inspectTypedArray$1,
  Uint16Array: inspectTypedArray$1,
  Int32Array: inspectTypedArray$1,
  Uint32Array: inspectTypedArray$1,
  Float32Array: inspectTypedArray$1,
  Float64Array: inspectTypedArray$1,
  Generator: function Generator() {
    return '';
  },
  DataView: function DataView() {
    return '';
  },
  ArrayBuffer: function ArrayBuffer() {
    return '';
  },
  Error: inspectObject$1,
  HTMLCollection: inspectNodeCollection$1,
  NodeList: inspectNodeCollection$1
};
// eslint-disable-next-line complexity
var inspectCustom$1 = function inspectCustom(value, options, type, inspectFn) {
  if (chaiInspect$1 in value && typeof value[chaiInspect$1] === 'function') {
    return value[chaiInspect$1](options);
  }
  if (nodeInspect$1 in value && typeof value[nodeInspect$1] === 'function') {
    return value[nodeInspect$1](options.depth, options, inspectFn);
  }
  if ('inspect' in value && typeof value.inspect === 'function') {
    return value.inspect(options.depth, options);
  }
  if ('constructor' in value && constructorMap$1.has(value.constructor)) {
    return constructorMap$1.get(value.constructor)(value, options);
  }
  if (stringTagMap$1[type]) {
    return stringTagMap$1[type](value, options);
  }
  return '';
};
var toString$1 = Object.prototype.toString;
// eslint-disable-next-line complexity
function inspect$2(value) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var options = normaliseOptions$1(opts, inspect$2);
  var customInspect = options.customInspect;
  var type = value === null ? 'null' : _typeof(value);
  if (type === 'object') {
    type = toString$1.call(value).slice(8, -1);
  }
  // If it is a base value that we already support, then use Loupe's inspector
  if (type in baseTypesMap$1) {
    return baseTypesMap$1[type](value, options);
  }
  // If `options.customInspect` is set to true then try to use the custom inspector
  if (customInspect && value) {
    var output = inspectCustom$1(value, options, type, inspect$2);
    if (output) {
      if (typeof output === 'string') return output;
      return inspect$2(output, options);
    }
  }
  var proto = value ? Object.getPrototypeOf(value) : false;
  // If it's a plain Object then use Loupe's inspector
  if (proto === Object.prototype || proto === null) {
    return inspectObject$2(value, options);
  }
  // Specifically account for HTMLElements
  // @ts-ignore
  if (value && typeof HTMLElement === 'function' && value instanceof HTMLElement) {
    return inspectHTML$1(value, options);
  }
  if ('constructor' in value) {
    // If it is a class, inspect it like an object but add the constructor name
    if (value.constructor !== Object) {
      return inspectClass$1(value, options);
    }
    // If it is an object with an anonymous prototype, display it as an object.
    return inspectObject$2(value, options);
  }
  // last chance to check if it's an object
  if (value === Object(value)) {
    return inspectObject$2(value, options);
  }
  // We have run out of options! Just stringify the value
  return options.stylize(String(value), type);
}

var _excluded$1 = ["maxLength"];
function ownKeys$8(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$8(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$8(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$8(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var AsymmetricMatcher$3 = plugins.AsymmetricMatcher,
  DOMCollection$2 = plugins.DOMCollection,
  DOMElement$2 = plugins.DOMElement,
  Immutable$2 = plugins.Immutable,
  ReactElement$2 = plugins.ReactElement,
  ReactTestComponent$2 = plugins.ReactTestComponent;
var PLUGINS$2 = [ReactTestComponent$2, ReactElement$2, DOMElement$2, DOMCollection$2, Immutable$2, AsymmetricMatcher$3];
function stringify(object) {
  var maxDepth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
    maxLength = _ref.maxLength,
    options = _objectWithoutProperties(_ref, _excluded$1);
  var MAX_LENGTH = maxLength !== null && maxLength !== void 0 ? maxLength : 1e4;
  var result;
  try {
    result = format$1(object, _objectSpread$8({
      maxDepth: maxDepth,
      escapeString: false,
      plugins: PLUGINS$2
    }, options));
  } catch (_unused) {
    result = format$1(object, _objectSpread$8({
      callToJSON: false,
      maxDepth: maxDepth,
      escapeString: false,
      plugins: PLUGINS$2
    }, options));
  }
  // Prevents infinite loop https://github.com/vitest-dev/vitest/issues/7249
  return result.length >= MAX_LENGTH && maxDepth > 1 ? stringify(object, Math.floor(Math.min(maxDepth, Number.MAX_SAFE_INTEGER) / 2), _objectSpread$8({
    maxLength: maxLength
  }, options)) : result;
}
var formatRegExp = /%[sdjifoOc%]/g;
function format() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (typeof args[0] !== "string") {
    var objects = [];
    for (var _i = 0; _i < args.length; _i++) {
      objects.push(inspect$1(args[_i], {
        depth: 0,
        colors: false
      }));
    }
    return objects.join(" ");
  }
  var len = args.length;
  var i = 1;
  var template = args[0];
  var str = String(template).replace(formatRegExp, function (x) {
    if (x === "%%") {
      return "%";
    }
    if (i >= len) {
      return x;
    }
    switch (x) {
      case "%s":
        {
          var value = args[i++];
          if (typeof value === "bigint") {
            return "".concat(value.toString(), "n");
          }
          if (typeof value === "number" && value === 0 && 1 / value < 0) {
            return "-0";
          }
          if (_typeof(value) === "object" && value !== null) {
            if (typeof value.toString === "function" && value.toString !== Object.prototype.toString) {
              return value.toString();
            }
            return inspect$1(value, {
              depth: 0,
              colors: false
            });
          }
          return String(value);
        }
      case "%d":
        {
          var _value = args[i++];
          if (typeof _value === "bigint") {
            return "".concat(_value.toString(), "n");
          }
          return Number(_value).toString();
        }
      case "%i":
        {
          var _value2 = args[i++];
          if (typeof _value2 === "bigint") {
            return "".concat(_value2.toString(), "n");
          }
          return Number.parseInt(String(_value2)).toString();
        }
      case "%f":
        return Number.parseFloat(String(args[i++])).toString();
      case "%o":
        return inspect$1(args[i++], {
          showHidden: true,
          showProxy: true
        });
      case "%O":
        return inspect$1(args[i++]);
      case "%c":
        {
          i++;
          return "";
        }
      case "%j":
        try {
          return JSON.stringify(args[i++]);
        } catch (err) {
          var m = err.message;
          if (m.includes("circular structure") || m.includes("cyclic structures") || m.includes("cyclic object")) {
            return "[Circular]";
          }
          throw err;
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (x === null || _typeof(x) !== "object") {
      str += " ".concat(x);
    } else {
      str += " ".concat(inspect$1(x));
    }
  }
  return str;
}
function inspect$1(obj) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (options.truncate === 0) {
    options.truncate = Number.POSITIVE_INFINITY;
  }
  return inspect$2(obj, options);
}
function objDisplay(obj) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (typeof options.truncate === "undefined") {
    options.truncate = 40;
  }
  var str = inspect$1(obj, options);
  var type = Object.prototype.toString.call(obj);
  if (options.truncate && str.length >= options.truncate) {
    if (type === "[object Function]") {
      var fn = obj;
      return !fn.name ? "[Function]" : "[Function: ".concat(fn.name, "]");
    } else if (type === "[object Array]") {
      return "[ Array(".concat(obj.length, ") ]");
    } else if (type === "[object Object]") {
      var keys = Object.keys(obj);
      var kstr = keys.length > 2 ? "".concat(keys.splice(0, 2).join(", "), ", ...") : keys.join(", ");
      return "{ Object (".concat(kstr, ") }");
    } else {
      return str;
    }
  }
  return str;
}
function getDefaultExportFromCjs$2(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function ownKeys$7(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$7(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$7(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$7(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _createForOfIteratorHelper$7(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$7(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray$7(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray$7(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$7(r, a) : void 0; } }
function _arrayLikeToArray$7(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
* Get original stacktrace without source map support the most performant way.
* - Create only 1 stack frame.
* - Rewrite prepareStackTrace to bypass "support-stack-trace" (usually takes ~250ms).
*/
function createSimpleStackTrace(options) {
  var _ref = options || {},
    _ref$message = _ref.message,
    message = _ref$message === void 0 ? "$$stack trace error" : _ref$message,
    _ref$stackTraceLimit = _ref.stackTraceLimit,
    stackTraceLimit = _ref$stackTraceLimit === void 0 ? 1 : _ref$stackTraceLimit;
  var limit = Error.stackTraceLimit;
  var prepareStackTrace = Error.prepareStackTrace;
  Error.stackTraceLimit = stackTraceLimit;
  Error.prepareStackTrace = function (e) {
    return e.stack;
  };
  var err = new Error(message);
  var stackTrace = err.stack || "";
  Error.prepareStackTrace = prepareStackTrace;
  Error.stackTraceLimit = limit;
  return stackTrace;
}
function assertTypes(value, name, types) {
  var receivedType = _typeof(value);
  var pass = types.includes(receivedType);
  if (!pass) {
    throw new TypeError("".concat(name, " value must be ").concat(types.join(" or "), ", received \"").concat(receivedType, "\""));
  }
}
function toArray(array) {
  if (array === null || array === undefined) {
    array = [];
  }
  if (Array.isArray(array)) {
    return array;
  }
  return [array];
}
function isObject$1(item) {
  return item != null && _typeof(item) === "object" && !Array.isArray(item);
}
function isFinalObj(obj) {
  return obj === Object.prototype || obj === Function.prototype || obj === RegExp.prototype;
}
function getType$1(value) {
  return Object.prototype.toString.apply(value).slice(8, -1);
}
function collectOwnProperties(obj, collector) {
  var collect = typeof collector === "function" ? collector : function (key) {
    return collector.add(key);
  };
  Object.getOwnPropertyNames(obj).forEach(collect);
  Object.getOwnPropertySymbols(obj).forEach(collect);
}
function getOwnProperties(obj) {
  var ownProps = new Set();
  if (isFinalObj(obj)) {
    return [];
  }
  collectOwnProperties(obj, ownProps);
  return Array.from(ownProps);
}
var defaultCloneOptions = {
  forceWritable: false
};
function deepClone(val) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultCloneOptions;
  var seen = new WeakMap();
  return clone(val, seen, options);
}
function clone(val, seen) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultCloneOptions;
  var k, out;
  if (seen.has(val)) {
    return seen.get(val);
  }
  if (Array.isArray(val)) {
    out = Array.from({
      length: k = val.length
    });
    seen.set(val, out);
    while (k--) {
      out[k] = clone(val[k], seen, options);
    }
    return out;
  }
  if (Object.prototype.toString.call(val) === "[object Object]") {
    out = Object.create(Object.getPrototypeOf(val));
    seen.set(val, out);
    // we don't need properties from prototype
    var props = getOwnProperties(val);
    var _iterator = _createForOfIteratorHelper$7(props),
      _step;
    try {
      var _loop = function _loop() {
        var k = _step.value;
        var descriptor = Object.getOwnPropertyDescriptor(val, k);
        if (!descriptor) {
          return 1; // continue
        }
        var cloned = clone(val[k], seen, options);
        if (options.forceWritable) {
          Object.defineProperty(out, k, {
            enumerable: descriptor.enumerable,
            configurable: true,
            writable: true,
            value: cloned
          });
        } else if ("get" in descriptor) {
          Object.defineProperty(out, k, _objectSpread$7(_objectSpread$7({}, descriptor), {}, {
            get: function get() {
              return cloned;
            }
          }));
        } else {
          Object.defineProperty(out, k, _objectSpread$7(_objectSpread$7({}, descriptor), {}, {
            value: cloned
          }));
        }
      };
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        if (_loop()) continue;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return out;
  }
  return val;
}
function noop() {}
function objectAttr(source, path) {
  var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
  // a[3].b -> a.3.b
  var paths = path.replace(/\[(\d+)\]/g, ".$1").split(".");
  var result = source;
  var _iterator2 = _createForOfIteratorHelper$7(paths),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var p = _step2.value;
      result = new Object(result)[p];
      if (result === undefined) {
        return defaultValue;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return result;
}
function createDefer() {
  var resolve = null;
  var reject = null;
  var p = new Promise(function (_resolve, _reject) {
    resolve = _resolve;
    reject = _reject;
  });
  p.resolve = resolve;
  p.reject = reject;
  return p;
}
function isNegativeNaN(val) {
  if (!Number.isNaN(val)) {
    return false;
  }
  var f64 = new Float64Array(1);
  f64[0] = val;
  var u32 = new Uint32Array(f64.buffer);
  var isNegative = u32[1] >>> 31 === 1;
  return isNegative;
}

var jsTokens_1$2;
var hasRequiredJsTokens$1;
function requireJsTokens$1() {
  if (hasRequiredJsTokens$1) return jsTokens_1$2;
  hasRequiredJsTokens$1 = 1;
  // Copyright 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023 Simon Lydell
  // License: MIT.
  var Identifier, JSXIdentifier, JSXPunctuator, JSXString, JSXText, KeywordsWithExpressionAfter, KeywordsWithNoLineTerminatorAfter, LineTerminatorSequence, MultiLineComment, Newline, NumericLiteral, Punctuator, RegularExpressionLiteral, SingleLineComment, StringLiteral, Template, TokensNotPrecedingObjectLiteral, TokensPrecedingExpression, WhiteSpace;
  RegularExpressionLiteral = new RegExp("\\/(?![\\*\\/])(?:\\[(?:(?![\\\\\\]])(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])|\\\\(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]))*\\]|(?![\\/\\\\])(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])|\\\\(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]))*(\\/(?:[\\$0-9A-Z_a-z\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u07FD\\u0800-\\u082D\\u0840-\\u085B\\u0860-\\u086A\\u0870-\\u0887\\u0889-\\u088F\\u0897-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u09FC\\u09FE\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9-\\u0AFF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B55-\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3C-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C5C\\u0C5D\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDC-\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1-\\u0CF3\\u0D00-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D81-\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECE\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u1715\\u171F-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u180F-\\u1819\\u1820-\\u1878\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1ABF-\\u1ADD\\u1AE0-\\u1AEB\\u1B00-\\u1B4C\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C8A\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CD0-\\u1CD2\\u1CD4-\\u1CFA\\u1D00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7DC\\uA7F1-\\uA827\\uA82C\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF65-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDD70-\\uDD7A\\uDD7C-\\uDD8A\\uDD8C-\\uDD92\\uDD94\\uDD95\\uDD97-\\uDDA1\\uDDA3-\\uDDB1\\uDDB3-\\uDDB9\\uDDBB\\uDDBC\\uDDC0-\\uDDF3\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67\\uDF80-\\uDF85\\uDF87-\\uDFB0\\uDFB2-\\uDFBA]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD40-\\uDD59\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD27\\uDD30-\\uDD39\\uDD40-\\uDD65\\uDD69-\\uDD6D\\uDD6F-\\uDD85\\uDE80-\\uDEA9\\uDEAB\\uDEAC\\uDEB0\\uDEB1\\uDEC2-\\uDEC7\\uDEFA-\\uDF1C\\uDF27\\uDF30-\\uDF50\\uDF70-\\uDF85\\uDFB0-\\uDFC4\\uDFE0-\\uDFF6]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC75\\uDC7F-\\uDCBA\\uDCC2\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD44-\\uDD47\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDC9-\\uDDCC\\uDDCE-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E-\\uDE41\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3B-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74\\uDF80-\\uDF89\\uDF8B\\uDF8E\\uDF90-\\uDFB5\\uDFB7-\\uDFC0\\uDFC2\\uDFC5\\uDFC7-\\uDFCA\\uDFCC-\\uDFD3\\uDFE1\\uDFE2]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC5E-\\uDC61\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB8\\uDEC0-\\uDEC9\\uDED0-\\uDEE3\\uDF00-\\uDF1A\\uDF1D-\\uDF2B\\uDF30-\\uDF39\\uDF40-\\uDF46]|\\uD806[\\uDC00-\\uDC3A\\uDCA0-\\uDCE9\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD35\\uDD37\\uDD38\\uDD3B-\\uDD43\\uDD50-\\uDD59\\uDDA0-\\uDDA7\\uDDAA-\\uDDD7\\uDDDA-\\uDDE1\\uDDE3\\uDDE4\\uDE00-\\uDE3E\\uDE47\\uDE50-\\uDE99\\uDE9D\\uDEB0-\\uDEF8\\uDF60-\\uDF67\\uDFC0-\\uDFE0\\uDFF0-\\uDFF9]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD47\\uDD50-\\uDD59\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD8E\\uDD90\\uDD91\\uDD93-\\uDD98\\uDDA0-\\uDDA9\\uDDB0-\\uDDDB\\uDDE0-\\uDDE9\\uDEE0-\\uDEF6\\uDF00-\\uDF10\\uDF12-\\uDF3A\\uDF3E-\\uDF42\\uDF50-\\uDF5A\\uDFB0]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|\\uD80B[\\uDF90-\\uDFF0]|[\\uD80C\\uD80E\\uD80F\\uD81C-\\uD822\\uD840-\\uD868\\uD86A-\\uD86D\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883\\uD885-\\uD88C][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2F\\uDC40-\\uDC55\\uDC60-\\uDFFF]|\\uD810[\\uDC00-\\uDFFA]|\\uD811[\\uDC00-\\uDE46]|\\uD818[\\uDD00-\\uDD39]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDE70-\\uDEBE\\uDEC0-\\uDEC9\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDD40-\\uDD6C\\uDD70-\\uDD79\\uDE40-\\uDE7F\\uDEA0-\\uDEB8\\uDEBB-\\uDED3\\uDF00-\\uDF4A\\uDF4F-\\uDF87\\uDF8F-\\uDF9F\\uDFE0\\uDFE1\\uDFE3\\uDFE4\\uDFF0-\\uDFF6]|\\uD823[\\uDC00-\\uDCD5\\uDCFF-\\uDD1E\\uDD80-\\uDDF2]|\\uD82B[\\uDFF0-\\uDFF3\\uDFF5-\\uDFFB\\uDFFD\\uDFFE]|\\uD82C[\\uDC00-\\uDD22\\uDD32\\uDD50-\\uDD52\\uDD55\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD833[\\uDCF0-\\uDCF9\\uDF00-\\uDF2D\\uDF30-\\uDF46]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD837[\\uDF00-\\uDF1E\\uDF25-\\uDF2A]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDC30-\\uDC6D\\uDC8F\\uDD00-\\uDD2C\\uDD30-\\uDD3D\\uDD40-\\uDD49\\uDD4E\\uDE90-\\uDEAE\\uDEC0-\\uDEF9]|\\uD839[\\uDCD0-\\uDCF9\\uDDD0-\\uDDFA\\uDEC0-\\uDEDE\\uDEE0-\\uDEF5\\uDEFE\\uDEFF\\uDFE0-\\uDFE6\\uDFE8-\\uDFEB\\uDFED\\uDFEE\\uDFF0-\\uDFFE]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4B\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD83E[\\uDFF0-\\uDFF9]|\\uD869[\\uDC00-\\uDEDF\\uDF00-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEAD\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0\\uDFF0-\\uDFFF]|\\uD87B[\\uDC00-\\uDE5D]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A\\uDF50-\\uDFFF]|\\uD88D[\\uDC00-\\uDC79]|\\uDB40[\\uDD00-\\uDDEF])*|\\\\)?", "y");
  Punctuator = new RegExp("--|\\+\\+|=>|\\.{3}|\\??\\.(?!\\d)|(?:&&|\\|\\||\\?\\?|[+\\-%&|^]|\\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\\/(?![\\/*]))=?|[?~,:;[\\](){}]", "y");
  Identifier = new RegExp("(#?)(?=(?:[\\$A-Z\\\\_a-z\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u0870-\\u0887\\u0889-\\u088F\\u08A0-\\u08C9\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C5C\\u0C5D\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDC-\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D04-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u1711\\u171F-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1878\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4C\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C8A\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7DC\\uA7F1-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDD70-\\uDD7A\\uDD7C-\\uDD8A\\uDD8C-\\uDD92\\uDD94\\uDD95\\uDD97-\\uDDA1\\uDDA3-\\uDDB1\\uDDB3-\\uDDB9\\uDDBB\\uDDBC\\uDDC0-\\uDDF3\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67\\uDF80-\\uDF85\\uDF87-\\uDFB0\\uDFB2-\\uDFBA]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD40-\\uDD59\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD23\\uDD4A-\\uDD65\\uDD6F-\\uDD85\\uDE80-\\uDEA9\\uDEB0\\uDEB1\\uDEC2-\\uDEC7\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF45\\uDF70-\\uDF81\\uDFB0-\\uDFC4\\uDFE0-\\uDFF6]|\\uD804[\\uDC03-\\uDC37\\uDC71\\uDC72\\uDC75\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD44\\uDD47\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE3F\\uDE40\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61\\uDF80-\\uDF89\\uDF8B\\uDF8E\\uDF90-\\uDFB5\\uDFB7\\uDFD1\\uDFD3]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC5F-\\uDC61\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDEB8\\uDF00-\\uDF1A\\uDF40-\\uDF46]|\\uD806[\\uDC00-\\uDC2B\\uDCA0-\\uDCDF\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD2F\\uDD3F\\uDD41\\uDDA0-\\uDDA7\\uDDAA-\\uDDD0\\uDDE1\\uDDE3\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE89\\uDE9D\\uDEB0-\\uDEF8\\uDFC0-\\uDFE0]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD89\\uDD98\\uDDB0-\\uDDDB\\uDEE0-\\uDEF2\\uDF02\\uDF04-\\uDF10\\uDF12-\\uDF33\\uDFB0]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|\\uD80B[\\uDF90-\\uDFF0]|[\\uD80C\\uD80E\\uD80F\\uD81C-\\uD822\\uD840-\\uD868\\uD86A-\\uD86D\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883\\uD885-\\uD88C][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2F\\uDC41-\\uDC46\\uDC60-\\uDFFF]|\\uD810[\\uDC00-\\uDFFA]|\\uD811[\\uDC00-\\uDE46]|\\uD818[\\uDD00-\\uDD1D]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE70-\\uDEBE\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDD40-\\uDD6C\\uDE40-\\uDE7F\\uDEA0-\\uDEB8\\uDEBB-\\uDED3\\uDF00-\\uDF4A\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1\\uDFE3\\uDFF2-\\uDFF6]|\\uD823[\\uDC00-\\uDCD5\\uDCFF-\\uDD1E\\uDD80-\\uDDF2]|\\uD82B[\\uDFF0-\\uDFF3\\uDFF5-\\uDFFB\\uDFFD\\uDFFE]|\\uD82C[\\uDC00-\\uDD22\\uDD32\\uDD50-\\uDD52\\uDD55\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD837[\\uDF00-\\uDF1E\\uDF25-\\uDF2A]|\\uD838[\\uDC30-\\uDC6D\\uDD00-\\uDD2C\\uDD37-\\uDD3D\\uDD4E\\uDE90-\\uDEAD\\uDEC0-\\uDEEB]|\\uD839[\\uDCD0-\\uDCEB\\uDDD0-\\uDDED\\uDDF0\\uDEC0-\\uDEDE\\uDEE0-\\uDEE2\\uDEE4\\uDEE5\\uDEE7-\\uDEED\\uDEF0-\\uDEF4\\uDEFE\\uDEFF\\uDFE0-\\uDFE6\\uDFE8-\\uDFEB\\uDFED\\uDFEE\\uDFF0-\\uDFFE]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43\\uDD4B]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDEDF\\uDF00-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEAD\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0\\uDFF0-\\uDFFF]|\\uD87B[\\uDC00-\\uDE5D]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A\\uDF50-\\uDFFF]|\\uD88D[\\uDC00-\\uDC79]))(?:(?:[\\$0-9A-Z_a-z\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u07FD\\u0800-\\u082D\\u0840-\\u085B\\u0860-\\u086A\\u0870-\\u0887\\u0889-\\u088F\\u0897-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u09FC\\u09FE\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9-\\u0AFF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B55-\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3C-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C5C\\u0C5D\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDC-\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1-\\u0CF3\\u0D00-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D81-\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECE\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u1715\\u171F-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u180F-\\u1819\\u1820-\\u1878\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1ABF-\\u1ADD\\u1AE0-\\u1AEB\\u1B00-\\u1B4C\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C8A\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CD0-\\u1CD2\\u1CD4-\\u1CFA\\u1D00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7DC\\uA7F1-\\uA827\\uA82C\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF65-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDD70-\\uDD7A\\uDD7C-\\uDD8A\\uDD8C-\\uDD92\\uDD94\\uDD95\\uDD97-\\uDDA1\\uDDA3-\\uDDB1\\uDDB3-\\uDDB9\\uDDBB\\uDDBC\\uDDC0-\\uDDF3\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67\\uDF80-\\uDF85\\uDF87-\\uDFB0\\uDFB2-\\uDFBA]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD40-\\uDD59\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD27\\uDD30-\\uDD39\\uDD40-\\uDD65\\uDD69-\\uDD6D\\uDD6F-\\uDD85\\uDE80-\\uDEA9\\uDEAB\\uDEAC\\uDEB0\\uDEB1\\uDEC2-\\uDEC7\\uDEFA-\\uDF1C\\uDF27\\uDF30-\\uDF50\\uDF70-\\uDF85\\uDFB0-\\uDFC4\\uDFE0-\\uDFF6]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC75\\uDC7F-\\uDCBA\\uDCC2\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD44-\\uDD47\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDC9-\\uDDCC\\uDDCE-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E-\\uDE41\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3B-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74\\uDF80-\\uDF89\\uDF8B\\uDF8E\\uDF90-\\uDFB5\\uDFB7-\\uDFC0\\uDFC2\\uDFC5\\uDFC7-\\uDFCA\\uDFCC-\\uDFD3\\uDFE1\\uDFE2]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC5E-\\uDC61\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB8\\uDEC0-\\uDEC9\\uDED0-\\uDEE3\\uDF00-\\uDF1A\\uDF1D-\\uDF2B\\uDF30-\\uDF39\\uDF40-\\uDF46]|\\uD806[\\uDC00-\\uDC3A\\uDCA0-\\uDCE9\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD35\\uDD37\\uDD38\\uDD3B-\\uDD43\\uDD50-\\uDD59\\uDDA0-\\uDDA7\\uDDAA-\\uDDD7\\uDDDA-\\uDDE1\\uDDE3\\uDDE4\\uDE00-\\uDE3E\\uDE47\\uDE50-\\uDE99\\uDE9D\\uDEB0-\\uDEF8\\uDF60-\\uDF67\\uDFC0-\\uDFE0\\uDFF0-\\uDFF9]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD47\\uDD50-\\uDD59\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD8E\\uDD90\\uDD91\\uDD93-\\uDD98\\uDDA0-\\uDDA9\\uDDB0-\\uDDDB\\uDDE0-\\uDDE9\\uDEE0-\\uDEF6\\uDF00-\\uDF10\\uDF12-\\uDF3A\\uDF3E-\\uDF42\\uDF50-\\uDF5A\\uDFB0]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|\\uD80B[\\uDF90-\\uDFF0]|[\\uD80C\\uD80E\\uD80F\\uD81C-\\uD822\\uD840-\\uD868\\uD86A-\\uD86D\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883\\uD885-\\uD88C][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2F\\uDC40-\\uDC55\\uDC60-\\uDFFF]|\\uD810[\\uDC00-\\uDFFA]|\\uD811[\\uDC00-\\uDE46]|\\uD818[\\uDD00-\\uDD39]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDE70-\\uDEBE\\uDEC0-\\uDEC9\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDD40-\\uDD6C\\uDD70-\\uDD79\\uDE40-\\uDE7F\\uDEA0-\\uDEB8\\uDEBB-\\uDED3\\uDF00-\\uDF4A\\uDF4F-\\uDF87\\uDF8F-\\uDF9F\\uDFE0\\uDFE1\\uDFE3\\uDFE4\\uDFF0-\\uDFF6]|\\uD823[\\uDC00-\\uDCD5\\uDCFF-\\uDD1E\\uDD80-\\uDDF2]|\\uD82B[\\uDFF0-\\uDFF3\\uDFF5-\\uDFFB\\uDFFD\\uDFFE]|\\uD82C[\\uDC00-\\uDD22\\uDD32\\uDD50-\\uDD52\\uDD55\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD833[\\uDCF0-\\uDCF9\\uDF00-\\uDF2D\\uDF30-\\uDF46]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD837[\\uDF00-\\uDF1E\\uDF25-\\uDF2A]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDC30-\\uDC6D\\uDC8F\\uDD00-\\uDD2C\\uDD30-\\uDD3D\\uDD40-\\uDD49\\uDD4E\\uDE90-\\uDEAE\\uDEC0-\\uDEF9]|\\uD839[\\uDCD0-\\uDCF9\\uDDD0-\\uDDFA\\uDEC0-\\uDEDE\\uDEE0-\\uDEF5\\uDEFE\\uDEFF\\uDFE0-\\uDFE6\\uDFE8-\\uDFEB\\uDFED\\uDFEE\\uDFF0-\\uDFFE]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4B\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD83E[\\uDFF0-\\uDFF9]|\\uD869[\\uDC00-\\uDEDF\\uDF00-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEAD\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0\\uDFF0-\\uDFFF]|\\uD87B[\\uDC00-\\uDE5D]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A\\uDF50-\\uDFFF]|\\uD88D[\\uDC00-\\uDC79]|\\uDB40[\\uDD00-\\uDDEF])|\\\\u[0-9A-Fa-f]{4}|\\\\u\\{[0-9A-Fa-f]+\\})+", "y");
  StringLiteral = new RegExp("(['\"])(?:(?!\\1)[^\\\\\\n\\r]|\\\\(?:\\r\\n|[^]))*(\\1)?", "y");
  NumericLiteral = new RegExp("(?:0[xX][\\da-fA-F](?:_?[\\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\\d)*n|(?:(?:0(?!\\d)|0\\d*[89]\\d*|[1-9](?:_?\\d)*)(?:\\.(?:\\d(?:_?\\d)*)?)?|\\.\\d(?:_?\\d)*)(?:[eE][+-]?\\d(?:_?\\d)*)?|0[0-7]+", "y");
  Template = new RegExp("[`}](?:[^`\\\\$]|\\\\[^]|\\$(?!\\{))*(`|\\$\\{)?", "y");
  WhiteSpace = new RegExp("[\\t\\x0B\\f \\xA0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000\\uFEFF]+", "y");
  LineTerminatorSequence = new RegExp("\\r?\\n|[\\r\\u2028\\u2029]", "y");
  MultiLineComment = new RegExp("\\/\\*(?:[^*]|\\*(?!\\/))*(\\*\\/)?", "y");
  SingleLineComment = new RegExp("\\/\\/.*", "y");
  JSXPunctuator = new RegExp("[<>.:={}]|\\/(?![\\/*])", "y");
  JSXIdentifier = new RegExp("(?:[\\$A-Z_a-z\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u0870-\\u0887\\u0889-\\u088F\\u08A0-\\u08C9\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C5C\\u0C5D\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDC-\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D04-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u1711\\u171F-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1878\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4C\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C8A\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7DC\\uA7F1-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDD70-\\uDD7A\\uDD7C-\\uDD8A\\uDD8C-\\uDD92\\uDD94\\uDD95\\uDD97-\\uDDA1\\uDDA3-\\uDDB1\\uDDB3-\\uDDB9\\uDDBB\\uDDBC\\uDDC0-\\uDDF3\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67\\uDF80-\\uDF85\\uDF87-\\uDFB0\\uDFB2-\\uDFBA]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD40-\\uDD59\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD23\\uDD4A-\\uDD65\\uDD6F-\\uDD85\\uDE80-\\uDEA9\\uDEB0\\uDEB1\\uDEC2-\\uDEC7\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF45\\uDF70-\\uDF81\\uDFB0-\\uDFC4\\uDFE0-\\uDFF6]|\\uD804[\\uDC03-\\uDC37\\uDC71\\uDC72\\uDC75\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD44\\uDD47\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE3F\\uDE40\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61\\uDF80-\\uDF89\\uDF8B\\uDF8E\\uDF90-\\uDFB5\\uDFB7\\uDFD1\\uDFD3]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC5F-\\uDC61\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDEB8\\uDF00-\\uDF1A\\uDF40-\\uDF46]|\\uD806[\\uDC00-\\uDC2B\\uDCA0-\\uDCDF\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD2F\\uDD3F\\uDD41\\uDDA0-\\uDDA7\\uDDAA-\\uDDD0\\uDDE1\\uDDE3\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE89\\uDE9D\\uDEB0-\\uDEF8\\uDFC0-\\uDFE0]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD89\\uDD98\\uDDB0-\\uDDDB\\uDEE0-\\uDEF2\\uDF02\\uDF04-\\uDF10\\uDF12-\\uDF33\\uDFB0]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|\\uD80B[\\uDF90-\\uDFF0]|[\\uD80C\\uD80E\\uD80F\\uD81C-\\uD822\\uD840-\\uD868\\uD86A-\\uD86D\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883\\uD885-\\uD88C][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2F\\uDC41-\\uDC46\\uDC60-\\uDFFF]|\\uD810[\\uDC00-\\uDFFA]|\\uD811[\\uDC00-\\uDE46]|\\uD818[\\uDD00-\\uDD1D]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE70-\\uDEBE\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDD40-\\uDD6C\\uDE40-\\uDE7F\\uDEA0-\\uDEB8\\uDEBB-\\uDED3\\uDF00-\\uDF4A\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1\\uDFE3\\uDFF2-\\uDFF6]|\\uD823[\\uDC00-\\uDCD5\\uDCFF-\\uDD1E\\uDD80-\\uDDF2]|\\uD82B[\\uDFF0-\\uDFF3\\uDFF5-\\uDFFB\\uDFFD\\uDFFE]|\\uD82C[\\uDC00-\\uDD22\\uDD32\\uDD50-\\uDD52\\uDD55\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD837[\\uDF00-\\uDF1E\\uDF25-\\uDF2A]|\\uD838[\\uDC30-\\uDC6D\\uDD00-\\uDD2C\\uDD37-\\uDD3D\\uDD4E\\uDE90-\\uDEAD\\uDEC0-\\uDEEB]|\\uD839[\\uDCD0-\\uDCEB\\uDDD0-\\uDDED\\uDDF0\\uDEC0-\\uDEDE\\uDEE0-\\uDEE2\\uDEE4\\uDEE5\\uDEE7-\\uDEED\\uDEF0-\\uDEF4\\uDEFE\\uDEFF\\uDFE0-\\uDFE6\\uDFE8-\\uDFEB\\uDFED\\uDFEE\\uDFF0-\\uDFFE]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43\\uDD4B]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDEDF\\uDF00-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEAD\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0\\uDFF0-\\uDFFF]|\\uD87B[\\uDC00-\\uDE5D]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A\\uDF50-\\uDFFF]|\\uD88D[\\uDC00-\\uDC79])(?:[\\$\\x2D0-9A-Z_a-z\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u07FD\\u0800-\\u082D\\u0840-\\u085B\\u0860-\\u086A\\u0870-\\u0887\\u0889-\\u088F\\u0897-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u09FC\\u09FE\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9-\\u0AFF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B55-\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3C-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C5C\\u0C5D\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDC-\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1-\\u0CF3\\u0D00-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D81-\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECE\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u1715\\u171F-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u180F-\\u1819\\u1820-\\u1878\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1ABF-\\u1ADD\\u1AE0-\\u1AEB\\u1B00-\\u1B4C\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C8A\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CD0-\\u1CD2\\u1CD4-\\u1CFA\\u1D00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7DC\\uA7F1-\\uA827\\uA82C\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF65-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDD70-\\uDD7A\\uDD7C-\\uDD8A\\uDD8C-\\uDD92\\uDD94\\uDD95\\uDD97-\\uDDA1\\uDDA3-\\uDDB1\\uDDB3-\\uDDB9\\uDDBB\\uDDBC\\uDDC0-\\uDDF3\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67\\uDF80-\\uDF85\\uDF87-\\uDFB0\\uDFB2-\\uDFBA]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD40-\\uDD59\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD27\\uDD30-\\uDD39\\uDD40-\\uDD65\\uDD69-\\uDD6D\\uDD6F-\\uDD85\\uDE80-\\uDEA9\\uDEAB\\uDEAC\\uDEB0\\uDEB1\\uDEC2-\\uDEC7\\uDEFA-\\uDF1C\\uDF27\\uDF30-\\uDF50\\uDF70-\\uDF85\\uDFB0-\\uDFC4\\uDFE0-\\uDFF6]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC75\\uDC7F-\\uDCBA\\uDCC2\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD44-\\uDD47\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDC9-\\uDDCC\\uDDCE-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E-\\uDE41\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3B-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74\\uDF80-\\uDF89\\uDF8B\\uDF8E\\uDF90-\\uDFB5\\uDFB7-\\uDFC0\\uDFC2\\uDFC5\\uDFC7-\\uDFCA\\uDFCC-\\uDFD3\\uDFE1\\uDFE2]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC5E-\\uDC61\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB8\\uDEC0-\\uDEC9\\uDED0-\\uDEE3\\uDF00-\\uDF1A\\uDF1D-\\uDF2B\\uDF30-\\uDF39\\uDF40-\\uDF46]|\\uD806[\\uDC00-\\uDC3A\\uDCA0-\\uDCE9\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD35\\uDD37\\uDD38\\uDD3B-\\uDD43\\uDD50-\\uDD59\\uDDA0-\\uDDA7\\uDDAA-\\uDDD7\\uDDDA-\\uDDE1\\uDDE3\\uDDE4\\uDE00-\\uDE3E\\uDE47\\uDE50-\\uDE99\\uDE9D\\uDEB0-\\uDEF8\\uDF60-\\uDF67\\uDFC0-\\uDFE0\\uDFF0-\\uDFF9]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD47\\uDD50-\\uDD59\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD8E\\uDD90\\uDD91\\uDD93-\\uDD98\\uDDA0-\\uDDA9\\uDDB0-\\uDDDB\\uDDE0-\\uDDE9\\uDEE0-\\uDEF6\\uDF00-\\uDF10\\uDF12-\\uDF3A\\uDF3E-\\uDF42\\uDF50-\\uDF5A\\uDFB0]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|\\uD80B[\\uDF90-\\uDFF0]|[\\uD80C\\uD80E\\uD80F\\uD81C-\\uD822\\uD840-\\uD868\\uD86A-\\uD86D\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883\\uD885-\\uD88C][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2F\\uDC40-\\uDC55\\uDC60-\\uDFFF]|\\uD810[\\uDC00-\\uDFFA]|\\uD811[\\uDC00-\\uDE46]|\\uD818[\\uDD00-\\uDD39]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDE70-\\uDEBE\\uDEC0-\\uDEC9\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDD40-\\uDD6C\\uDD70-\\uDD79\\uDE40-\\uDE7F\\uDEA0-\\uDEB8\\uDEBB-\\uDED3\\uDF00-\\uDF4A\\uDF4F-\\uDF87\\uDF8F-\\uDF9F\\uDFE0\\uDFE1\\uDFE3\\uDFE4\\uDFF0-\\uDFF6]|\\uD823[\\uDC00-\\uDCD5\\uDCFF-\\uDD1E\\uDD80-\\uDDF2]|\\uD82B[\\uDFF0-\\uDFF3\\uDFF5-\\uDFFB\\uDFFD\\uDFFE]|\\uD82C[\\uDC00-\\uDD22\\uDD32\\uDD50-\\uDD52\\uDD55\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD833[\\uDCF0-\\uDCF9\\uDF00-\\uDF2D\\uDF30-\\uDF46]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD837[\\uDF00-\\uDF1E\\uDF25-\\uDF2A]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDC30-\\uDC6D\\uDC8F\\uDD00-\\uDD2C\\uDD30-\\uDD3D\\uDD40-\\uDD49\\uDD4E\\uDE90-\\uDEAE\\uDEC0-\\uDEF9]|\\uD839[\\uDCD0-\\uDCF9\\uDDD0-\\uDDFA\\uDEC0-\\uDEDE\\uDEE0-\\uDEF5\\uDEFE\\uDEFF\\uDFE0-\\uDFE6\\uDFE8-\\uDFEB\\uDFED\\uDFEE\\uDFF0-\\uDFFE]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4B\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD83E[\\uDFF0-\\uDFF9]|\\uD869[\\uDC00-\\uDEDF\\uDF00-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEAD\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0\\uDFF0-\\uDFFF]|\\uD87B[\\uDC00-\\uDE5D]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A\\uDF50-\\uDFFF]|\\uD88D[\\uDC00-\\uDC79]|\\uDB40[\\uDD00-\\uDDEF])*", "y");
  JSXString = new RegExp("(['\"])(?:(?!\\1)[^])*(\\1)?", "y");
  JSXText = new RegExp("[^<>{}]+", "y");
  TokensPrecedingExpression = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/;
  TokensNotPrecedingObjectLiteral = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/;
  KeywordsWithExpressionAfter = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/;
  KeywordsWithNoLineTerminatorAfter = /^(?:return|throw|yield)$/;
  Newline = RegExp(LineTerminatorSequence.source);
  jsTokens_1$2 = function jsTokens_1(input) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$jsx = _ref.jsx,
      jsx = _ref$jsx === void 0 ? false : _ref$jsx;
    return /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      var braces, firstCodePoint, isExpression, lastIndex, lastSignificantToken, length, match, mode, nextLastIndex, nextLastSignificantToken, parenNesting, postfixIncDec, punctuator, stack, _t, _t2, _t3, _t4, _t5;
      return _regeneratorRuntime.wrap(function (_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            length = input.length;
            lastIndex = 0;
            lastSignificantToken = "";
            stack = [{
              tag: "JS"
            }];
            braces = [];
            parenNesting = 0;
            postfixIncDec = false;
          case 1:
            if (!(lastIndex < length)) {
              _context.next = 65;
              break;
            }
            mode = stack[stack.length - 1];
            _t = mode.tag;
            _context.next = _t === "JS" ? 2 : _t === "JSNonExpressionParen" ? 2 : _t === "InterpolationInTemplate" ? 2 : _t === "InterpolationInJSX" ? 2 : _t === "JSXTag" ? 36 : _t === "JSXTagEnd" ? 36 : _t === "JSXChildren" ? 48 : 55;
            break;
          case 2:
            if (!(input[lastIndex] === "/" && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken)))) {
              _context.next = 4;
              break;
            }
            RegularExpressionLiteral.lastIndex = lastIndex;
            if (!(match = RegularExpressionLiteral.exec(input))) {
              _context.next = 4;
              break;
            }
            lastIndex = RegularExpressionLiteral.lastIndex;
            lastSignificantToken = match[0];
            postfixIncDec = true;
            _context.next = 3;
            return {
              type: "RegularExpressionLiteral",
              value: match[0],
              closed: match[1] !== void 0 && match[1] !== "\\"
            };
          case 3:
            return _context.abrupt("continue", 1);
          case 4:
            Punctuator.lastIndex = lastIndex;
            if (!(match = Punctuator.exec(input))) {
              _context.next = 25;
              break;
            }
            punctuator = match[0];
            nextLastIndex = Punctuator.lastIndex;
            nextLastSignificantToken = punctuator;
            _t2 = punctuator;
            _context.next = _t2 === "(" ? 5 : _t2 === ")" ? 6 : _t2 === "{" ? 7 : _t2 === "}" ? 8 : _t2 === "]" ? 17 : _t2 === "++" ? 18 : _t2 === "--" ? 18 : _t2 === "<" ? 19 : 22;
            break;
          case 5:
            if (lastSignificantToken === "?NonExpressionParenKeyword") {
              stack.push({
                tag: "JSNonExpressionParen",
                nesting: parenNesting
              });
            }
            parenNesting++;
            postfixIncDec = false;
            return _context.abrupt("continue", 23);
          case 6:
            parenNesting--;
            postfixIncDec = true;
            if (mode.tag === "JSNonExpressionParen" && parenNesting === mode.nesting) {
              stack.pop();
              nextLastSignificantToken = "?NonExpressionParenEnd";
              postfixIncDec = false;
            }
            return _context.abrupt("continue", 23);
          case 7:
            Punctuator.lastIndex = 0;
            isExpression = !TokensNotPrecedingObjectLiteral.test(lastSignificantToken) && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken));
            braces.push(isExpression);
            postfixIncDec = false;
            return _context.abrupt("continue", 23);
          case 8:
            _t3 = mode.tag;
            _context.next = _t3 === "InterpolationInTemplate" ? 9 : _t3 === "InterpolationInJSX" ? 14 : 16;
            break;
          case 9:
            if (!(braces.length === mode.nesting)) {
              _context.next = 13;
              break;
            }
            Template.lastIndex = lastIndex;
            match = Template.exec(input);
            lastIndex = Template.lastIndex;
            lastSignificantToken = match[0];
            if (!(match[1] === "${")) {
              _context.next = 11;
              break;
            }
            lastSignificantToken = "?InterpolationInTemplate";
            postfixIncDec = false;
            _context.next = 10;
            return {
              type: "TemplateMiddle",
              value: match[0]
            };
          case 10:
            _context.next = 12;
            break;
          case 11:
            stack.pop();
            postfixIncDec = true;
            _context.next = 12;
            return {
              type: "TemplateTail",
              value: match[0],
              closed: match[1] === "`"
            };
          case 12:
            return _context.abrupt("continue", 1);
          case 13:
            return _context.abrupt("continue", 16);
          case 14:
            if (!(braces.length === mode.nesting)) {
              _context.next = 16;
              break;
            }
            stack.pop();
            lastIndex += 1;
            lastSignificantToken = "}";
            _context.next = 15;
            return {
              type: "JSXPunctuator",
              value: "}"
            };
          case 15:
            return _context.abrupt("continue", 1);
          case 16:
            postfixIncDec = braces.pop();
            nextLastSignificantToken = postfixIncDec ? "?ExpressionBraceEnd" : "}";
            return _context.abrupt("continue", 23);
          case 17:
            postfixIncDec = true;
            return _context.abrupt("continue", 23);
          case 18:
            nextLastSignificantToken = postfixIncDec ? "?PostfixIncDec" : "?UnaryIncDec";
            return _context.abrupt("continue", 23);
          case 19:
            if (!(jsx && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken)))) {
              _context.next = 21;
              break;
            }
            stack.push({
              tag: "JSXTag"
            });
            lastIndex += 1;
            lastSignificantToken = "<";
            _context.next = 20;
            return {
              type: "JSXPunctuator",
              value: punctuator
            };
          case 20:
            return _context.abrupt("continue", 1);
          case 21:
            postfixIncDec = false;
            return _context.abrupt("continue", 23);
          case 22:
            postfixIncDec = false;
          case 23:
            lastIndex = nextLastIndex;
            lastSignificantToken = nextLastSignificantToken;
            _context.next = 24;
            return {
              type: "Punctuator",
              value: punctuator
            };
          case 24:
            return _context.abrupt("continue", 1);
          case 25:
            Identifier.lastIndex = lastIndex;
            if (!(match = Identifier.exec(input))) {
              _context.next = 27;
              break;
            }
            lastIndex = Identifier.lastIndex;
            nextLastSignificantToken = match[0];
            switch (match[0]) {
              case "for":
              case "if":
              case "while":
              case "with":
                if (lastSignificantToken !== "." && lastSignificantToken !== "?.") {
                  nextLastSignificantToken = "?NonExpressionParenKeyword";
                }
            }
            lastSignificantToken = nextLastSignificantToken;
            postfixIncDec = !KeywordsWithExpressionAfter.test(match[0]);
            _context.next = 26;
            return {
              type: match[1] === "#" ? "PrivateIdentifier" : "IdentifierName",
              value: match[0]
            };
          case 26:
            return _context.abrupt("continue", 1);
          case 27:
            StringLiteral.lastIndex = lastIndex;
            if (!(match = StringLiteral.exec(input))) {
              _context.next = 29;
              break;
            }
            lastIndex = StringLiteral.lastIndex;
            lastSignificantToken = match[0];
            postfixIncDec = true;
            _context.next = 28;
            return {
              type: "StringLiteral",
              value: match[0],
              closed: match[2] !== void 0
            };
          case 28:
            return _context.abrupt("continue", 1);
          case 29:
            NumericLiteral.lastIndex = lastIndex;
            if (!(match = NumericLiteral.exec(input))) {
              _context.next = 31;
              break;
            }
            lastIndex = NumericLiteral.lastIndex;
            lastSignificantToken = match[0];
            postfixIncDec = true;
            _context.next = 30;
            return {
              type: "NumericLiteral",
              value: match[0]
            };
          case 30:
            return _context.abrupt("continue", 1);
          case 31:
            Template.lastIndex = lastIndex;
            if (!(match = Template.exec(input))) {
              _context.next = 35;
              break;
            }
            lastIndex = Template.lastIndex;
            lastSignificantToken = match[0];
            if (!(match[1] === "${")) {
              _context.next = 33;
              break;
            }
            lastSignificantToken = "?InterpolationInTemplate";
            stack.push({
              tag: "InterpolationInTemplate",
              nesting: braces.length
            });
            postfixIncDec = false;
            _context.next = 32;
            return {
              type: "TemplateHead",
              value: match[0]
            };
          case 32:
            _context.next = 34;
            break;
          case 33:
            postfixIncDec = true;
            _context.next = 34;
            return {
              type: "NoSubstitutionTemplate",
              value: match[0],
              closed: match[1] === "`"
            };
          case 34:
            return _context.abrupt("continue", 1);
          case 35:
            return _context.abrupt("continue", 55);
          case 36:
            JSXPunctuator.lastIndex = lastIndex;
            if (!(match = JSXPunctuator.exec(input))) {
              _context.next = 43;
              break;
            }
            lastIndex = JSXPunctuator.lastIndex;
            nextLastSignificantToken = match[0];
            _t4 = match[0];
            _context.next = _t4 === "<" ? 37 : _t4 === ">" ? 38 : _t4 === "{" ? 39 : _t4 === "/" ? 40 : 41;
            break;
          case 37:
            stack.push({
              tag: "JSXTag"
            });
            return _context.abrupt("continue", 41);
          case 38:
            stack.pop();
            if (lastSignificantToken === "/" || mode.tag === "JSXTagEnd") {
              nextLastSignificantToken = "?JSX";
              postfixIncDec = true;
            } else {
              stack.push({
                tag: "JSXChildren"
              });
            }
            return _context.abrupt("continue", 41);
          case 39:
            stack.push({
              tag: "InterpolationInJSX",
              nesting: braces.length
            });
            nextLastSignificantToken = "?InterpolationInJSX";
            postfixIncDec = false;
            return _context.abrupt("continue", 41);
          case 40:
            if (lastSignificantToken === "<") {
              stack.pop();
              if (stack[stack.length - 1].tag === "JSXChildren") {
                stack.pop();
              }
              stack.push({
                tag: "JSXTagEnd"
              });
            }
          case 41:
            lastSignificantToken = nextLastSignificantToken;
            _context.next = 42;
            return {
              type: "JSXPunctuator",
              value: match[0]
            };
          case 42:
            return _context.abrupt("continue", 1);
          case 43:
            JSXIdentifier.lastIndex = lastIndex;
            if (!(match = JSXIdentifier.exec(input))) {
              _context.next = 45;
              break;
            }
            lastIndex = JSXIdentifier.lastIndex;
            lastSignificantToken = match[0];
            _context.next = 44;
            return {
              type: "JSXIdentifier",
              value: match[0]
            };
          case 44:
            return _context.abrupt("continue", 1);
          case 45:
            JSXString.lastIndex = lastIndex;
            if (!(match = JSXString.exec(input))) {
              _context.next = 47;
              break;
            }
            lastIndex = JSXString.lastIndex;
            lastSignificantToken = match[0];
            _context.next = 46;
            return {
              type: "JSXString",
              value: match[0],
              closed: match[2] !== void 0
            };
          case 46:
            return _context.abrupt("continue", 1);
          case 47:
            return _context.abrupt("continue", 55);
          case 48:
            JSXText.lastIndex = lastIndex;
            if (!(match = JSXText.exec(input))) {
              _context.next = 50;
              break;
            }
            lastIndex = JSXText.lastIndex;
            lastSignificantToken = match[0];
            _context.next = 49;
            return {
              type: "JSXText",
              value: match[0]
            };
          case 49:
            return _context.abrupt("continue", 1);
          case 50:
            _t5 = input[lastIndex];
            _context.next = _t5 === "<" ? 51 : _t5 === "{" ? 53 : 55;
            break;
          case 51:
            stack.push({
              tag: "JSXTag"
            });
            lastIndex++;
            lastSignificantToken = "<";
            _context.next = 52;
            return {
              type: "JSXPunctuator",
              value: "<"
            };
          case 52:
            return _context.abrupt("continue", 1);
          case 53:
            stack.push({
              tag: "InterpolationInJSX",
              nesting: braces.length
            });
            lastIndex++;
            lastSignificantToken = "?InterpolationInJSX";
            postfixIncDec = false;
            _context.next = 54;
            return {
              type: "JSXPunctuator",
              value: "{"
            };
          case 54:
            return _context.abrupt("continue", 1);
          case 55:
            WhiteSpace.lastIndex = lastIndex;
            if (!(match = WhiteSpace.exec(input))) {
              _context.next = 57;
              break;
            }
            lastIndex = WhiteSpace.lastIndex;
            _context.next = 56;
            return {
              type: "WhiteSpace",
              value: match[0]
            };
          case 56:
            return _context.abrupt("continue", 1);
          case 57:
            LineTerminatorSequence.lastIndex = lastIndex;
            if (!(match = LineTerminatorSequence.exec(input))) {
              _context.next = 59;
              break;
            }
            lastIndex = LineTerminatorSequence.lastIndex;
            postfixIncDec = false;
            if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {
              lastSignificantToken = "?NoLineTerminatorHere";
            }
            _context.next = 58;
            return {
              type: "LineTerminatorSequence",
              value: match[0]
            };
          case 58:
            return _context.abrupt("continue", 1);
          case 59:
            MultiLineComment.lastIndex = lastIndex;
            if (!(match = MultiLineComment.exec(input))) {
              _context.next = 61;
              break;
            }
            lastIndex = MultiLineComment.lastIndex;
            if (Newline.test(match[0])) {
              postfixIncDec = false;
              if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {
                lastSignificantToken = "?NoLineTerminatorHere";
              }
            }
            _context.next = 60;
            return {
              type: "MultiLineComment",
              value: match[0],
              closed: match[1] !== void 0
            };
          case 60:
            return _context.abrupt("continue", 1);
          case 61:
            SingleLineComment.lastIndex = lastIndex;
            if (!(match = SingleLineComment.exec(input))) {
              _context.next = 63;
              break;
            }
            lastIndex = SingleLineComment.lastIndex;
            postfixIncDec = false;
            _context.next = 62;
            return {
              type: "SingleLineComment",
              value: match[0]
            };
          case 62:
            return _context.abrupt("continue", 1);
          case 63:
            firstCodePoint = String.fromCodePoint(input.codePointAt(lastIndex));
            lastIndex += firstCodePoint.length;
            lastSignificantToken = firstCodePoint;
            postfixIncDec = false;
            _context.next = 64;
            return {
              type: mode.tag.startsWith("JSX") ? "JSXInvalid" : "Invalid",
              value: firstCodePoint
            };
          case 64:
            _context.next = 1;
            break;
          case 65:
            return _context.abrupt("return", void 0);
          case 66:
          case "end":
            return _context.stop();
        }
      }, _callee);
    })();
  };
  return jsTokens_1$2;
}
requireJsTokens$1();
var SAFE_TIMERS_SYMBOL = Symbol("vitest:SAFE_TIMERS");
function getSafeTimers() {
  var _ref2 = globalThis[SAFE_TIMERS_SYMBOL] || globalThis,
    safeSetTimeout = _ref2.setTimeout,
    safeSetInterval = _ref2.setInterval,
    safeClearInterval = _ref2.clearInterval,
    safeClearTimeout = _ref2.clearTimeout,
    safeSetImmediate = _ref2.setImmediate,
    safeClearImmediate = _ref2.clearImmediate,
    safeQueueMicrotask = _ref2.queueMicrotask;
  var _ref3 = globalThis[SAFE_TIMERS_SYMBOL] || globalThis.process || {
      nextTick: function nextTick(cb) {
        return cb();
      }
    },
    safeNextTick = _ref3.nextTick;
  return {
    nextTick: safeNextTick,
    setTimeout: safeSetTimeout,
    setInterval: safeSetInterval,
    clearInterval: safeClearInterval,
    clearTimeout: safeClearTimeout,
    setImmediate: safeSetImmediate,
    clearImmediate: safeClearImmediate,
    queueMicrotask: safeQueueMicrotask
  };
}

function ownKeys$6(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$6(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$6(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$6(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }

/**
* Diff Match and Patch
* Copyright 2018 The diff-match-patch Authors.
* https://github.com/google/diff-match-patch
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
* @fileoverview Computes the difference between two texts to create a patch.
* Applies the patch onto another text, allowing for errors.
* @author fraser@google.com (Neil Fraser)
*/
/**
* CHANGES by pedrottimark to diff_match_patch_uncompressed.ts file:
*
* 1. Delete anything not needed to use diff_cleanupSemantic method
* 2. Convert from prototype properties to var declarations
* 3. Convert Diff to class from constructor and prototype
* 4. Add type annotations for arguments and return values
* 5. Add exports
*/
/**
* The data structure representing a diff is an array of tuples:
* [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
* which means: delete 'Hello', add 'Goodbye' and keep ' world.'
*/
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;
/**
* Class representing one diff tuple.
* Attempts to look like a two-element array (which is what this used to be).
* @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.
* @param {string} text Text to be deleted, inserted, or retained.
* @constructor
*/
var Diff = /*#__PURE__*/_createClass(function Diff(op, text) {
  _classCallCheck(this, Diff);
  _defineProperty(this, 0, void 0);
  _defineProperty(this, 1, void 0);
  this[0] = op;
  this[1] = text;
});
/**
* Determine the common prefix of two strings.
* @param {string} text1 First string.
* @param {string} text2 Second string.
* @return {number} The number of characters common to the start of each
*     string.
*/
function diff_commonPrefix(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: https://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
}
/**
* Determine the common suffix of two strings.
* @param {string} text1 First string.
* @param {string} text2 Second string.
* @return {number} The number of characters common to the end of each string.
*/
function diff_commonSuffix(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: https://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
}
/**
* Determine if the suffix of one string is the prefix of another.
* @param {string} text1 First string.
* @param {string} text2 Second string.
* @return {number} The number of characters common to the end of the first
*     string and the start of the second string.
* @private
*/
function diff_commonOverlap_(text1, text2) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  // Eliminate the null case.
  if (text1_length === 0 || text2_length === 0) {
    return 0;
  }
  // Truncate the longer string.
  if (text1_length > text2_length) {
    text1 = text1.substring(text1_length - text2_length);
  } else if (text1_length < text2_length) {
    text2 = text2.substring(0, text1_length);
  }
  var text_length = Math.min(text1_length, text2_length);
  // Quick check for the worst case.
  if (text1 === text2) {
    return text_length;
  }
  // Start by looking for a single character match
  // and increase length until no match is found.
  // Performance analysis: https://neil.fraser.name/news/2010/11/04/
  var best = 0;
  var length = 1;
  while (true) {
    var pattern = text1.substring(text_length - length);
    var found = text2.indexOf(pattern);
    if (found === -1) {
      return best;
    }
    length += found;
    if (found === 0 || text1.substring(text_length - length) === text2.substring(0, length)) {
      best = length;
      length++;
    }
  }
}
/**
* Reduce the number of edits by eliminating semantically trivial equalities.
* @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
*/
function diff_cleanupSemantic(diffs) {
  var changes = false;
  var equalities = [];
  var equalitiesLength = 0;
  /** @type {?string} */
  var lastEquality = null;
  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
  var pointer = 0;
  // Number of characters that changed prior to the equality.
  var length_insertions1 = 0;
  var length_deletions1 = 0;
  // Number of characters that changed after the equality.
  var length_insertions2 = 0;
  var length_deletions2 = 0;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] === DIFF_EQUAL) {
      // Equality found.
      equalities[equalitiesLength++] = pointer;
      length_insertions1 = length_insertions2;
      length_deletions1 = length_deletions2;
      length_insertions2 = 0;
      length_deletions2 = 0;
      lastEquality = diffs[pointer][1];
    } else {
      // An insertion or deletion.
      if (diffs[pointer][0] === DIFF_INSERT) {
        length_insertions2 += diffs[pointer][1].length;
      } else {
        length_deletions2 += diffs[pointer][1].length;
      }
      // Eliminate an equality that is smaller or equal to the edits on both
      // sides of it.
      if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2)) {
        // Duplicate record.
        diffs.splice(equalities[equalitiesLength - 1], 0, new Diff(DIFF_DELETE, lastEquality));
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        // Throw away the equality we just deleted.
        equalitiesLength--;
        // Throw away the previous equality (it needs to be reevaluated).
        equalitiesLength--;
        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        length_insertions1 = 0;
        length_deletions1 = 0;
        length_insertions2 = 0;
        length_deletions2 = 0;
        lastEquality = null;
        changes = true;
      }
    }
    pointer++;
  }
  // Normalize the diff.
  if (changes) {
    diff_cleanupMerge(diffs);
  }
  diff_cleanupSemanticLossless(diffs);
  // Find any overlaps between deletions and insertions.
  // e.g: <del>abcxxx</del><ins>xxxdef</ins>
  //   -> <del>abc</del>xxx<ins>def</ins>
  // e.g: <del>xxxabc</del><ins>defxxx</ins>
  //   -> <ins>def</ins>xxx<del>abc</del>
  // Only extract an overlap if it is as big as the edit ahead or behind it.
  pointer = 1;
  while (pointer < diffs.length) {
    if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {
      var deletion = diffs[pointer - 1][1];
      var insertion = diffs[pointer][1];
      var overlap_length1 = diff_commonOverlap_(deletion, insertion);
      var overlap_length2 = diff_commonOverlap_(insertion, deletion);
      if (overlap_length1 >= overlap_length2) {
        if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
          // Overlap found.  Insert an equality and trim the surrounding edits.
          diffs.splice(pointer, 0, new Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1)));
          diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);
          diffs[pointer + 1][1] = insertion.substring(overlap_length1);
          pointer++;
        }
      } else {
        if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
          // Reverse overlap found.
          // Insert an equality and swap and trim the surrounding edits.
          diffs.splice(pointer, 0, new Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2)));
          diffs[pointer - 1][0] = DIFF_INSERT;
          diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);
          diffs[pointer + 1][0] = DIFF_DELETE;
          diffs[pointer + 1][1] = deletion.substring(overlap_length2);
          pointer++;
        }
      }
      pointer++;
    }
    pointer++;
  }
}
// Define some regex patterns for matching boundaries.
var nonAlphaNumericRegex_ = /[^a-z0-9]/i;
var whitespaceRegex_ = /\s/;
var linebreakRegex_ = /[\r\n]/;
var blanklineEndRegex_ = /\n\r?\n$/;
var blanklineStartRegex_ = /^\r?\n\r?\n/;
/**
* Look for single edits surrounded on both sides by equalities
* which can be shifted sideways to align the edit to a word boundary.
* e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
* @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
*/
function diff_cleanupSemanticLossless(diffs) {
  var pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      var equality1 = diffs[pointer - 1][1];
      var edit = diffs[pointer][1];
      var equality2 = diffs[pointer + 1][1];
      // First, shift the edit as far left as possible.
      var commonOffset = diff_commonSuffix(equality1, edit);
      if (commonOffset) {
        var commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }
      // Second, step character by character right, looking for the best fit.
      var bestEquality1 = equality1;
      var bestEdit = edit;
      var bestEquality2 = equality2;
      var bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        var score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
        // The >= encourages trailing rather than leading whitespace on edits.
        if (score >= bestScore) {
          bestScore = score;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }
      if (diffs[pointer - 1][1] !== bestEquality1) {
        // We have an improvement, save it back to the diff.
        if (bestEquality1) {
          diffs[pointer - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer - 1, 1);
          pointer--;
        }
        diffs[pointer][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer + 1, 1);
          pointer--;
        }
      }
    }
    pointer++;
  }
}
/**
* Reorder and merge like edit sections.  Merge equalities.
* Any edit section can move as long as it doesn't cross an equality.
* @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
*/
function diff_cleanupMerge(diffs) {
  // Add a dummy entry at the end.
  diffs.push(new Diff(DIFF_EQUAL, ""));
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = "";
  var text_insert = "";
  var commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete + count_insert > 1) {
          if (count_delete !== 0 && count_insert !== 0) {
            // Factor out any common prefixes.
            commonlength = diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] === DIFF_EQUAL) {
                diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, new Diff(DIFF_EQUAL, text_insert.substring(0, commonlength)));
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            // Factor out any common suffixes.
            commonlength = diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length - commonlength);
              text_delete = text_delete.substring(0, text_delete.length - commonlength);
            }
          }
          // Delete the offending records and add the merged ones.
          pointer -= count_delete + count_insert;
          diffs.splice(pointer, count_delete + count_insert);
          if (text_delete.length) {
            diffs.splice(pointer, 0, new Diff(DIFF_DELETE, text_delete));
            pointer++;
          }
          if (text_insert.length) {
            diffs.splice(pointer, 0, new Diff(DIFF_INSERT, text_insert));
            pointer++;
          }
          pointer++;
        } else if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
          // Merge this equality with the previous one.
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = "";
        text_insert = "";
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === "") {
    diffs.pop();
  }
  // Second pass: look for single edits surrounded on both sides by equalities
  // which can be shifted sideways to eliminate an equality.
  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
  var changes = false;
  pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {
        // Shift the edit over the previous equality.
        diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1]) {
        // Shift the edit over the next equality.
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  // If shifts were made, the diff needs reordering and another shift sweep.
  if (changes) {
    diff_cleanupMerge(diffs);
  }
}
/**
* Given two strings, compute a score representing whether the internal
* boundary falls on logical boundaries.
* Scores range from 6 (best) to 0 (worst).
* Closure, but does not reference any external variables.
* @param {string} one First string.
* @param {string} two Second string.
* @return {number} The score.
* @private
*/
function diff_cleanupSemanticScore_(one, two) {
  if (!one || !two) {
    // Edges are the best.
    return 6;
  }
  // Each port of this function behaves slightly differently due to
  // subtle differences in each language's definition of things like
  // 'whitespace'.  Since this function's purpose is largely cosmetic,
  // the choice has been made to use each language's native features
  // rather than force total conformity.
  var char1 = one.charAt(one.length - 1);
  var char2 = two.charAt(0);
  var nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);
  var nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);
  var whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);
  var whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);
  var lineBreak1 = whitespace1 && char1.match(linebreakRegex_);
  var lineBreak2 = whitespace2 && char2.match(linebreakRegex_);
  var blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);
  var blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);
  if (blankLine1 || blankLine2) {
    // Five points for blank lines.
    return 5;
  } else if (lineBreak1 || lineBreak2) {
    // Four points for line breaks.
    return 4;
  } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
    // Three points for end of sentences.
    return 3;
  } else if (whitespace1 || whitespace2) {
    // Two points for whitespace.
    return 2;
  } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
    // One point for non-alphanumeric.
    return 1;
  }
  return 0;
}

/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var NO_DIFF_MESSAGE = "Compared values have no visual difference.";
var SIMILAR_MESSAGE = "Compared values serialize to the same structure.\n" + "Printing internal object structure without calling `toJSON` instead.";
var build = {};
var hasRequiredBuild;
function requireBuild() {
  if (hasRequiredBuild) return build;
  hasRequiredBuild = 1;
  Object.defineProperty(build, '__esModule', {
    value: true
  });
  build.default = diffSequence;
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   */

  // This diff-sequences package implements the linear space variation in
  // An O(ND) Difference Algorithm and Its Variations by Eugene W. Myers

  // Relationship in notation between Myers paper and this package:
  // A is a
  // N is aLength, aEnd - aStart, and so on
  // x is aIndex, aFirst, aLast, and so on
  // B is b
  // M is bLength, bEnd - bStart, and so on
  // y is bIndex, bFirst, bLast, and so on
  // Δ = N - M is negative of baDeltaLength = bLength - aLength
  // D is d
  // k is kF
  // k + Δ is kF = kR - baDeltaLength
  // V is aIndexesF or aIndexesR (see comment below about Indexes type)
  // index intervals [1, N] and [1, M] are [0, aLength) and [0, bLength)
  // starting point in forward direction (0, 0) is (-1, -1)
  // starting point in reverse direction (N + 1, M + 1) is (aLength, bLength)

  // The “edit graph” for sequences a and b corresponds to items:
  // in a on the horizontal axis
  // in b on the vertical axis
  //
  // Given a-coordinate of a point in a diagonal, you can compute b-coordinate.
  //
  // Forward diagonals kF:
  // zero diagonal intersects top left corner
  // positive diagonals intersect top edge
  // negative diagonals insersect left edge
  //
  // Reverse diagonals kR:
  // zero diagonal intersects bottom right corner
  // positive diagonals intersect right edge
  // negative diagonals intersect bottom edge

  // The graph contains a directed acyclic graph of edges:
  // horizontal: delete an item from a
  // vertical: insert an item from b
  // diagonal: common item in a and b
  //
  // The algorithm solves dual problems in the graph analogy:
  // Find longest common subsequence: path with maximum number of diagonal edges
  // Find shortest edit script: path with minimum number of non-diagonal edges

  // Input callback function compares items at indexes in the sequences.

  // Output callback function receives the number of adjacent items
  // and starting indexes of each common subsequence.
  // Either original functions or wrapped to swap indexes if graph is transposed.
  // Indexes in sequence a of last point of forward or reverse paths in graph.
  // Myers algorithm indexes by diagonal k which for negative is bad deopt in V8.
  // This package indexes by iF and iR which are greater than or equal to zero.
  // and also updates the index arrays in place to cut memory in half.
  // kF = 2 * iF - d
  // kR = d - 2 * iR
  // Division of index intervals in sequences a and b at the middle change.
  // Invariant: intervals do not have common items at the start or end.
  var pkg = 'diff-sequences'; // for error messages
  var NOT_YET_SET = 0; // small int instead of undefined to avoid deopt in V8

  // Return the number of common items that follow in forward direction.
  // The length of what Myers paper calls a “snake” in a forward path.
  var countCommonItemsF = function countCommonItemsF(aIndex, aEnd, bIndex, bEnd, isCommon) {
    var nCommon = 0;
    while (aIndex < aEnd && bIndex < bEnd && isCommon(aIndex, bIndex)) {
      aIndex += 1;
      bIndex += 1;
      nCommon += 1;
    }
    return nCommon;
  };

  // Return the number of common items that precede in reverse direction.
  // The length of what Myers paper calls a “snake” in a reverse path.
  var countCommonItemsR = function countCommonItemsR(aStart, aIndex, bStart, bIndex, isCommon) {
    var nCommon = 0;
    while (aStart <= aIndex && bStart <= bIndex && isCommon(aIndex, bIndex)) {
      aIndex -= 1;
      bIndex -= 1;
      nCommon += 1;
    }
    return nCommon;
  };

  // A simple function to extend forward paths from (d - 1) to d changes
  // when forward and reverse paths cannot yet overlap.
  var extendPathsF = function extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF // return the value because optimization might decrease it
  ) {
    // Unroll the first iteration.
    var iF = 0;
    var kF = -d; // kF = 2 * iF - d
    var aFirst = aIndexesF[iF]; // in first iteration always insert
    var aIndexPrev1 = aFirst; // prev value of [iF - 1] in next iteration
    aIndexesF[iF] += countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);

    // Optimization: skip diagonals in which paths cannot ever overlap.
    var nF = d < iMaxF ? d : iMaxF;

    // The diagonals kF are odd when d is odd and even when d is even.
    for (iF += 1, kF += 2; iF <= nF; iF += 1, kF += 2) {
      // To get first point of path segment, move one change in forward direction
      // from last point of previous path segment in an adjacent diagonal.
      // In last possible iteration when iF === d and kF === d always delete.
      if (iF !== d && aIndexPrev1 < aIndexesF[iF]) {
        aFirst = aIndexesF[iF]; // vertical to insert from b
      } else {
        aFirst = aIndexPrev1 + 1; // horizontal to delete from a

        if (aEnd <= aFirst) {
          // Optimization: delete moved past right of graph.
          return iF - 1;
        }
      }

      // To get last point of path segment, move along diagonal of common items.
      aIndexPrev1 = aIndexesF[iF];
      aIndexesF[iF] = aFirst + countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);
    }
    return iMaxF;
  };

  // A simple function to extend reverse paths from (d - 1) to d changes
  // when reverse and forward paths cannot yet overlap.
  var extendPathsR = function extendPathsR(d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR // return the value because optimization might decrease it
  ) {
    // Unroll the first iteration.
    var iR = 0;
    var kR = d; // kR = d - 2 * iR
    var aFirst = aIndexesR[iR]; // in first iteration always insert
    var aIndexPrev1 = aFirst; // prev value of [iR - 1] in next iteration
    aIndexesR[iR] -= countCommonItemsR(aStart, aFirst - 1, bStart, bR + aFirst - kR - 1, isCommon);

    // Optimization: skip diagonals in which paths cannot ever overlap.
    var nR = d < iMaxR ? d : iMaxR;

    // The diagonals kR are odd when d is odd and even when d is even.
    for (iR += 1, kR -= 2; iR <= nR; iR += 1, kR -= 2) {
      // To get first point of path segment, move one change in reverse direction
      // from last point of previous path segment in an adjacent diagonal.
      // In last possible iteration when iR === d and kR === -d always delete.
      if (iR !== d && aIndexesR[iR] < aIndexPrev1) {
        aFirst = aIndexesR[iR]; // vertical to insert from b
      } else {
        aFirst = aIndexPrev1 - 1; // horizontal to delete from a

        if (aFirst < aStart) {
          // Optimization: delete moved past left of graph.
          return iR - 1;
        }
      }

      // To get last point of path segment, move along diagonal of common items.
      aIndexPrev1 = aIndexesR[iR];
      aIndexesR[iR] = aFirst - countCommonItemsR(aStart, aFirst - 1, bStart, bR + aFirst - kR - 1, isCommon);
    }
    return iMaxR;
  };

  // A complete function to extend forward paths from (d - 1) to d changes.
  // Return true if a path overlaps reverse path of (d - 1) changes in its diagonal.
  var extendOverlappablePathsF = function extendOverlappablePathsF(d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division // update prop values if return true
  ) {
    var bF = bStart - aStart; // bIndex = bF + aIndex - kF
    var aLength = aEnd - aStart;
    var bLength = bEnd - bStart;
    var baDeltaLength = bLength - aLength; // kF = kR - baDeltaLength

    // Range of diagonals in which forward and reverse paths might overlap.
    var kMinOverlapF = -baDeltaLength - (d - 1); // -(d - 1) <= kR
    var kMaxOverlapF = -baDeltaLength + (d - 1); // kR <= (d - 1)

    var aIndexPrev1 = NOT_YET_SET; // prev value of [iF - 1] in next iteration

    // Optimization: skip diagonals in which paths cannot ever overlap.
    var nF = d < iMaxF ? d : iMaxF;

    // The diagonals kF = 2 * iF - d are odd when d is odd and even when d is even.
    for (var iF = 0, kF = -d; iF <= nF; iF += 1, kF += 2) {
      // To get first point of path segment, move one change in forward direction
      // from last point of previous path segment in an adjacent diagonal.
      // In first iteration when iF === 0 and kF === -d always insert.
      // In last possible iteration when iF === d and kF === d always delete.
      var insert = iF === 0 || iF !== d && aIndexPrev1 < aIndexesF[iF];
      var aLastPrev = insert ? aIndexesF[iF] : aIndexPrev1;
      var aFirst = insert ? aLastPrev // vertical to insert from b
      : aLastPrev + 1; // horizontal to delete from a

      // To get last point of path segment, move along diagonal of common items.
      var bFirst = bF + aFirst - kF;
      var nCommonF = countCommonItemsF(aFirst + 1, aEnd, bFirst + 1, bEnd, isCommon);
      var aLast = aFirst + nCommonF;
      aIndexPrev1 = aIndexesF[iF];
      aIndexesF[iF] = aLast;
      if (kMinOverlapF <= kF && kF <= kMaxOverlapF) {
        // Solve for iR of reverse path with (d - 1) changes in diagonal kF:
        // kR = kF + baDeltaLength
        // kR = (d - 1) - 2 * iR
        var iR = (d - 1 - (kF + baDeltaLength)) / 2;

        // If this forward path overlaps the reverse path in this diagonal,
        // then this is the middle change of the index intervals.
        if (iR <= iMaxR && aIndexesR[iR] - 1 <= aLast) {
          // Unlike the Myers algorithm which finds only the middle “snake”
          // this package can find two common subsequences per division.
          // Last point of previous path segment is on an adjacent diagonal.
          var bLastPrev = bF + aLastPrev - (insert ? kF + 1 : kF - 1);

          // Because of invariant that intervals preceding the middle change
          // cannot have common items at the end,
          // move in reverse direction along a diagonal of common items.
          var nCommonR = countCommonItemsR(aStart, aLastPrev, bStart, bLastPrev, isCommon);
          var aIndexPrevFirst = aLastPrev - nCommonR;
          var bIndexPrevFirst = bLastPrev - nCommonR;
          var aEndPreceding = aIndexPrevFirst + 1;
          var bEndPreceding = bIndexPrevFirst + 1;
          division.nChangePreceding = d - 1;
          if (d - 1 === aEndPreceding + bEndPreceding - aStart - bStart) {
            // Optimization: number of preceding changes in forward direction
            // is equal to number of items in preceding interval,
            // therefore it cannot contain any common items.
            division.aEndPreceding = aStart;
            division.bEndPreceding = bStart;
          } else {
            division.aEndPreceding = aEndPreceding;
            division.bEndPreceding = bEndPreceding;
          }
          division.nCommonPreceding = nCommonR;
          if (nCommonR !== 0) {
            division.aCommonPreceding = aEndPreceding;
            division.bCommonPreceding = bEndPreceding;
          }
          division.nCommonFollowing = nCommonF;
          if (nCommonF !== 0) {
            division.aCommonFollowing = aFirst + 1;
            division.bCommonFollowing = bFirst + 1;
          }
          var aStartFollowing = aLast + 1;
          var bStartFollowing = bFirst + nCommonF + 1;
          division.nChangeFollowing = d - 1;
          if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {
            // Optimization: number of changes in reverse direction
            // is equal to number of items in following interval,
            // therefore it cannot contain any common items.
            division.aStartFollowing = aEnd;
            division.bStartFollowing = bEnd;
          } else {
            division.aStartFollowing = aStartFollowing;
            division.bStartFollowing = bStartFollowing;
          }
          return true;
        }
      }
    }
    return false;
  };

  // A complete function to extend reverse paths from (d - 1) to d changes.
  // Return true if a path overlaps forward path of d changes in its diagonal.
  var extendOverlappablePathsR = function extendOverlappablePathsR(d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division // update prop values if return true
  ) {
    var bR = bEnd - aEnd; // bIndex = bR + aIndex - kR
    var aLength = aEnd - aStart;
    var bLength = bEnd - bStart;
    var baDeltaLength = bLength - aLength; // kR = kF + baDeltaLength

    // Range of diagonals in which forward and reverse paths might overlap.
    var kMinOverlapR = baDeltaLength - d; // -d <= kF
    var kMaxOverlapR = baDeltaLength + d; // kF <= d

    var aIndexPrev1 = NOT_YET_SET; // prev value of [iR - 1] in next iteration

    // Optimization: skip diagonals in which paths cannot ever overlap.
    var nR = d < iMaxR ? d : iMaxR;

    // The diagonals kR = d - 2 * iR are odd when d is odd and even when d is even.
    for (var iR = 0, kR = d; iR <= nR; iR += 1, kR -= 2) {
      // To get first point of path segment, move one change in reverse direction
      // from last point of previous path segment in an adjacent diagonal.
      // In first iteration when iR === 0 and kR === d always insert.
      // In last possible iteration when iR === d and kR === -d always delete.
      var insert = iR === 0 || iR !== d && aIndexesR[iR] < aIndexPrev1;
      var aLastPrev = insert ? aIndexesR[iR] : aIndexPrev1;
      var aFirst = insert ? aLastPrev // vertical to insert from b
      : aLastPrev - 1; // horizontal to delete from a

      // To get last point of path segment, move along diagonal of common items.
      var bFirst = bR + aFirst - kR;
      var nCommonR = countCommonItemsR(aStart, aFirst - 1, bStart, bFirst - 1, isCommon);
      var aLast = aFirst - nCommonR;
      aIndexPrev1 = aIndexesR[iR];
      aIndexesR[iR] = aLast;
      if (kMinOverlapR <= kR && kR <= kMaxOverlapR) {
        // Solve for iF of forward path with d changes in diagonal kR:
        // kF = kR - baDeltaLength
        // kF = 2 * iF - d
        var iF = (d + (kR - baDeltaLength)) / 2;

        // If this reverse path overlaps the forward path in this diagonal,
        // then this is a middle change of the index intervals.
        if (iF <= iMaxF && aLast - 1 <= aIndexesF[iF]) {
          var bLast = bFirst - nCommonR;
          division.nChangePreceding = d;
          if (d === aLast + bLast - aStart - bStart) {
            // Optimization: number of changes in reverse direction
            // is equal to number of items in preceding interval,
            // therefore it cannot contain any common items.
            division.aEndPreceding = aStart;
            division.bEndPreceding = bStart;
          } else {
            division.aEndPreceding = aLast;
            division.bEndPreceding = bLast;
          }
          division.nCommonPreceding = nCommonR;
          if (nCommonR !== 0) {
            // The last point of reverse path segment is start of common subsequence.
            division.aCommonPreceding = aLast;
            division.bCommonPreceding = bLast;
          }
          division.nChangeFollowing = d - 1;
          if (d === 1) {
            // There is no previous path segment.
            division.nCommonFollowing = 0;
            division.aStartFollowing = aEnd;
            division.bStartFollowing = bEnd;
          } else {
            // Unlike the Myers algorithm which finds only the middle “snake”
            // this package can find two common subsequences per division.
            // Last point of previous path segment is on an adjacent diagonal.
            var bLastPrev = bR + aLastPrev - (insert ? kR - 1 : kR + 1);

            // Because of invariant that intervals following the middle change
            // cannot have common items at the start,
            // move in forward direction along a diagonal of common items.
            var nCommonF = countCommonItemsF(aLastPrev, aEnd, bLastPrev, bEnd, isCommon);
            division.nCommonFollowing = nCommonF;
            if (nCommonF !== 0) {
              // The last point of reverse path segment is start of common subsequence.
              division.aCommonFollowing = aLastPrev;
              division.bCommonFollowing = bLastPrev;
            }
            var aStartFollowing = aLastPrev + nCommonF; // aFirstPrev
            var bStartFollowing = bLastPrev + nCommonF; // bFirstPrev

            if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {
              // Optimization: number of changes in forward direction
              // is equal to number of items in following interval,
              // therefore it cannot contain any common items.
              division.aStartFollowing = aEnd;
              division.bStartFollowing = bEnd;
            } else {
              division.aStartFollowing = aStartFollowing;
              division.bStartFollowing = bStartFollowing;
            }
          }
          return true;
        }
      }
    }
    return false;
  };

  // Given index intervals and input function to compare items at indexes,
  // divide at the middle change.
  //
  // DO NOT CALL if start === end, because interval cannot contain common items
  // and because this function will throw the “no overlap” error.
  var divide = function divide(nChange, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, aIndexesR, division // output
  ) {
    var bF = bStart - aStart; // bIndex = bF + aIndex - kF
    var bR = bEnd - aEnd; // bIndex = bR + aIndex - kR
    var aLength = aEnd - aStart;
    var bLength = bEnd - bStart;

    // Because graph has square or portrait orientation,
    // length difference is minimum number of items to insert from b.
    // Corresponding forward and reverse diagonals in graph
    // depend on length difference of the sequences:
    // kF = kR - baDeltaLength
    // kR = kF + baDeltaLength
    var baDeltaLength = bLength - aLength;

    // Optimization: max diagonal in graph intersects corner of shorter side.
    var iMaxF = aLength;
    var iMaxR = aLength;

    // Initialize no changes yet in forward or reverse direction:
    aIndexesF[0] = aStart - 1; // at open start of interval, outside closed start
    aIndexesR[0] = aEnd; // at open end of interval

    if (baDeltaLength % 2 === 0) {
      // The number of changes in paths is 2 * d if length difference is even.
      var dMin = (nChange || baDeltaLength) / 2;
      var dMax = (aLength + bLength) / 2;
      for (var d = 1; d <= dMax; d += 1) {
        iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
        if (d < dMin) {
          iMaxR = extendPathsR(d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);
        } else if (
        // If a reverse path overlaps a forward path in the same diagonal,
        // return a division of the index intervals at the middle change.
        extendOverlappablePathsR(d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division)) {
          return;
        }
      }
    } else {
      // The number of changes in paths is 2 * d - 1 if length difference is odd.
      var _dMin = ((nChange || baDeltaLength) + 1) / 2;
      var _dMax = (aLength + bLength + 1) / 2;

      // Unroll first half iteration so loop extends the relevant pairs of paths.
      // Because of invariant that intervals have no common items at start or end,
      // and limitation not to call divide with empty intervals,
      // therefore it cannot be called if a forward path with one change
      // would overlap a reverse path with no changes, even if dMin === 1.
      var _d = 1;
      iMaxF = extendPathsF(_d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
      for (_d += 1; _d <= _dMax; _d += 1) {
        iMaxR = extendPathsR(_d - 1, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);
        if (_d < _dMin) {
          iMaxF = extendPathsF(_d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
        } else if (
        // If a forward path overlaps a reverse path in the same diagonal,
        // return a division of the index intervals at the middle change.
        extendOverlappablePathsF(_d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division)) {
          return;
        }
      }
    }

    /* istanbul ignore next */
    throw new Error("".concat(pkg, ": no overlap aStart=").concat(aStart, " aEnd=").concat(aEnd, " bStart=").concat(bStart, " bEnd=").concat(bEnd));
  };

  // Given index intervals and input function to compare items at indexes,
  // return by output function the number of adjacent items and starting indexes
  // of each common subsequence. Divide and conquer with only linear space.
  //
  // The index intervals are half open [start, end) like array slice method.
  // DO NOT CALL if start === end, because interval cannot contain common items
  // and because divide function will throw the “no overlap” error.
  var _findSubsequences = function findSubsequences(nChange, aStart, aEnd, bStart, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division // temporary memory, not input nor output
  ) {
    if (bEnd - bStart < aEnd - aStart) {
      // Transpose graph so it has portrait instead of landscape orientation.
      // Always compare shorter to longer sequence for consistency and optimization.
      transposed = !transposed;
      if (transposed && callbacks.length === 1) {
        // Lazily wrap callback functions to swap args if graph is transposed.
        var _callbacks$ = callbacks[0],
          _foundSubsequence = _callbacks$.foundSubsequence,
          _isCommon = _callbacks$.isCommon;
        callbacks[1] = {
          foundSubsequence: function foundSubsequence(nCommon, bCommon, aCommon) {
            _foundSubsequence(nCommon, aCommon, bCommon);
          },
          isCommon: function isCommon(bIndex, aIndex) {
            return _isCommon(aIndex, bIndex);
          }
        };
      }
      var tStart = aStart;
      var tEnd = aEnd;
      aStart = bStart;
      aEnd = bEnd;
      bStart = tStart;
      bEnd = tEnd;
    }
    var _callbacks = callbacks[transposed ? 1 : 0],
      foundSubsequence = _callbacks.foundSubsequence,
      isCommon = _callbacks.isCommon;

    // Divide the index intervals at the middle change.
    divide(nChange, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, aIndexesR, division);
    var nChangePreceding = division.nChangePreceding,
      aEndPreceding = division.aEndPreceding,
      bEndPreceding = division.bEndPreceding,
      nCommonPreceding = division.nCommonPreceding,
      aCommonPreceding = division.aCommonPreceding,
      bCommonPreceding = division.bCommonPreceding,
      nCommonFollowing = division.nCommonFollowing,
      aCommonFollowing = division.aCommonFollowing,
      bCommonFollowing = division.bCommonFollowing,
      nChangeFollowing = division.nChangeFollowing,
      aStartFollowing = division.aStartFollowing,
      bStartFollowing = division.bStartFollowing;

    // Unless either index interval is empty, they might contain common items.
    if (aStart < aEndPreceding && bStart < bEndPreceding) {
      // Recursely find and return common subsequences preceding the division.
      _findSubsequences(nChangePreceding, aStart, aEndPreceding, bStart, bEndPreceding, transposed, callbacks, aIndexesF, aIndexesR, division);
    }

    // Return common subsequences that are adjacent to the middle change.
    if (nCommonPreceding !== 0) {
      foundSubsequence(nCommonPreceding, aCommonPreceding, bCommonPreceding);
    }
    if (nCommonFollowing !== 0) {
      foundSubsequence(nCommonFollowing, aCommonFollowing, bCommonFollowing);
    }

    // Unless either index interval is empty, they might contain common items.
    if (aStartFollowing < aEnd && bStartFollowing < bEnd) {
      // Recursely find and return common subsequences following the division.
      _findSubsequences(nChangeFollowing, aStartFollowing, aEnd, bStartFollowing, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division);
    }
  };
  var validateLength = function validateLength(name, arg) {
    if (typeof arg !== 'number') {
      throw new TypeError("".concat(pkg, ": ").concat(name, " typeof ").concat(_typeof(arg), " is not a number"));
    }
    if (!Number.isSafeInteger(arg)) {
      throw new RangeError("".concat(pkg, ": ").concat(name, " value ").concat(arg, " is not a safe integer"));
    }
    if (arg < 0) {
      throw new RangeError("".concat(pkg, ": ").concat(name, " value ").concat(arg, " is a negative integer"));
    }
  };
  var validateCallback = function validateCallback(name, arg) {
    var type = _typeof(arg);
    if (type !== 'function') {
      throw new TypeError("".concat(pkg, ": ").concat(name, " typeof ").concat(type, " is not a function"));
    }
  };

  // Compare items in two sequences to find a longest common subsequence.
  // Given lengths of sequences and input function to compare items at indexes,
  // return by output function the number of adjacent items and starting indexes
  // of each common subsequence.
  function diffSequence(aLength, bLength, isCommon, foundSubsequence) {
    validateLength('aLength', aLength);
    validateLength('bLength', bLength);
    validateCallback('isCommon', isCommon);
    validateCallback('foundSubsequence', foundSubsequence);

    // Count common items from the start in the forward direction.
    var nCommonF = countCommonItemsF(0, aLength, 0, bLength, isCommon);
    if (nCommonF !== 0) {
      foundSubsequence(nCommonF, 0, 0);
    }

    // Unless both sequences consist of common items only,
    // find common items in the half-trimmed index intervals.
    if (aLength !== nCommonF || bLength !== nCommonF) {
      // Invariant: intervals do not have common items at the start.
      // The start of an index interval is closed like array slice method.
      var aStart = nCommonF;
      var bStart = nCommonF;

      // Count common items from the end in the reverse direction.
      var nCommonR = countCommonItemsR(aStart, aLength - 1, bStart, bLength - 1, isCommon);

      // Invariant: intervals do not have common items at the end.
      // The end of an index interval is open like array slice method.
      var aEnd = aLength - nCommonR;
      var bEnd = bLength - nCommonR;

      // Unless one sequence consists of common items only,
      // therefore the other trimmed index interval consists of changes only,
      // find common items in the trimmed index intervals.
      var nCommonFR = nCommonF + nCommonR;
      if (aLength !== nCommonFR && bLength !== nCommonFR) {
        var nChange = 0; // number of change items is not yet known
        var transposed = false; // call the original unwrapped functions
        var callbacks = [{
          foundSubsequence: foundSubsequence,
          isCommon: isCommon
        }];

        // Indexes in sequence a of last points in furthest reaching paths
        // from outside the start at top left in the forward direction:
        var aIndexesF = [NOT_YET_SET];
        // from the end at bottom right in the reverse direction:
        var aIndexesR = [NOT_YET_SET];

        // Initialize one object as output of all calls to divide function.
        var division = {
          aCommonFollowing: NOT_YET_SET,
          aCommonPreceding: NOT_YET_SET,
          aEndPreceding: NOT_YET_SET,
          aStartFollowing: NOT_YET_SET,
          bCommonFollowing: NOT_YET_SET,
          bCommonPreceding: NOT_YET_SET,
          bEndPreceding: NOT_YET_SET,
          bStartFollowing: NOT_YET_SET,
          nChangeFollowing: NOT_YET_SET,
          nChangePreceding: NOT_YET_SET,
          nCommonFollowing: NOT_YET_SET,
          nCommonPreceding: NOT_YET_SET
        };

        // Find and return common subsequences in the trimmed index intervals.
        _findSubsequences(nChange, aStart, aEnd, bStart, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division);
      }
      if (nCommonR !== 0) {
        foundSubsequence(nCommonR, aEnd, bEnd);
      }
    }
  }
  return build;
}
var buildExports = requireBuild();
var diffSequences = /*@__PURE__*/getDefaultExportFromCjs$2(buildExports);
function formatTrailingSpaces(line, trailingSpaceFormatter) {
  return line.replace(/\s+$/, function (match) {
    return trailingSpaceFormatter(match);
  });
}
function printDiffLine(line, isFirstOrLast, color, indicator, trailingSpaceFormatter, emptyFirstOrLastLinePlaceholder) {
  return line.length !== 0 ? color("".concat(indicator, " ").concat(formatTrailingSpaces(line, trailingSpaceFormatter))) : indicator !== " " ? color(indicator) : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0 ? color("".concat(indicator, " ").concat(emptyFirstOrLastLinePlaceholder)) : "";
}
function printDeleteLine(line, isFirstOrLast, _ref) {
  var aColor = _ref.aColor,
    aIndicator = _ref.aIndicator,
    changeLineTrailingSpaceColor = _ref.changeLineTrailingSpaceColor,
    emptyFirstOrLastLinePlaceholder = _ref.emptyFirstOrLastLinePlaceholder;
  return printDiffLine(line, isFirstOrLast, aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
function printInsertLine(line, isFirstOrLast, _ref2) {
  var bColor = _ref2.bColor,
    bIndicator = _ref2.bIndicator,
    changeLineTrailingSpaceColor = _ref2.changeLineTrailingSpaceColor,
    emptyFirstOrLastLinePlaceholder = _ref2.emptyFirstOrLastLinePlaceholder;
  return printDiffLine(line, isFirstOrLast, bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
function printCommonLine(line, isFirstOrLast, _ref3) {
  var commonColor = _ref3.commonColor,
    commonIndicator = _ref3.commonIndicator,
    commonLineTrailingSpaceColor = _ref3.commonLineTrailingSpaceColor,
    emptyFirstOrLastLinePlaceholder = _ref3.emptyFirstOrLastLinePlaceholder;
  return printDiffLine(line, isFirstOrLast, commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
// In GNU diff format, indexes are one-based instead of zero-based.
function createPatchMark(aStart, aEnd, bStart, bEnd, _ref4) {
  var patchColor = _ref4.patchColor;
  return patchColor("@@ -".concat(aStart + 1, ",").concat(aEnd - aStart, " +").concat(bStart + 1, ",").concat(bEnd - bStart, " @@"));
}
// jest --no-expand
//
// Given array of aligned strings with inverse highlight formatting,
// return joined lines with diff formatting (and patch marks, if needed).
function joinAlignedDiffsNoExpand(diffs, options) {
  var iLength = diffs.length;
  var nContextLines = options.contextLines;
  var nContextLines2 = nContextLines + nContextLines;
  // First pass: count output lines and see if it has patches.
  var jLength = iLength;
  var hasExcessAtStartOrEnd = false;
  var nExcessesBetweenChanges = 0;
  var i = 0;
  while (i !== iLength) {
    var iStart = i;
    while (i !== iLength && diffs[i][0] === DIFF_EQUAL) {
      i += 1;
    }
    if (iStart !== i) {
      if (iStart === 0) {
        // at start
        if (i > nContextLines) {
          jLength -= i - nContextLines;
          hasExcessAtStartOrEnd = true;
        }
      } else if (i === iLength) {
        // at end
        var n = i - iStart;
        if (n > nContextLines) {
          jLength -= n - nContextLines;
          hasExcessAtStartOrEnd = true;
        }
      } else {
        // between changes
        var _n = i - iStart;
        if (_n > nContextLines2) {
          jLength -= _n - nContextLines2;
          nExcessesBetweenChanges += 1;
        }
      }
    }
    while (i !== iLength && diffs[i][0] !== DIFF_EQUAL) {
      i += 1;
    }
  }
  var hasPatch = nExcessesBetweenChanges !== 0 || hasExcessAtStartOrEnd;
  if (nExcessesBetweenChanges !== 0) {
    jLength += nExcessesBetweenChanges + 1;
  } else if (hasExcessAtStartOrEnd) {
    jLength += 1;
  }
  var jLast = jLength - 1;
  var lines = [];
  var jPatchMark = 0;
  if (hasPatch) {
    lines.push("");
  }
  // Indexes of expected or received lines in current patch:
  var aStart = 0;
  var bStart = 0;
  var aEnd = 0;
  var bEnd = 0;
  var pushCommonLine = function pushCommonLine(line) {
    var j = lines.length;
    lines.push(printCommonLine(line, j === 0 || j === jLast, options));
    aEnd += 1;
    bEnd += 1;
  };
  var pushDeleteLine = function pushDeleteLine(line) {
    var j = lines.length;
    lines.push(printDeleteLine(line, j === 0 || j === jLast, options));
    aEnd += 1;
  };
  var pushInsertLine = function pushInsertLine(line) {
    var j = lines.length;
    lines.push(printInsertLine(line, j === 0 || j === jLast, options));
    bEnd += 1;
  };
  // Second pass: push lines with diff formatting (and patch marks, if needed).
  i = 0;
  while (i !== iLength) {
    var _iStart = i;
    while (i !== iLength && diffs[i][0] === DIFF_EQUAL) {
      i += 1;
    }
    if (_iStart !== i) {
      if (_iStart === 0) {
        // at beginning
        if (i > nContextLines) {
          _iStart = i - nContextLines;
          aStart = _iStart;
          bStart = _iStart;
          aEnd = aStart;
          bEnd = bStart;
        }
        for (var iCommon = _iStart; iCommon !== i; iCommon += 1) {
          pushCommonLine(diffs[iCommon][1]);
        }
      } else if (i === iLength) {
        // at end
        var iEnd = i - _iStart > nContextLines ? _iStart + nContextLines : i;
        for (var _iCommon = _iStart; _iCommon !== iEnd; _iCommon += 1) {
          pushCommonLine(diffs[_iCommon][1]);
        }
      } else {
        // between changes
        var nCommon = i - _iStart;
        if (nCommon > nContextLines2) {
          var _iEnd = _iStart + nContextLines;
          for (var _iCommon2 = _iStart; _iCommon2 !== _iEnd; _iCommon2 += 1) {
            pushCommonLine(diffs[_iCommon2][1]);
          }
          lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);
          jPatchMark = lines.length;
          lines.push("");
          var nOmit = nCommon - nContextLines2;
          aStart = aEnd + nOmit;
          bStart = bEnd + nOmit;
          aEnd = aStart;
          bEnd = bStart;
          for (var _iCommon3 = i - nContextLines; _iCommon3 !== i; _iCommon3 += 1) {
            pushCommonLine(diffs[_iCommon3][1]);
          }
        } else {
          for (var _iCommon4 = _iStart; _iCommon4 !== i; _iCommon4 += 1) {
            pushCommonLine(diffs[_iCommon4][1]);
          }
        }
      }
    }
    while (i !== iLength && diffs[i][0] === DIFF_DELETE) {
      pushDeleteLine(diffs[i][1]);
      i += 1;
    }
    while (i !== iLength && diffs[i][0] === DIFF_INSERT) {
      pushInsertLine(diffs[i][1]);
      i += 1;
    }
  }
  if (hasPatch) {
    lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);
  }
  return lines.join("\n");
}
// jest --expand
//
// Given array of aligned strings with inverse highlight formatting,
// return joined lines with diff formatting.
function joinAlignedDiffsExpand(diffs, options) {
  return diffs.map(function (diff, i, diffs) {
    var line = diff[1];
    var isFirstOrLast = i === 0 || i === diffs.length - 1;
    switch (diff[0]) {
      case DIFF_DELETE:
        return printDeleteLine(line, isFirstOrLast, options);
      case DIFF_INSERT:
        return printInsertLine(line, isFirstOrLast, options);
      default:
        return printCommonLine(line, isFirstOrLast, options);
    }
  }).join("\n");
}
var noColor = function noColor(string) {
  return string;
};
var DIFF_CONTEXT_DEFAULT = 5;
var DIFF_TRUNCATE_THRESHOLD_DEFAULT = 0;
function getDefaultOptions() {
  return {
    aAnnotation: "Expected",
    aColor: s.green,
    aIndicator: "-",
    bAnnotation: "Received",
    bColor: s.red,
    bIndicator: "+",
    changeColor: s.inverse,
    changeLineTrailingSpaceColor: noColor,
    commonColor: s.dim,
    commonIndicator: " ",
    commonLineTrailingSpaceColor: noColor,
    compareKeys: undefined,
    contextLines: DIFF_CONTEXT_DEFAULT,
    emptyFirstOrLastLinePlaceholder: "",
    expand: false,
    includeChangeCounts: false,
    omitAnnotationLines: false,
    patchColor: s.yellow,
    printBasicPrototype: false,
    truncateThreshold: DIFF_TRUNCATE_THRESHOLD_DEFAULT,
    truncateAnnotation: "... Diff result is truncated",
    truncateAnnotationColor: noColor
  };
}
function getCompareKeys(compareKeys) {
  return compareKeys && typeof compareKeys === "function" ? compareKeys : undefined;
}
function getContextLines(contextLines) {
  return typeof contextLines === "number" && Number.isSafeInteger(contextLines) && contextLines >= 0 ? contextLines : DIFF_CONTEXT_DEFAULT;
}
// Pure function returns options with all properties.
function normalizeDiffOptions() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return _objectSpread$6(_objectSpread$6(_objectSpread$6({}, getDefaultOptions()), options), {}, {
    compareKeys: getCompareKeys(options.compareKeys),
    contextLines: getContextLines(options.contextLines)
  });
}
function isEmptyString(lines) {
  return lines.length === 1 && lines[0].length === 0;
}
function countChanges(diffs) {
  var a = 0;
  var b = 0;
  diffs.forEach(function (diff) {
    switch (diff[0]) {
      case DIFF_DELETE:
        a += 1;
        break;
      case DIFF_INSERT:
        b += 1;
        break;
    }
  });
  return {
    a: a,
    b: b
  };
}
function printAnnotation(_ref5, changeCounts) {
  var aAnnotation = _ref5.aAnnotation,
    aColor = _ref5.aColor,
    aIndicator = _ref5.aIndicator,
    bAnnotation = _ref5.bAnnotation,
    bColor = _ref5.bColor,
    bIndicator = _ref5.bIndicator,
    includeChangeCounts = _ref5.includeChangeCounts,
    omitAnnotationLines = _ref5.omitAnnotationLines;
  if (omitAnnotationLines) {
    return "";
  }
  var aRest = "";
  var bRest = "";
  if (includeChangeCounts) {
    var aCount = String(changeCounts.a);
    var bCount = String(changeCounts.b);
    // Padding right aligns the ends of the annotations.
    var baAnnotationLengthDiff = bAnnotation.length - aAnnotation.length;
    var aAnnotationPadding = " ".repeat(Math.max(0, baAnnotationLengthDiff));
    var bAnnotationPadding = " ".repeat(Math.max(0, -baAnnotationLengthDiff));
    // Padding left aligns the ends of the counts.
    var baCountLengthDiff = bCount.length - aCount.length;
    var aCountPadding = " ".repeat(Math.max(0, baCountLengthDiff));
    var bCountPadding = " ".repeat(Math.max(0, -baCountLengthDiff));
    aRest = "".concat(aAnnotationPadding, "  ").concat(aIndicator, " ").concat(aCountPadding).concat(aCount);
    bRest = "".concat(bAnnotationPadding, "  ").concat(bIndicator, " ").concat(bCountPadding).concat(bCount);
  }
  var a = "".concat(aIndicator, " ").concat(aAnnotation).concat(aRest);
  var b = "".concat(bIndicator, " ").concat(bAnnotation).concat(bRest);
  return "".concat(aColor(a), "\n").concat(bColor(b), "\n\n");
}
function printDiffLines(diffs, truncated, options) {
  return printAnnotation(options, countChanges(diffs)) + (options.expand ? joinAlignedDiffsExpand(diffs, options) : joinAlignedDiffsNoExpand(diffs, options)) + (truncated ? options.truncateAnnotationColor("\n".concat(options.truncateAnnotation)) : "");
}
// Compare two arrays of strings line-by-line. Format as comparison lines.
function diffLinesUnified(aLines, bLines, options) {
  var normalizedOptions = normalizeDiffOptions(options);
  var _diffLinesRaw = diffLinesRaw(isEmptyString(aLines) ? [] : aLines, isEmptyString(bLines) ? [] : bLines, normalizedOptions),
    _diffLinesRaw2 = _slicedToArray(_diffLinesRaw, 2),
    diffs = _diffLinesRaw2[0],
    truncated = _diffLinesRaw2[1];
  return printDiffLines(diffs, truncated, normalizedOptions);
}
// Given two pairs of arrays of strings:
// Compare the pair of comparison arrays line-by-line.
// Format the corresponding lines in the pair of displayable arrays.
function diffLinesUnified2(aLinesDisplay, bLinesDisplay, aLinesCompare, bLinesCompare, options) {
  if (isEmptyString(aLinesDisplay) && isEmptyString(aLinesCompare)) {
    aLinesDisplay = [];
    aLinesCompare = [];
  }
  if (isEmptyString(bLinesDisplay) && isEmptyString(bLinesCompare)) {
    bLinesDisplay = [];
    bLinesCompare = [];
  }
  if (aLinesDisplay.length !== aLinesCompare.length || bLinesDisplay.length !== bLinesCompare.length) {
    // Fall back to diff of display lines.
    return diffLinesUnified(aLinesDisplay, bLinesDisplay, options);
  }
  var _diffLinesRaw3 = diffLinesRaw(aLinesCompare, bLinesCompare, options),
    _diffLinesRaw4 = _slicedToArray(_diffLinesRaw3, 2),
    diffs = _diffLinesRaw4[0],
    truncated = _diffLinesRaw4[1];
  // Replace comparison lines with displayable lines.
  var aIndex = 0;
  var bIndex = 0;
  diffs.forEach(function (diff) {
    switch (diff[0]) {
      case DIFF_DELETE:
        diff[1] = aLinesDisplay[aIndex];
        aIndex += 1;
        break;
      case DIFF_INSERT:
        diff[1] = bLinesDisplay[bIndex];
        bIndex += 1;
        break;
      default:
        diff[1] = bLinesDisplay[bIndex];
        aIndex += 1;
        bIndex += 1;
    }
  });
  return printDiffLines(diffs, truncated, normalizeDiffOptions(options));
}
// Compare two arrays of strings line-by-line.
function diffLinesRaw(aLines, bLines, options) {
  var _ref6, _ref7;
  var truncate = (_ref6 = options === null || options === void 0 ? void 0 : options.truncateThreshold) !== null && _ref6 !== void 0 ? _ref6 : false;
  var truncateThreshold = Math.max(Math.floor((_ref7 = options === null || options === void 0 ? void 0 : options.truncateThreshold) !== null && _ref7 !== void 0 ? _ref7 : 0), 0);
  var aLength = truncate ? Math.min(aLines.length, truncateThreshold) : aLines.length;
  var bLength = truncate ? Math.min(bLines.length, truncateThreshold) : bLines.length;
  var truncated = aLength !== aLines.length || bLength !== bLines.length;
  var isCommon = function isCommon(aIndex, bIndex) {
    return aLines[aIndex] === bLines[bIndex];
  };
  var diffs = [];
  var aIndex = 0;
  var bIndex = 0;
  var foundSubsequence = function foundSubsequence(nCommon, aCommon, bCommon) {
    for (; aIndex !== aCommon; aIndex += 1) {
      diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));
    }
    for (; bIndex !== bCommon; bIndex += 1) {
      diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));
    }
    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {
      diffs.push(new Diff(DIFF_EQUAL, bLines[bIndex]));
    }
  };
  diffSequences(aLength, bLength, isCommon, foundSubsequence);
  // After the last common subsequence, push remaining change items.
  for (; aIndex !== aLength; aIndex += 1) {
    diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));
  }
  for (; bIndex !== bLength; bIndex += 1) {
    diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));
  }
  return [diffs, truncated];
}

// get the type of a value with handling the edge cases like `typeof []`
// and `typeof null`
function getType(value) {
  if (value === undefined) {
    return "undefined";
  } else if (value === null) {
    return "null";
  } else if (Array.isArray(value)) {
    return "array";
  } else if (typeof value === "boolean") {
    return "boolean";
  } else if (typeof value === "function") {
    return "function";
  } else if (typeof value === "number") {
    return "number";
  } else if (typeof value === "string") {
    return "string";
  } else if (typeof value === "bigint") {
    return "bigint";
  } else if (_typeof(value) === "object") {
    if (value != null) {
      if (value.constructor === RegExp) {
        return "regexp";
      } else if (value.constructor === Map) {
        return "map";
      } else if (value.constructor === Set) {
        return "set";
      } else if (value.constructor === Date) {
        return "date";
      }
    }
    return "object";
  } else if (_typeof(value) === "symbol") {
    return "symbol";
  }
  throw new Error("value of unknown type: ".concat(value));
}

// platforms compatible
function getNewLineSymbol(string) {
  return string.includes("\r\n") ? "\r\n" : "\n";
}
function diffStrings(a, b, options) {
  var _ref8, _ref9;
  var truncate = (_ref8 = options === null || options === void 0 ? void 0 : options.truncateThreshold) !== null && _ref8 !== void 0 ? _ref8 : false;
  var truncateThreshold = Math.max(Math.floor((_ref9 = options === null || options === void 0 ? void 0 : options.truncateThreshold) !== null && _ref9 !== void 0 ? _ref9 : 0), 0);
  var aLength = a.length;
  var bLength = b.length;
  if (truncate) {
    var aMultipleLines = a.includes("\n");
    var bMultipleLines = b.includes("\n");
    var aNewLineSymbol = getNewLineSymbol(a);
    var bNewLineSymbol = getNewLineSymbol(b);
    // multiple-lines string expects a newline to be appended at the end
    var _a = aMultipleLines ? "".concat(a.split(aNewLineSymbol, truncateThreshold).join(aNewLineSymbol), "\n") : a;
    var _b = bMultipleLines ? "".concat(b.split(bNewLineSymbol, truncateThreshold).join(bNewLineSymbol), "\n") : b;
    aLength = _a.length;
    bLength = _b.length;
  }
  var truncated = aLength !== a.length || bLength !== b.length;
  var isCommon = function isCommon(aIndex, bIndex) {
    return a[aIndex] === b[bIndex];
  };
  var aIndex = 0;
  var bIndex = 0;
  var diffs = [];
  var foundSubsequence = function foundSubsequence(nCommon, aCommon, bCommon) {
    if (aIndex !== aCommon) {
      diffs.push(new Diff(DIFF_DELETE, a.slice(aIndex, aCommon)));
    }
    if (bIndex !== bCommon) {
      diffs.push(new Diff(DIFF_INSERT, b.slice(bIndex, bCommon)));
    }
    aIndex = aCommon + nCommon;
    bIndex = bCommon + nCommon;
    diffs.push(new Diff(DIFF_EQUAL, b.slice(bCommon, bIndex)));
  };
  diffSequences(aLength, bLength, isCommon, foundSubsequence);
  // After the last common subsequence, push remaining change items.
  if (aIndex !== aLength) {
    diffs.push(new Diff(DIFF_DELETE, a.slice(aIndex)));
  }
  if (bIndex !== bLength) {
    diffs.push(new Diff(DIFF_INSERT, b.slice(bIndex)));
  }
  return [diffs, truncated];
}

// Given change op and array of diffs, return concatenated string:
// * include common strings
// * include change strings which have argument op with changeColor
// * exclude change strings which have opposite op
function concatenateRelevantDiffs(op, diffs, changeColor) {
  return diffs.reduce(function (reduced, diff) {
    return reduced + (diff[0] === DIFF_EQUAL ? diff[1] : diff[0] === op && diff[1].length !== 0 ? changeColor(diff[1]) : "");
  }, "");
}
// Encapsulate change lines until either a common newline or the end.
var ChangeBuffer = /*#__PURE__*/function () {
  function ChangeBuffer(op, changeColor) {
    _classCallCheck(this, ChangeBuffer);
    _defineProperty(this, "op", void 0);
    _defineProperty(this, "line", void 0);
    _defineProperty(this, "lines", void 0);
    _defineProperty(this, "changeColor", void 0);
    this.op = op;
    this.line = [];
    this.lines = [];
    this.changeColor = changeColor;
  }
  return _createClass(ChangeBuffer, [{
    key: "pushSubstring",
    value: function pushSubstring(substring) {
      this.pushDiff(new Diff(this.op, substring));
    }
  }, {
    key: "pushLine",
    value: function pushLine() {
      // Assume call only if line has at least one diff,
      // therefore an empty line must have a diff which has an empty string.
      // If line has multiple diffs, then assume it has a common diff,
      // therefore change diffs have change color;
      // otherwise then it has line color only.
      this.lines.push(this.line.length !== 1 ? new Diff(this.op, concatenateRelevantDiffs(this.op, this.line, this.changeColor)) : this.line[0][0] === this.op ? this.line[0] : new Diff(this.op, this.line[0][1]));
      this.line.length = 0;
    }
  }, {
    key: "isLineEmpty",
    value: function isLineEmpty() {
      return this.line.length === 0;
    }
    // Minor input to buffer.
  }, {
    key: "pushDiff",
    value: function pushDiff(diff) {
      this.line.push(diff);
    }
    // Main input to buffer.
  }, {
    key: "align",
    value: function align(diff) {
      var _this = this;
      var string = diff[1];
      if (string.includes("\n")) {
        var substrings = string.split("\n");
        var iLast = substrings.length - 1;
        substrings.forEach(function (substring, i) {
          if (i < iLast) {
            // The first substring completes the current change line.
            // A middle substring is a change line.
            _this.pushSubstring(substring);
            _this.pushLine();
          } else if (substring.length !== 0) {
            // The last substring starts a change line, if it is not empty.
            // Important: This non-empty condition also automatically omits
            // the newline appended to the end of expected and received strings.
            _this.pushSubstring(substring);
          }
        });
      } else {
        // Append non-multiline string to current change line.
        this.pushDiff(diff);
      }
    }
    // Output from buffer.
  }, {
    key: "moveLinesTo",
    value: function moveLinesTo(lines) {
      if (!this.isLineEmpty()) {
        this.pushLine();
      }
      lines.push.apply(lines, _toConsumableArray(this.lines));
      this.lines.length = 0;
    }
  }]);
}(); // Encapsulate common and change lines.
var CommonBuffer = /*#__PURE__*/function () {
  function CommonBuffer(deleteBuffer, insertBuffer) {
    _classCallCheck(this, CommonBuffer);
    _defineProperty(this, "deleteBuffer", void 0);
    _defineProperty(this, "insertBuffer", void 0);
    _defineProperty(this, "lines", void 0);
    this.deleteBuffer = deleteBuffer;
    this.insertBuffer = insertBuffer;
    this.lines = [];
  }
  return _createClass(CommonBuffer, [{
    key: "pushDiffCommonLine",
    value: function pushDiffCommonLine(diff) {
      this.lines.push(diff);
    }
  }, {
    key: "pushDiffChangeLines",
    value: function pushDiffChangeLines(diff) {
      var isDiffEmpty = diff[1].length === 0;
      // An empty diff string is redundant, unless a change line is empty.
      if (!isDiffEmpty || this.deleteBuffer.isLineEmpty()) {
        this.deleteBuffer.pushDiff(diff);
      }
      if (!isDiffEmpty || this.insertBuffer.isLineEmpty()) {
        this.insertBuffer.pushDiff(diff);
      }
    }
  }, {
    key: "flushChangeLines",
    value: function flushChangeLines() {
      this.deleteBuffer.moveLinesTo(this.lines);
      this.insertBuffer.moveLinesTo(this.lines);
    }
    // Input to buffer.
  }, {
    key: "align",
    value: function align(diff) {
      var _this2 = this;
      var op = diff[0];
      var string = diff[1];
      if (string.includes("\n")) {
        var substrings = string.split("\n");
        var iLast = substrings.length - 1;
        substrings.forEach(function (substring, i) {
          if (i === 0) {
            var subdiff = new Diff(op, substring);
            if (_this2.deleteBuffer.isLineEmpty() && _this2.insertBuffer.isLineEmpty()) {
              // If both current change lines are empty,
              // then the first substring is a common line.
              _this2.flushChangeLines();
              _this2.pushDiffCommonLine(subdiff);
            } else {
              // If either current change line is non-empty,
              // then the first substring completes the change lines.
              _this2.pushDiffChangeLines(subdiff);
              _this2.flushChangeLines();
            }
          } else if (i < iLast) {
            // A middle substring is a common line.
            _this2.pushDiffCommonLine(new Diff(op, substring));
          } else if (substring.length !== 0) {
            // The last substring starts a change line, if it is not empty.
            // Important: This non-empty condition also automatically omits
            // the newline appended to the end of expected and received strings.
            _this2.pushDiffChangeLines(new Diff(op, substring));
          }
        });
      } else {
        // Append non-multiline string to current change lines.
        // Important: It cannot be at the end following empty change lines,
        // because newline appended to the end of expected and received strings.
        this.pushDiffChangeLines(diff);
      }
    }
    // Output from buffer.
  }, {
    key: "getLines",
    value: function getLines() {
      this.flushChangeLines();
      return this.lines;
    }
  }]);
}(); // Given diffs from expected and received strings,
// return new array of diffs split or joined into lines.
//
// To correctly align a change line at the end, the algorithm:
// * assumes that a newline was appended to the strings
// * omits the last newline from the output array
//
// Assume the function is not called:
// * if either expected or received is empty string
// * if neither expected nor received is multiline string
function getAlignedDiffs(diffs, changeColor) {
  var deleteBuffer = new ChangeBuffer(DIFF_DELETE, changeColor);
  var insertBuffer = new ChangeBuffer(DIFF_INSERT, changeColor);
  var commonBuffer = new CommonBuffer(deleteBuffer, insertBuffer);
  diffs.forEach(function (diff) {
    switch (diff[0]) {
      case DIFF_DELETE:
        deleteBuffer.align(diff);
        break;
      case DIFF_INSERT:
        insertBuffer.align(diff);
        break;
      default:
        commonBuffer.align(diff);
    }
  });
  return commonBuffer.getLines();
}
function hasCommonDiff(diffs, isMultiline) {
  if (isMultiline) {
    // Important: Ignore common newline that was appended to multiline strings!
    var iLast = diffs.length - 1;
    return diffs.some(function (diff, i) {
      return diff[0] === DIFF_EQUAL && (i !== iLast || diff[1] !== "\n");
    });
  }
  return diffs.some(function (diff) {
    return diff[0] === DIFF_EQUAL;
  });
}
// Compare two strings character-by-character.
// Format as comparison lines in which changed substrings have inverse colors.
function diffStringsUnified(a, b, options) {
  if (a !== b && a.length !== 0 && b.length !== 0) {
    var isMultiline = a.includes("\n") || b.includes("\n");
    // getAlignedDiffs assumes that a newline was appended to the strings.
    var _diffStringsRaw = diffStringsRaw(isMultiline ? "".concat(a, "\n") : a, isMultiline ? "".concat(b, "\n") : b, true, options),
      _diffStringsRaw2 = _slicedToArray(_diffStringsRaw, 2),
      diffs = _diffStringsRaw2[0],
      truncated = _diffStringsRaw2[1];
    if (hasCommonDiff(diffs, isMultiline)) {
      var optionsNormalized = normalizeDiffOptions(options);
      var lines = getAlignedDiffs(diffs, optionsNormalized.changeColor);
      return printDiffLines(lines, truncated, optionsNormalized);
    }
  }
  // Fall back to line-by-line diff.
  return diffLinesUnified(a.split("\n"), b.split("\n"), options);
}
// Compare two strings character-by-character.
// Optionally clean up small common substrings, also known as chaff.
function diffStringsRaw(a, b, cleanup, options) {
  var _diffStrings = diffStrings(a, b, options),
    _diffStrings2 = _slicedToArray(_diffStrings, 2),
    diffs = _diffStrings2[0],
    truncated = _diffStrings2[1];
  if (cleanup) {
    diff_cleanupSemantic(diffs);
  }
  return [diffs, truncated];
}
function getCommonMessage(message, options) {
  var _normalizeDiffOptions = normalizeDiffOptions(options),
    commonColor = _normalizeDiffOptions.commonColor;
  return commonColor(message);
}
var AsymmetricMatcher$2 = plugins.AsymmetricMatcher,
  DOMCollection$1 = plugins.DOMCollection,
  DOMElement$1 = plugins.DOMElement,
  Immutable$1 = plugins.Immutable,
  ReactElement$1 = plugins.ReactElement,
  ReactTestComponent$1 = plugins.ReactTestComponent;
var PLUGINS$1 = [ReactTestComponent$1, ReactElement$1, DOMElement$1, DOMCollection$1, Immutable$1, AsymmetricMatcher$2, plugins.Error];
var FORMAT_OPTIONS = {
  maxDepth: 20,
  plugins: PLUGINS$1
};
var FALLBACK_FORMAT_OPTIONS = {
  callToJSON: false,
  maxDepth: 8,
  plugins: PLUGINS$1
};
// Generate a string that will highlight the difference between two values
// with green and red. (similar to how github does code diffing)
/**
* @param a Expected value
* @param b Received value
* @param options Diff options
* @returns {string | null} a string diff
*/
function diff(a, b, options) {
  if (Object.is(a, b)) {
    return "";
  }
  var aType = getType(a);
  var expectedType = aType;
  var omitDifference = false;
  if (aType === "object" && typeof a.asymmetricMatch === "function") {
    if (a.$$typeof !== Symbol.for("jest.asymmetricMatcher")) {
      // Do not know expected type of user-defined asymmetric matcher.
      return undefined;
    }
    if (typeof a.getExpectedType !== "function") {
      // For example, expect.anything() matches either null or undefined
      return undefined;
    }
    expectedType = a.getExpectedType();
    // Primitive types boolean and number omit difference below.
    // For example, omit difference for expect.stringMatching(regexp)
    omitDifference = expectedType === "string";
  }
  if (expectedType !== getType(b)) {
    var _normalizeDiffOptions2 = normalizeDiffOptions(options),
      aAnnotation = _normalizeDiffOptions2.aAnnotation,
      aColor = _normalizeDiffOptions2.aColor,
      aIndicator = _normalizeDiffOptions2.aIndicator,
      bAnnotation = _normalizeDiffOptions2.bAnnotation,
      bColor = _normalizeDiffOptions2.bColor,
      bIndicator = _normalizeDiffOptions2.bIndicator;
    var formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options);
    var aDisplay = format$1(a, formatOptions);
    var bDisplay = format$1(b, formatOptions);
    // even if prettyFormat prints successfully big objects,
    // large string can choke later on (concatenation? RPC?),
    // so truncate it to a reasonable length here.
    // (For example, playwright's ElementHandle can become about 200_000_000 length string)
    var MAX_LENGTH = 1e5;
    function truncate(s) {
      return s.length <= MAX_LENGTH ? s : "".concat(s.slice(0, MAX_LENGTH), "...");
    }
    aDisplay = truncate(aDisplay);
    bDisplay = truncate(bDisplay);
    var aDiff = "".concat(aColor("".concat(aIndicator, " ").concat(aAnnotation, ":")), " \n").concat(aDisplay);
    var bDiff = "".concat(bColor("".concat(bIndicator, " ").concat(bAnnotation, ":")), " \n").concat(bDisplay);
    return "".concat(aDiff, "\n\n").concat(bDiff);
  }
  if (omitDifference) {
    return undefined;
  }
  switch (aType) {
    case "string":
      return diffLinesUnified(a.split("\n"), b.split("\n"), options);
    case "boolean":
    case "number":
      return comparePrimitive(a, b, options);
    case "map":
      return compareObjects(sortMap(a), sortMap(b), options);
    case "set":
      return compareObjects(sortSet(a), sortSet(b), options);
    default:
      return compareObjects(a, b, options);
  }
}
function comparePrimitive(a, b, options) {
  var aFormat = format$1(a, FORMAT_OPTIONS);
  var bFormat = format$1(b, FORMAT_OPTIONS);
  return aFormat === bFormat ? "" : diffLinesUnified(aFormat.split("\n"), bFormat.split("\n"), options);
}
function sortMap(map) {
  return new Map(Array.from(map.entries()).sort());
}
function sortSet(set) {
  return new Set(Array.from(set.values()).sort());
}
function compareObjects(a, b, options) {
  var difference;
  var hasThrown = false;
  try {
    var formatOptions = getFormatOptions(FORMAT_OPTIONS, options);
    difference = getObjectsDifference(a, b, formatOptions, options);
  } catch (_unused) {
    hasThrown = true;
  }
  var noDiffMessage = getCommonMessage(NO_DIFF_MESSAGE, options);
  // If the comparison yields no results, compare again but this time
  // without calling `toJSON`. It's also possible that toJSON might throw.
  if (difference === undefined || difference === noDiffMessage) {
    var _formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options);
    difference = getObjectsDifference(a, b, _formatOptions, options);
    if (difference !== noDiffMessage && !hasThrown) {
      difference = "".concat(getCommonMessage(SIMILAR_MESSAGE, options), "\n\n").concat(difference);
    }
  }
  return difference;
}
function getFormatOptions(formatOptions, options) {
  var _normalizeDiffOptions3 = normalizeDiffOptions(options),
    compareKeys = _normalizeDiffOptions3.compareKeys,
    printBasicPrototype = _normalizeDiffOptions3.printBasicPrototype,
    maxDepth = _normalizeDiffOptions3.maxDepth;
  return _objectSpread$6(_objectSpread$6({}, formatOptions), {}, {
    compareKeys: compareKeys,
    printBasicPrototype: printBasicPrototype,
    maxDepth: maxDepth !== null && maxDepth !== void 0 ? maxDepth : formatOptions.maxDepth
  });
}
function getObjectsDifference(a, b, formatOptions, options) {
  var formatOptionsZeroIndent = _objectSpread$6(_objectSpread$6({}, formatOptions), {}, {
    indent: 0
  });
  var aCompare = format$1(a, formatOptionsZeroIndent);
  var bCompare = format$1(b, formatOptionsZeroIndent);
  if (aCompare === bCompare) {
    return getCommonMessage(NO_DIFF_MESSAGE, options);
  } else {
    var aDisplay = format$1(a, formatOptions);
    var bDisplay = format$1(b, formatOptions);
    return diffLinesUnified2(aDisplay.split("\n"), bDisplay.split("\n"), aCompare.split("\n"), bCompare.split("\n"), options);
  }
}
var MAX_DIFF_STRING_LENGTH = 2e4;
function isAsymmetricMatcher(data) {
  var type = getType$1(data);
  return type === "Object" && typeof data.asymmetricMatch === "function";
}
function isReplaceable(obj1, obj2) {
  var obj1Type = getType$1(obj1);
  var obj2Type = getType$1(obj2);
  return obj1Type === obj2Type && (obj1Type === "Object" || obj1Type === "Array");
}
function printDiffOrStringify(received, expected, options) {
  var _normalizeDiffOptions4 = normalizeDiffOptions(options),
    aAnnotation = _normalizeDiffOptions4.aAnnotation,
    bAnnotation = _normalizeDiffOptions4.bAnnotation;
  if (typeof expected === "string" && typeof received === "string" && expected.length > 0 && received.length > 0 && expected.length <= MAX_DIFF_STRING_LENGTH && received.length <= MAX_DIFF_STRING_LENGTH && expected !== received) {
    if (expected.includes("\n") || received.includes("\n")) {
      return diffStringsUnified(expected, received, options);
    }
    var _diffStringsRaw3 = diffStringsRaw(expected, received, true),
      _diffStringsRaw4 = _slicedToArray(_diffStringsRaw3, 1),
      diffs = _diffStringsRaw4[0];
    var _hasCommonDiff = diffs.some(function (diff) {
      return diff[0] === DIFF_EQUAL;
    });
    var printLabel = getLabelPrinter(aAnnotation, bAnnotation);
    var expectedLine = printLabel(aAnnotation) + printExpected$1(getCommonAndChangedSubstrings(diffs, DIFF_DELETE, _hasCommonDiff));
    var receivedLine = printLabel(bAnnotation) + printReceived$1(getCommonAndChangedSubstrings(diffs, DIFF_INSERT, _hasCommonDiff));
    return "".concat(expectedLine, "\n").concat(receivedLine);
  }
  // if (isLineDiffable(expected, received)) {
  var clonedExpected = deepClone(expected, {
    forceWritable: true
  });
  var clonedReceived = deepClone(received, {
    forceWritable: true
  });
  var _replaceAsymmetricMat = replaceAsymmetricMatcher(clonedReceived, clonedExpected),
    replacedExpected = _replaceAsymmetricMat.replacedExpected,
    replacedActual = _replaceAsymmetricMat.replacedActual;
  var difference = diff(replacedExpected, replacedActual, options);
  return difference;
  // }
  // const printLabel = getLabelPrinter(aAnnotation, bAnnotation)
  // const expectedLine = printLabel(aAnnotation) + printExpected(expected)
  // const receivedLine
  //   = printLabel(bAnnotation)
  //   + (stringify(expected) === stringify(received)
  //     ? 'serializes to the same string'
  //     : printReceived(received))
  // return `${expectedLine}\n${receivedLine}`
}
function replaceAsymmetricMatcher(actual, expected) {
  var actualReplaced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new WeakSet();
  var expectedReplaced = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new WeakSet();
  // handle asymmetric Error.cause diff
  if (actual instanceof Error && expected instanceof Error && typeof actual.cause !== "undefined" && typeof expected.cause === "undefined") {
    delete actual.cause;
    return {
      replacedActual: actual,
      replacedExpected: expected
    };
  }
  if (!isReplaceable(actual, expected)) {
    return {
      replacedActual: actual,
      replacedExpected: expected
    };
  }
  if (actualReplaced.has(actual) || expectedReplaced.has(expected)) {
    return {
      replacedActual: actual,
      replacedExpected: expected
    };
  }
  actualReplaced.add(actual);
  expectedReplaced.add(expected);
  getOwnProperties(expected).forEach(function (key) {
    var expectedValue = expected[key];
    var actualValue = actual[key];
    if (isAsymmetricMatcher(expectedValue)) {
      if (expectedValue.asymmetricMatch(actualValue)) {
        actual[key] = expectedValue;
      }
    } else if (isAsymmetricMatcher(actualValue)) {
      if (actualValue.asymmetricMatch(expectedValue)) {
        expected[key] = actualValue;
      }
    } else if (isReplaceable(actualValue, expectedValue)) {
      var replaced = replaceAsymmetricMatcher(actualValue, expectedValue, actualReplaced, expectedReplaced);
      actual[key] = replaced.replacedActual;
      expected[key] = replaced.replacedExpected;
    }
  });
  return {
    replacedActual: actual,
    replacedExpected: expected
  };
}
function getLabelPrinter() {
  for (var _len = arguments.length, strings = new Array(_len), _key = 0; _key < _len; _key++) {
    strings[_key] = arguments[_key];
  }
  var maxLength = strings.reduce(function (max, string) {
    return string.length > max ? string.length : max;
  }, 0);
  return function (string) {
    return "".concat(string, ": ").concat(" ".repeat(maxLength - string.length));
  };
}
var SPACE_SYMBOL$1 = "·";
function replaceTrailingSpaces$1(text) {
  return text.replace(/\s+$/gm, function (spaces) {
    return SPACE_SYMBOL$1.repeat(spaces.length);
  });
}
function printReceived$1(object) {
  return s.red(replaceTrailingSpaces$1(stringify(object)));
}
function printExpected$1(value) {
  return s.green(replaceTrailingSpaces$1(stringify(value)));
}
function getCommonAndChangedSubstrings(diffs, op, hasCommonDiff) {
  return diffs.reduce(function (reduced, diff) {
    return reduced + (diff[0] === DIFF_EQUAL ? diff[1] : diff[0] === op ? hasCommonDiff ? s.inverse(diff[1]) : diff[1] : "");
  }, "");
}

var _excluded = ["value"];
function _createForOfIteratorHelper$6(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$6(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray$6(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray$6(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$6(r, a) : void 0; } }
function _arrayLikeToArray$6(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
// src/utils.ts
function S(e, t) {
  if (!e) throw new Error(t);
}
function f$1(e, t) {
  return _typeof(t) === e;
}
function w(e) {
  return e instanceof Promise;
}
function u(e, t, r) {
  Object.defineProperty(e, t, r);
}
function l(e, t, r) {
  u(e, t, {
    value: r,
    configurable: !0,
    writable: !0
  });
}

// src/constants.ts
var y = Symbol.for("tinyspy:spy");

// src/internal.ts
var x = /* @__PURE__ */new Set(),
  h$1 = function h(e) {
    e.called = !1, e.callCount = 0, e.calls = [], e.results = [], e.resolves = [], e.next = [];
  },
  k = function k(e) {
    return u(e, y, {
      value: {
        reset: function reset() {
          return h$1(e[y]);
        }
      }
    }), e[y];
  },
  T = function T(e) {
    return e[y] || k(e);
  };
function R(e) {
  S(f$1("function", e) || f$1("undefined", e), "cannot spy on a non-function value");
  var t = function _target() {
    var n = T(t);
    for (var _len = arguments.length, s = new Array(_len), _key = 0; _key < _len; _key++) {
      s[_key] = arguments[_key];
    }
    n.called = !0, n.callCount++, n.calls.push(s);
    var d = n.next.shift();
    if (d) {
      n.results.push(d);
      var _d = _slicedToArray(d, 2),
        a = _d[0],
        i = _d[1];
      if (a === "ok") return i;
      throw i;
    }
    var o,
      c = "ok",
      p = n.results.length;
    if (n.impl) try {
      (this instanceof _target ? this.constructor : void 0) ? o = Reflect.construct(n.impl, s, this instanceof _target ? this.constructor : void 0) : o = n.impl.apply(this, s), c = "ok";
    } catch (a) {
      throw o = a, c = "error", n.results.push([c, a]), a;
    }
    var g = [c, o];
    return w(o) && o.then(function (a) {
      return n.resolves[p] = ["ok", a];
    }, function (a) {
      return n.resolves[p] = ["error", a];
    }), n.results.push(g), o;
  };
  l(t, "_isMockFunction", !0), l(t, "length", e ? e.length : 0), l(t, "name", e && e.name || "spy");
  var r = T(t);
  return r.reset(), r.impl = e, t;
}
function v(e) {
  return !!e && e._isMockFunction === !0;
}

// src/spyOn.ts
var b = function b(e, t) {
    var r = Object.getOwnPropertyDescriptor(e, t);
    if (r) return [e, r];
    var s = Object.getPrototypeOf(e);
    for (; s !== null;) {
      var n = Object.getOwnPropertyDescriptor(s, t);
      if (n) return [s, n];
      s = Object.getPrototypeOf(s);
    }
  },
  P = function P(e, t) {
    t != null && typeof t == "function" && t.prototype != null && Object.setPrototypeOf(e.prototype, t.prototype);
  };
function M(e, t, r) {
  S(!f$1("undefined", e), "spyOn could not find an object to spy upon"), S(f$1("object", e) || f$1("function", e), "cannot spyOn on a primitive value");
  var _ref3 = function () {
      if (!f$1("object", t)) return [t, "value"];
      if ("getter" in t && "setter" in t) throw new Error("cannot spy on both getter and setter");
      if ("getter" in t) return [t.getter, "get"];
      if ("setter" in t) return [t.setter, "set"];
      throw new Error("specify getter or setter to spy on");
    }(),
    _ref4 = _slicedToArray(_ref3, 2),
    s = _ref4[0],
    n = _ref4[1],
    _ref5 = b(e, s) || [],
    _ref6 = _slicedToArray(_ref5, 2),
    d = _ref6[0],
    o = _ref6[1];
  S(o || s in e, "".concat(String(s), " does not exist"));
  var c = !1;
  n === "value" && o && !o.value && o.get && (n = "get", c = !0, r = o.get());
  var p;
  o ? p = o[n] : n !== "value" ? p = function p() {
    return e[s];
  } : p = e[s], p && j(p) && (p = p[y].getOriginal());
  var g = function g(I) {
      var _ref7 = o || {
          configurable: !0,
          writable: !0
        };
        _ref7.value;
        var O = _objectWithoutProperties(_ref7, _excluded);
      n !== "value" && delete O.writable, O[n] = I, u(e, s, O);
    },
    a = function a() {
      d !== e ? Reflect.deleteProperty(e, s) : o && !p ? u(e, s, o) : g(p);
    };
  r || (r = p);
  var i = E(R(r), r);
  n === "value" && P(i, p);
  var m = i[y];
  return l(m, "restore", a), l(m, "getOriginal", function () {
    return c ? p() : p;
  }), l(m, "willCall", function (I) {
    return m.impl = I, i;
  }), g(c ? function () {
    return P(i, r), i;
  } : i), x.add(i), i;
}
var K = /* @__PURE__ */new Set(["length", "name", "prototype"]);
function D(e) {
  var t = /* @__PURE__ */new Set(),
    r = {};
  for (; e && e !== Object.prototype && e !== Function.prototype;) {
    var s = [].concat(_toConsumableArray(Object.getOwnPropertyNames(e)), _toConsumableArray(Object.getOwnPropertySymbols(e)));
    var _iterator = _createForOfIteratorHelper$6(s),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var n = _step.value;
        r[n] || K.has(n) || (t.add(n), r[n] = Object.getOwnPropertyDescriptor(e, n));
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    e = Object.getPrototypeOf(e);
  }
  return {
    properties: t,
    descriptors: r
  };
}
function E(e, t) {
  if (!t ||
  // the original is already a spy, so it has all the properties
  y in t) return e;
  var _D = D(t),
    r = _D.properties,
    s = _D.descriptors;
  var _iterator2 = _createForOfIteratorHelper$6(r),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var n = _step2.value;
      var d = s[n];
      b(e, n) || u(e, n, d);
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return e;
}
function j(e) {
  return v(e) && "getOriginal" in e[y];
}

var mocks = new Set();
function isMockFunction(fn) {
  return typeof fn === "function" && "_isMockFunction" in fn && fn._isMockFunction;
}
function spyOn(obj, method, accessType) {
  var dictionary = {
    get: "getter",
    set: "setter"
  };
  var objMethod = accessType ? _defineProperty({}, dictionary[accessType], method) : method;
  var state;
  var descriptor = getDescriptor(obj, method);
  var fn = descriptor && descriptor[accessType || "value"];
  // inherit implementations if it was already mocked
  if (isMockFunction(fn)) {
    state = fn.mock._state();
  }
  try {
    var stub = M(obj, objMethod);
    var spy = enhanceSpy(stub);
    if (state) {
      spy.mock._state(state);
    }
    return spy;
  } catch (error) {
    if (error instanceof TypeError && Symbol.toStringTag && obj[Symbol.toStringTag] === "Module" && (error.message.includes("Cannot redefine property") || error.message.includes("Cannot replace module namespace") || error.message.includes("can't redefine non-configurable property"))) {
      throw new TypeError("Cannot spy on export \"".concat(String(objMethod), "\". Module namespace is not configurable in ESM. See: https://vitest.dev/guide/browser/#limitations"), {
        cause: error
      });
    }
    throw error;
  }
}
var callOrder = 0;
function enhanceSpy(spy) {
  var stub = spy;
  var implementation;
  var onceImplementations = [];
  var implementationChangedTemporarily = false;
  var instances = [];
  var contexts = [];
  var invocations = [];
  var state = T(spy);
  var mockContext = {
    get calls() {
      return state.calls;
    },
    get contexts() {
      return contexts;
    },
    get instances() {
      return instances;
    },
    get invocationCallOrder() {
      return invocations;
    },
    get results() {
      return state.results.map(function (_ref2) {
        var _ref3 = _slicedToArray(_ref2, 2),
          callType = _ref3[0],
          value = _ref3[1];
        var type = callType === "error" ? "throw" : "return";
        return {
          type: type,
          value: value
        };
      });
    },
    get settledResults() {
      return state.resolves.map(function (_ref4) {
        var _ref5 = _slicedToArray(_ref4, 2),
          callType = _ref5[0],
          value = _ref5[1];
        var type = callType === "error" ? "rejected" : "fulfilled";
        return {
          type: type,
          value: value
        };
      });
    },
    get lastCall() {
      return state.calls[state.calls.length - 1];
    },
    _state: function _state(state) {
      if (state) {
        implementation = state.implementation;
        onceImplementations = state.onceImplementations;
        implementationChangedTemporarily = state.implementationChangedTemporarily;
      }
      return {
        implementation: implementation,
        onceImplementations: onceImplementations,
        implementationChangedTemporarily: implementationChangedTemporarily
      };
    }
  };
  function mockCall() {
    instances.push(this);
    contexts.push(this);
    invocations.push(++callOrder);
    var impl = implementationChangedTemporarily ? implementation : onceImplementations.shift() || implementation || state.getOriginal() || function () {};
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return impl.apply(this, args);
  }
  var name = stub.name;
  stub.getMockName = function () {
    return name || "vi.fn()";
  };
  stub.mockName = function (n) {
    name = n;
    return stub;
  };
  stub.mockClear = function () {
    state.reset();
    instances = [];
    contexts = [];
    invocations = [];
    return stub;
  };
  stub.mockReset = function () {
    stub.mockClear();
    implementation = undefined;
    onceImplementations = [];
    return stub;
  };
  stub.mockRestore = function () {
    stub.mockReset();
    state.restore();
    return stub;
  };
  if (Symbol.dispose) {
    stub[Symbol.dispose] = function () {
      return stub.mockRestore();
    };
  }
  stub.getMockImplementation = function () {
    return implementationChangedTemporarily ? implementation : onceImplementations.at(0) || implementation;
  };
  stub.mockImplementation = function (fn) {
    implementation = fn;
    state.willCall(mockCall);
    return stub;
  };
  stub.mockImplementationOnce = function (fn) {
    onceImplementations.push(fn);
    return stub;
  };
  function withImplementation(fn, cb) {
    var originalImplementation = implementation;
    implementation = fn;
    state.willCall(mockCall);
    implementationChangedTemporarily = true;
    var reset = function reset() {
      implementation = originalImplementation;
      implementationChangedTemporarily = false;
    };
    var result = cb();
    if (_typeof(result) === "object" && result && typeof result.then === "function") {
      return result.then(function () {
        reset();
        return stub;
      });
    }
    reset();
    return stub;
  }
  stub.withImplementation = withImplementation;
  stub.mockReturnThis = function () {
    return stub.mockImplementation(function () {
      return this;
    });
  };
  stub.mockReturnValue = function (val) {
    return stub.mockImplementation(function () {
      return val;
    });
  };
  stub.mockReturnValueOnce = function (val) {
    return stub.mockImplementationOnce(function () {
      return val;
    });
  };
  stub.mockResolvedValue = function (val) {
    return stub.mockImplementation(function () {
      return Promise.resolve(val);
    });
  };
  stub.mockResolvedValueOnce = function (val) {
    return stub.mockImplementationOnce(function () {
      return Promise.resolve(val);
    });
  };
  stub.mockRejectedValue = function (val) {
    return stub.mockImplementation(function () {
      return Promise.reject(val);
    });
  };
  stub.mockRejectedValueOnce = function (val) {
    return stub.mockImplementationOnce(function () {
      return Promise.reject(val);
    });
  };
  Object.defineProperty(stub, "mock", {
    get: function get() {
      return mockContext;
    }
  });
  state.willCall(mockCall);
  mocks.add(stub);
  return stub;
}
function fn(implementation) {
  var enhancedSpy = enhanceSpy(M({
    spy: implementation || function () {}
  }, "spy"));
  if (implementation) {
    enhancedSpy.mockImplementation(implementation);
  }
  return enhancedSpy;
}
function getDescriptor(obj, method) {
  var objDescriptor = Object.getOwnPropertyDescriptor(obj, method);
  if (objDescriptor) {
    return objDescriptor;
  }
  var currentProto = Object.getPrototypeOf(obj);
  while (currentProto !== null) {
    var descriptor = Object.getOwnPropertyDescriptor(currentProto, method);
    if (descriptor) {
      return descriptor;
    }
    currentProto = Object.getPrototypeOf(currentProto);
  }
}

function ownKeys$5(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$5(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$5(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var IS_RECORD_SYMBOL$1 = "@@__IMMUTABLE_RECORD__@@";
var IS_COLLECTION_SYMBOL = "@@__IMMUTABLE_ITERABLE__@@";
function isImmutable(v) {
  return v && (v[IS_COLLECTION_SYMBOL] || v[IS_RECORD_SYMBOL$1]);
}
var OBJECT_PROTO = Object.getPrototypeOf({});
function getUnserializableMessage(err) {
  if (err instanceof Error) {
    return "<unserializable>: ".concat(err.message);
  }
  if (typeof err === "string") {
    return "<unserializable>: ".concat(err);
  }
  return "<unserializable>";
}
// https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm
function serializeValue(val) {
  var seen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new WeakMap();
  if (!val || typeof val === "string") {
    return val;
  }
  if (val instanceof Error && "toJSON" in val && typeof val.toJSON === "function") {
    var jsonValue = val.toJSON();
    if (jsonValue && jsonValue !== val && _typeof(jsonValue) === "object") {
      if (typeof val.message === "string") {
        safe(function () {
          var _jsonValue$message;
          return (_jsonValue$message = jsonValue.message) !== null && _jsonValue$message !== void 0 ? _jsonValue$message : jsonValue.message = val.message;
        });
      }
      if (typeof val.stack === "string") {
        safe(function () {
          var _jsonValue$stack;
          return (_jsonValue$stack = jsonValue.stack) !== null && _jsonValue$stack !== void 0 ? _jsonValue$stack : jsonValue.stack = val.stack;
        });
      }
      if (typeof val.name === "string") {
        safe(function () {
          var _jsonValue$name;
          return (_jsonValue$name = jsonValue.name) !== null && _jsonValue$name !== void 0 ? _jsonValue$name : jsonValue.name = val.name;
        });
      }
      if (val.cause != null) {
        safe(function () {
          var _jsonValue$cause;
          return (_jsonValue$cause = jsonValue.cause) !== null && _jsonValue$cause !== void 0 ? _jsonValue$cause : jsonValue.cause = serializeValue(val.cause, seen);
        });
      }
    }
    return serializeValue(jsonValue, seen);
  }
  if (typeof val === "function") {
    return "Function<".concat(val.name || "anonymous", ">");
  }
  if (_typeof(val) === "symbol") {
    return val.toString();
  }
  if (_typeof(val) !== "object") {
    return val;
  }
  if (typeof Buffer !== "undefined" && val instanceof Buffer) {
    return "<Buffer(".concat(val.length, ") ...>");
  }
  if (typeof Uint8Array !== "undefined" && val instanceof Uint8Array) {
    return "<Uint8Array(".concat(val.length, ") ...>");
  }
  // cannot serialize immutables as immutables
  if (isImmutable(val)) {
    return serializeValue(val.toJSON(), seen);
  }
  if (val instanceof Promise || val.constructor && val.constructor.prototype === "AsyncFunction") {
    return "Promise";
  }
  if (typeof Element !== "undefined" && val instanceof Element) {
    return val.tagName;
  }
  if (typeof val.asymmetricMatch === "function") {
    return "".concat(val.toString(), " ").concat(format(val.sample));
  }
  if (typeof val.toJSON === "function") {
    return serializeValue(val.toJSON(), seen);
  }
  if (seen.has(val)) {
    return seen.get(val);
  }
  if (Array.isArray(val)) {
    // eslint-disable-next-line unicorn/no-new-array -- we need to keep sparse arrays ([1,,3])
    var clone = new Array(val.length);
    seen.set(val, clone);
    val.forEach(function (e, i) {
      try {
        clone[i] = serializeValue(e, seen);
      } catch (err) {
        clone[i] = getUnserializableMessage(err);
      }
    });
    return clone;
  } else {
    // Objects with `Error` constructors appear to cause problems during worker communication
    // using `MessagePort`, so the serialized error object is being recreated as plain object.
    var _clone = Object.create(null);
    seen.set(val, _clone);
    var obj = val;
    while (obj && obj !== OBJECT_PROTO) {
      Object.getOwnPropertyNames(obj).forEach(function (key) {
        if (key in _clone) {
          return;
        }
        try {
          _clone[key] = serializeValue(val[key], seen);
        } catch (err) {
          // delete in case it has a setter from prototype that might throw
          delete _clone[key];
          _clone[key] = getUnserializableMessage(err);
        }
      });
      obj = Object.getPrototypeOf(obj);
    }
    return _clone;
  }
}
function safe(fn) {
  try {
    return fn();
  } catch (_unused) {}
}
function normalizeErrorMessage(message) {
  return message.replace(/__(vite_ssr_import|vi_import)_\d+__\./g, "");
}
function processError(_err, diffOptions) {
  var seen = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new WeakSet();
  if (!_err || _typeof(_err) !== "object") {
    return {
      message: String(_err)
    };
  }
  var err = _err;
  if (err.showDiff || err.showDiff === undefined && err.expected !== undefined && err.actual !== undefined) {
    err.diff = printDiffOrStringify(err.actual, err.expected, _objectSpread$5(_objectSpread$5({}, diffOptions), err.diffOptions));
  }
  if ("expected" in err && typeof err.expected !== "string") {
    err.expected = stringify(err.expected, 10);
  }
  if ("actual" in err && typeof err.actual !== "string") {
    err.actual = stringify(err.actual, 10);
  }
  // some Error implementations don't allow rewriting message
  try {
    if (typeof err.message === "string") {
      err.message = normalizeErrorMessage(err.message);
    }
  } catch (_unused2) {}
  // some Error implementations may not allow rewriting cause
  // in most cases, the assignment will lead to "err.cause = err.cause"
  try {
    if (!seen.has(err) && _typeof(err.cause) === "object") {
      seen.add(err);
      err.cause = processError(err.cause, diffOptions, seen);
    }
  } catch (_unused3) {}
  try {
    return serializeValue(err);
  } catch (e) {
    return serializeValue(new Error("Failed to fully serialize error: ".concat(e === null || e === void 0 ? void 0 : e.message, "\nInner error message: ").concat(err === null || err === void 0 ? void 0 : err.message)));
  }
}

var _AssertionError2, _Assertion2;
function ownKeys$4(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$4(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$4(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _callSuper$5(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$5() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$5() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$5 = function _isNativeReflectConstruct() { return !!t; })(); }
var __defProp = Object.defineProperty;
var __name = function __name(target, value) {
  return __defProp(target, "name", {
    value: value,
    configurable: true
  });
};
var __export = function __export(target, all) {
  for (var name in all) __defProp(target, name, {
    get: all[name],
    enumerable: true
  });
};

// lib/chai/utils/index.js
var utils_exports = {};
__export(utils_exports, {
  addChainableMethod: function addChainableMethod() {
    return _addChainableMethod;
  },
  addLengthGuard: function addLengthGuard() {
    return _addLengthGuard;
  },
  addMethod: function addMethod() {
    return _addMethod;
  },
  addProperty: function addProperty() {
    return _addProperty;
  },
  checkError: function checkError() {
    return check_error_exports;
  },
  compareByInspect: function compareByInspect() {
    return _compareByInspect;
  },
  eql: function eql() {
    return deep_eql_default;
  },
  expectTypes: function expectTypes() {
    return _expectTypes;
  },
  flag: function flag() {
    return _flag;
  },
  getActual: function getActual() {
    return _getActual;
  },
  getMessage: function getMessage() {
    return getMessage2;
  },
  getName: function getName() {
    return _getName;
  },
  getOperator: function getOperator() {
    return _getOperator;
  },
  getOwnEnumerableProperties: function getOwnEnumerableProperties() {
    return _getOwnEnumerableProperties;
  },
  getOwnEnumerablePropertySymbols: function getOwnEnumerablePropertySymbols() {
    return _getOwnEnumerablePropertySymbols;
  },
  getPathInfo: function getPathInfo() {
    return _getPathInfo;
  },
  hasProperty: function hasProperty() {
    return _hasProperty;
  },
  inspect: function inspect() {
    return inspect2;
  },
  isNaN: function isNaN() {
    return isNaN2;
  },
  isNumeric: function isNumeric() {
    return _isNumeric;
  },
  isProxyEnabled: function isProxyEnabled() {
    return _isProxyEnabled;
  },
  isRegExp: function isRegExp() {
    return isRegExp2;
  },
  objDisplay: function objDisplay() {
    return _objDisplay;
  },
  overwriteChainableMethod: function overwriteChainableMethod() {
    return _overwriteChainableMethod;
  },
  overwriteMethod: function overwriteMethod() {
    return _overwriteMethod;
  },
  overwriteProperty: function overwriteProperty() {
    return _overwriteProperty;
  },
  proxify: function proxify() {
    return _proxify;
  },
  test: function test() {
    return _test$1;
  },
  transferFlags: function transferFlags() {
    return _transferFlags;
  },
  type: function type() {
    return _type;
  }
});

// node_modules/check-error/index.js
var check_error_exports = {};
__export(check_error_exports, {
  compatibleConstructor: function compatibleConstructor() {
    return _compatibleConstructor;
  },
  compatibleInstance: function compatibleInstance() {
    return _compatibleInstance;
  },
  compatibleMessage: function compatibleMessage() {
    return _compatibleMessage;
  },
  getConstructorName: function getConstructorName() {
    return _getConstructorName;
  },
  getMessage: function getMessage() {
    return _getMessage;
  }
});
function isErrorInstance(obj) {
  return obj instanceof Error || Object.prototype.toString.call(obj) === "[object Error]";
}
__name(isErrorInstance, "isErrorInstance");
function isRegExp(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
}
__name(isRegExp, "isRegExp");
function _compatibleInstance(thrown, errorLike) {
  return isErrorInstance(errorLike) && thrown === errorLike;
}
__name(_compatibleInstance, "compatibleInstance");
function _compatibleConstructor(thrown, errorLike) {
  if (isErrorInstance(errorLike)) {
    return thrown.constructor === errorLike.constructor || thrown instanceof errorLike.constructor;
  } else if ((_typeof(errorLike) === "object" || typeof errorLike === "function") && errorLike.prototype) {
    return thrown.constructor === errorLike || thrown instanceof errorLike;
  }
  return false;
}
__name(_compatibleConstructor, "compatibleConstructor");
function _compatibleMessage(thrown, errMatcher) {
  var comparisonString = typeof thrown === "string" ? thrown : thrown.message;
  if (isRegExp(errMatcher)) {
    return errMatcher.test(comparisonString);
  } else if (typeof errMatcher === "string") {
    return comparisonString.indexOf(errMatcher) !== -1;
  }
  return false;
}
__name(_compatibleMessage, "compatibleMessage");
function _getConstructorName(errorLike) {
  var constructorName = errorLike;
  if (isErrorInstance(errorLike)) {
    constructorName = errorLike.constructor.name;
  } else if (typeof errorLike === "function") {
    constructorName = errorLike.name;
    if (constructorName === "") {
      var newConstructorName = new errorLike().name;
      constructorName = newConstructorName || constructorName;
    }
  }
  return constructorName;
}
__name(_getConstructorName, "getConstructorName");
function _getMessage(errorLike) {
  var msg = "";
  if (errorLike && errorLike.message) {
    msg = errorLike.message;
  } else if (typeof errorLike === "string") {
    msg = errorLike;
  }
  return msg;
}
__name(_getMessage, "getMessage");

// lib/chai/utils/flag.js
function _flag(obj, key, value) {
  var flags = obj.__flags || (obj.__flags = /* @__PURE__ */Object.create(null));
  if (arguments.length === 3) {
    flags[key] = value;
  } else {
    return flags[key];
  }
}
__name(_flag, "flag");

// lib/chai/utils/test.js
function _test$1(obj, args) {
  var negate = _flag(obj, "negate"),
    expr = args[0];
  return negate ? !expr : expr;
}
__name(_test$1, "test");

// lib/chai/utils/type-detect.js
function _type(obj) {
  if (typeof obj === "undefined") {
    return "undefined";
  }
  if (obj === null) {
    return "null";
  }
  var stringTag = obj[Symbol.toStringTag];
  if (typeof stringTag === "string") {
    return stringTag;
  }
  var type3 = Object.prototype.toString.call(obj).slice(8, -1);
  return type3;
}
__name(_type, "type");

// node_modules/assertion-error/index.js
var canElideFrames = "captureStackTrace" in Error;
var AssertionError = (_AssertionError2 = /*#__PURE__*/function (_Error) {
  function _AssertionError() {
    var _this;
    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "Unspecified AssertionError";
    var props = arguments.length > 1 ? arguments[1] : undefined;
    var ssf = arguments.length > 2 ? arguments[2] : undefined;
    _classCallCheck(this, _AssertionError);
    _this = _callSuper$5(this, _AssertionError, [message]);
    _defineProperty(_this, "message", void 0);
    _this.message = message;
    if (canElideFrames) {
      Error.captureStackTrace(_this, ssf || _AssertionError);
    }
    for (var key in props) {
      if (!(key in _this)) {
        _this[key] = props[key];
      }
    }
    return _this;
  }
  _inherits(_AssertionError, _Error);
  return _createClass(_AssertionError, [{
    key: "name",
    get: function get() {
      return "AssertionError";
    }
  }, {
    key: "ok",
    get: function get() {
      return false;
    }
  }, {
    key: "toJSON",
    value: function toJSON(stack) {
      return _objectSpread$4(_objectSpread$4({}, this), {}, {
        name: this.name,
        message: this.message,
        ok: false,
        stack: stack !== false ? this.stack : void 0
      });
    }
  }]);
}(/*#__PURE__*/_wrapNativeSuper(Error)), __name(_AssertionError2, "AssertionError"), _AssertionError2);

// lib/chai/utils/expectTypes.js
function _expectTypes(obj, types) {
  var flagMsg = _flag(obj, "message");
  var ssfi = _flag(obj, "ssfi");
  flagMsg = flagMsg ? flagMsg + ": " : "";
  obj = _flag(obj, "object");
  types = types.map(function (t) {
    return t.toLowerCase();
  });
  types.sort();
  var str = types.map(function (t, index) {
    var art = ~["a", "e", "i", "o", "u"].indexOf(t.charAt(0)) ? "an" : "a";
    var or = types.length > 1 && index === types.length - 1 ? "or " : "";
    return or + art + " " + t;
  }).join(", ");
  var objType = _type(obj).toLowerCase();
  if (!types.some(function (expected) {
    return objType === expected;
  })) {
    throw new AssertionError(flagMsg + "object tested must be " + str + ", but " + objType + " given", void 0, ssfi);
  }
}
__name(_expectTypes, "expectTypes");

// lib/chai/utils/getActual.js
function _getActual(obj, args) {
  return args.length > 4 ? args[4] : obj._obj;
}
__name(_getActual, "getActual");

// node_modules/loupe/lib/helpers.js
var ansiColors = {
  bold: ["1", "22"],
  dim: ["2", "22"],
  italic: ["3", "23"],
  underline: ["4", "24"],
  // 5 & 6 are blinking
  inverse: ["7", "27"],
  hidden: ["8", "28"],
  strike: ["9", "29"],
  // 10-20 are fonts
  // 21-29 are resets for 1-9
  black: ["30", "39"],
  red: ["31", "39"],
  green: ["32", "39"],
  yellow: ["33", "39"],
  blue: ["34", "39"],
  magenta: ["35", "39"],
  cyan: ["36", "39"],
  white: ["37", "39"],
  brightblack: ["30;1", "39"],
  brightred: ["31;1", "39"],
  brightgreen: ["32;1", "39"],
  brightyellow: ["33;1", "39"],
  brightblue: ["34;1", "39"],
  brightmagenta: ["35;1", "39"],
  brightcyan: ["36;1", "39"],
  brightwhite: ["37;1", "39"],
  grey: ["90", "39"]
};
var styles = {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red"
};
var truncator = "\u2026";
function colorise(value, styleType) {
  var color = ansiColors[styles[styleType]] || ansiColors[styleType] || "";
  if (!color) {
    return String(value);
  }
  return "\x1B[".concat(color[0], "m").concat(String(value), "\x1B[").concat(color[1], "m");
}
__name(colorise, "colorise");
function normaliseOptions() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    _ref$showHidden = _ref.showHidden,
    showHidden = _ref$showHidden === void 0 ? false : _ref$showHidden,
    _ref$depth = _ref.depth,
    depth = _ref$depth === void 0 ? 2 : _ref$depth,
    _ref$colors = _ref.colors,
    colors = _ref$colors === void 0 ? false : _ref$colors,
    _ref$customInspect = _ref.customInspect,
    customInspect = _ref$customInspect === void 0 ? true : _ref$customInspect,
    _ref$showProxy = _ref.showProxy,
    showProxy = _ref$showProxy === void 0 ? false : _ref$showProxy,
    _ref$maxArrayLength = _ref.maxArrayLength,
    maxArrayLength = _ref$maxArrayLength === void 0 ? Infinity : _ref$maxArrayLength,
    _ref$breakLength = _ref.breakLength,
    breakLength = _ref$breakLength === void 0 ? Infinity : _ref$breakLength,
    _ref$seen = _ref.seen,
    seen = _ref$seen === void 0 ? [] : _ref$seen,
    _ref$truncate = _ref.truncate,
    truncate2 = _ref$truncate === void 0 ? Infinity : _ref$truncate,
    _ref$stylize = _ref.stylize,
    stylize = _ref$stylize === void 0 ? String : _ref$stylize;
  var inspect3 = arguments.length > 1 ? arguments[1] : undefined;
  var options = {
    showHidden: Boolean(showHidden),
    depth: Number(depth),
    colors: Boolean(colors),
    customInspect: Boolean(customInspect),
    showProxy: Boolean(showProxy),
    maxArrayLength: Number(maxArrayLength),
    breakLength: Number(breakLength),
    truncate: Number(truncate2),
    seen: seen,
    inspect: inspect3,
    stylize: stylize
  };
  if (options.colors) {
    options.stylize = colorise;
  }
  return options;
}
__name(normaliseOptions, "normaliseOptions");
function isHighSurrogate(char) {
  return char >= "\uD800" && char <= "\uDBFF";
}
__name(isHighSurrogate, "isHighSurrogate");
function truncate(string, length) {
  var tail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : truncator;
  string = String(string);
  var tailLength = tail.length;
  var stringLength = string.length;
  if (tailLength > length && stringLength > tailLength) {
    return tail;
  }
  if (stringLength > length && stringLength > tailLength) {
    var end = length - tailLength;
    if (end > 0 && isHighSurrogate(string[end - 1])) {
      end = end - 1;
    }
    return "".concat(string.slice(0, end)).concat(tail);
  }
  return string;
}
__name(truncate, "truncate");
function inspectList(list, options, inspectItem) {
  var separator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ", ";
  inspectItem = inspectItem || options.inspect;
  var size = list.length;
  if (size === 0) return "";
  var originalLength = options.truncate;
  var output = "";
  var peek = "";
  var truncated = "";
  for (var i = 0; i < size; i += 1) {
    var last = i + 1 === list.length;
    var secondToLast = i + 2 === list.length;
    truncated = "".concat(truncator, "(").concat(list.length - i, ")");
    var value = list[i];
    options.truncate = originalLength - output.length - (last ? 0 : separator.length);
    var string = peek || inspectItem(value, options) + (last ? "" : separator);
    var nextLength = output.length + string.length;
    var truncatedLength = nextLength + truncated.length;
    if (last && nextLength > originalLength && output.length + truncated.length <= originalLength) {
      break;
    }
    if (!last && !secondToLast && truncatedLength > originalLength) {
      break;
    }
    peek = last ? "" : inspectItem(list[i + 1], options) + (secondToLast ? "" : separator);
    if (!last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength) {
      break;
    }
    output += string;
    if (!last && !secondToLast && nextLength + peek.length >= originalLength) {
      truncated = "".concat(truncator, "(").concat(list.length - i - 1, ")");
      break;
    }
    truncated = "";
  }
  return "".concat(output).concat(truncated);
}
__name(inspectList, "inspectList");
function quoteComplexKey(key) {
  if (key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)) {
    return key;
  }
  return JSON.stringify(key).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
__name(quoteComplexKey, "quoteComplexKey");
function inspectProperty(_ref2, options) {
  var _ref3 = _slicedToArray(_ref2, 2),
    key = _ref3[0],
    value = _ref3[1];
  options.truncate -= 2;
  if (typeof key === "string") {
    key = quoteComplexKey(key);
  } else if (typeof key !== "number") {
    key = "[".concat(options.inspect(key, options), "]");
  }
  options.truncate -= key.length;
  value = options.inspect(value, options);
  return "".concat(key, ": ").concat(value);
}
__name(inspectProperty, "inspectProperty");

// node_modules/loupe/lib/array.js
function inspectArray(array, options) {
  var nonIndexProperties = Object.keys(array).slice(array.length);
  if (!array.length && !nonIndexProperties.length) return "[]";
  options.truncate -= 4;
  var listContents = inspectList(array, options);
  options.truncate -= listContents.length;
  var propertyContents = "";
  if (nonIndexProperties.length) {
    propertyContents = inspectList(nonIndexProperties.map(function (key) {
      return [key, array[key]];
    }), options, inspectProperty);
  }
  return "[ ".concat(listContents).concat(propertyContents ? ", ".concat(propertyContents) : "", " ]");
}
__name(inspectArray, "inspectArray");

// node_modules/loupe/lib/typedarray.js
var getArrayName = /* @__PURE__ */__name(function (array) {
  if (typeof Buffer === "function" && array instanceof Buffer) {
    return "Buffer";
  }
  if (array[Symbol.toStringTag]) {
    return array[Symbol.toStringTag];
  }
  return array.constructor.name;
}, "getArrayName");
function inspectTypedArray(array, options) {
  var name = getArrayName(array);
  options.truncate -= name.length + 4;
  var nonIndexProperties = Object.keys(array).slice(array.length);
  if (!array.length && !nonIndexProperties.length) return "".concat(name, "[]");
  var output = "";
  for (var i = 0; i < array.length; i++) {
    var string = "".concat(options.stylize(truncate(array[i], options.truncate), "number")).concat(i === array.length - 1 ? "" : ", ");
    options.truncate -= string.length;
    if (array[i] !== array.length && options.truncate <= 3) {
      output += "".concat(truncator, "(").concat(array.length - array[i] + 1, ")");
      break;
    }
    output += string;
  }
  var propertyContents = "";
  if (nonIndexProperties.length) {
    propertyContents = inspectList(nonIndexProperties.map(function (key) {
      return [key, array[key]];
    }), options, inspectProperty);
  }
  return "".concat(name, "[ ").concat(output).concat(propertyContents ? ", ".concat(propertyContents) : "", " ]");
}
__name(inspectTypedArray, "inspectTypedArray");

// node_modules/loupe/lib/date.js
function inspectDate(dateObject, options) {
  var stringRepresentation = dateObject.toJSON();
  if (stringRepresentation === null) {
    return "Invalid Date";
  }
  var split = stringRepresentation.split("T");
  var date = split[0];
  return options.stylize("".concat(date, "T").concat(truncate(split[1], options.truncate - date.length - 1)), "date");
}
__name(inspectDate, "inspectDate");

// node_modules/loupe/lib/function.js
function inspectFunction(func, options) {
  var functionType = func[Symbol.toStringTag] || "Function";
  var name = func.name;
  if (!name) {
    return options.stylize("[".concat(functionType, "]"), "special");
  }
  return options.stylize("[".concat(functionType, " ").concat(truncate(name, options.truncate - 11), "]"), "special");
}
__name(inspectFunction, "inspectFunction");

// node_modules/loupe/lib/map.js
function inspectMapEntry(_ref4, options) {
  var _ref5 = _slicedToArray(_ref4, 2),
    key = _ref5[0],
    value = _ref5[1];
  options.truncate -= 4;
  key = options.inspect(key, options);
  options.truncate -= key.length;
  value = options.inspect(value, options);
  return "".concat(key, " => ").concat(value);
}
__name(inspectMapEntry, "inspectMapEntry");
function mapToEntries(map) {
  var entries = [];
  map.forEach(function (value, key) {
    entries.push([key, value]);
  });
  return entries;
}
__name(mapToEntries, "mapToEntries");
function inspectMap(map, options) {
  if (map.size === 0) return "Map{}";
  options.truncate -= 7;
  return "Map{ ".concat(inspectList(mapToEntries(map), options, inspectMapEntry), " }");
}
__name(inspectMap, "inspectMap");

// node_modules/loupe/lib/number.js
var isNaN = Number.isNaN || function (i) {
  return i !== i;
};
function inspectNumber(number, options) {
  if (isNaN(number)) {
    return options.stylize("NaN", "number");
  }
  if (number === Infinity) {
    return options.stylize("Infinity", "number");
  }
  if (number === -Infinity) {
    return options.stylize("-Infinity", "number");
  }
  if (number === 0) {
    return options.stylize(1 / number === Infinity ? "+0" : "-0", "number");
  }
  return options.stylize(truncate(String(number), options.truncate), "number");
}
__name(inspectNumber, "inspectNumber");

// node_modules/loupe/lib/bigint.js
function inspectBigInt(number, options) {
  var nums = truncate(number.toString(), options.truncate - 1);
  if (nums !== truncator) nums += "n";
  return options.stylize(nums, "bigint");
}
__name(inspectBigInt, "inspectBigInt");

// node_modules/loupe/lib/regexp.js
function inspectRegExp(value, options) {
  var flags = value.toString().split("/")[2];
  var sourceLength = options.truncate - (2 + flags.length);
  var source = value.source;
  return options.stylize("/".concat(truncate(source, sourceLength), "/").concat(flags), "regexp");
}
__name(inspectRegExp, "inspectRegExp");

// node_modules/loupe/lib/set.js
function arrayFromSet(set2) {
  var values = [];
  set2.forEach(function (value) {
    values.push(value);
  });
  return values;
}
__name(arrayFromSet, "arrayFromSet");
function inspectSet(set2, options) {
  if (set2.size === 0) return "Set{}";
  options.truncate -= 7;
  return "Set{ ".concat(inspectList(arrayFromSet(set2), options), " }");
}
__name(inspectSet, "inspectSet");

// node_modules/loupe/lib/string.js
var stringEscapeChars = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g");
var escapeCharacters = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  "'": "\\'",
  "\\": "\\\\"
};
var hex = 16;
var unicodeLength = 4;
function escape(char) {
  return escapeCharacters[char] || "\\u".concat("0000".concat(char.charCodeAt(0).toString(hex)).slice(-unicodeLength));
}
__name(escape, "escape");
function inspectString(string, options) {
  if (stringEscapeChars.test(string)) {
    string = string.replace(stringEscapeChars, escape);
  }
  return options.stylize("'".concat(truncate(string, options.truncate - 2), "'"), "string");
}
__name(inspectString, "inspectString");

// node_modules/loupe/lib/symbol.js
function inspectSymbol(value) {
  if ("description" in Symbol.prototype) {
    return value.description ? "Symbol(".concat(value.description, ")") : "Symbol()";
  }
  return value.toString();
}
__name(inspectSymbol, "inspectSymbol");

// node_modules/loupe/lib/promise.js
var getPromiseValue$1 = /* @__PURE__ */__name(function () {
  return "Promise{\u2026}";
}, "getPromiseValue");
var promise_default = getPromiseValue$1;

// node_modules/loupe/lib/object.js
function inspectObject(object, options) {
  var properties = Object.getOwnPropertyNames(object);
  var symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : [];
  if (properties.length === 0 && symbols.length === 0) {
    return "{}";
  }
  options.truncate -= 4;
  options.seen = options.seen || [];
  if (options.seen.includes(object)) {
    return "[Circular]";
  }
  options.seen.push(object);
  var propertyContents = inspectList(properties.map(function (key) {
    return [key, object[key]];
  }), options, inspectProperty);
  var symbolContents = inspectList(symbols.map(function (key) {
    return [key, object[key]];
  }), options, inspectProperty);
  options.seen.pop();
  var sep = "";
  if (propertyContents && symbolContents) {
    sep = ", ";
  }
  return "{ ".concat(propertyContents).concat(sep).concat(symbolContents, " }");
}
__name(inspectObject, "inspectObject");

// node_modules/loupe/lib/class.js
var toStringTag = typeof Symbol !== "undefined" && Symbol.toStringTag ? Symbol.toStringTag : false;
function inspectClass(value, options) {
  var name = "";
  if (toStringTag && toStringTag in value) {
    name = value[toStringTag];
  }
  name = name || value.constructor.name;
  if (!name || name === "_class") {
    name = "<Anonymous Class>";
  }
  options.truncate -= name.length;
  return "".concat(name).concat(inspectObject(value, options));
}
__name(inspectClass, "inspectClass");

// node_modules/loupe/lib/arguments.js
function inspectArguments(args, options) {
  if (args.length === 0) return "Arguments[]";
  options.truncate -= 13;
  return "Arguments[ ".concat(inspectList(args, options), " ]");
}
__name(inspectArguments, "inspectArguments");

// node_modules/loupe/lib/error.js
var errorKeys = ["stack", "line", "column", "name", "message", "fileName", "lineNumber", "columnNumber", "number", "description", "cause"];
function inspectObject2(error, options) {
  var properties = Object.getOwnPropertyNames(error).filter(function (key) {
    return errorKeys.indexOf(key) === -1;
  });
  var name = error.name;
  options.truncate -= name.length;
  var message = "";
  if (typeof error.message === "string") {
    message = truncate(error.message, options.truncate);
  } else {
    properties.unshift("message");
  }
  message = message ? ": ".concat(message) : "";
  options.truncate -= message.length + 5;
  options.seen = options.seen || [];
  if (options.seen.includes(error)) {
    return "[Circular]";
  }
  options.seen.push(error);
  var propertyContents = inspectList(properties.map(function (key) {
    return [key, error[key]];
  }), options, inspectProperty);
  return "".concat(name).concat(message).concat(propertyContents ? " { ".concat(propertyContents, " }") : "");
}
__name(inspectObject2, "inspectObject");

// node_modules/loupe/lib/html.js
function inspectAttribute(_ref6, options) {
  var _ref7 = _slicedToArray(_ref6, 2),
    key = _ref7[0],
    value = _ref7[1];
  options.truncate -= 3;
  if (!value) {
    return "".concat(options.stylize(String(key), "yellow"));
  }
  return "".concat(options.stylize(String(key), "yellow"), "=").concat(options.stylize("\"".concat(value, "\""), "string"));
}
__name(inspectAttribute, "inspectAttribute");
function inspectNodeCollection(collection, options) {
  return inspectList(collection, options, inspectNode, "\n");
}
__name(inspectNodeCollection, "inspectNodeCollection");
function inspectNode(node, options) {
  switch (node.nodeType) {
    case 1:
      return inspectHTML(node, options);
    case 3:
      return options.inspect(node.data, options);
    default:
      return options.inspect(node, options);
  }
}
__name(inspectNode, "inspectNode");
function inspectHTML(element, options) {
  var properties = element.getAttributeNames();
  var name = element.tagName.toLowerCase();
  var head = options.stylize("<".concat(name), "special");
  var headClose = options.stylize(">", "special");
  var tail = options.stylize("</".concat(name, ">"), "special");
  options.truncate -= name.length * 2 + 5;
  var propertyContents = "";
  if (properties.length > 0) {
    propertyContents += " ";
    propertyContents += inspectList(properties.map(function (key) {
      return [key, element.getAttribute(key)];
    }), options, inspectAttribute, " ");
  }
  options.truncate -= propertyContents.length;
  var truncate2 = options.truncate;
  var children = inspectNodeCollection(element.children, options);
  if (children && children.length > truncate2) {
    children = "".concat(truncator, "(").concat(element.children.length, ")");
  }
  return "".concat(head).concat(propertyContents).concat(headClose).concat(children).concat(tail);
}
__name(inspectHTML, "inspectHTML");

// node_modules/loupe/lib/index.js
var symbolsSupported = typeof Symbol === "function" && typeof Symbol.for === "function";
var chaiInspect = symbolsSupported ? Symbol.for("chai/inspect") : "@@chai/inspect";
var nodeInspect = Symbol.for("nodejs.util.inspect.custom");
var constructorMap = /* @__PURE__ */new WeakMap();
var stringTagMap = {};
var baseTypesMap = {
  undefined: /* @__PURE__ */__name(function (value, options) {
    return options.stylize("undefined", "undefined");
  }, "undefined"),
  null: /* @__PURE__ */__name(function (value, options) {
    return options.stylize("null", "null");
  }, "null"),
  boolean: /* @__PURE__ */__name(function (value, options) {
    return options.stylize(String(value), "boolean");
  }, "boolean"),
  Boolean: /* @__PURE__ */__name(function (value, options) {
    return options.stylize(String(value), "boolean");
  }, "Boolean"),
  number: inspectNumber,
  Number: inspectNumber,
  bigint: inspectBigInt,
  BigInt: inspectBigInt,
  string: inspectString,
  String: inspectString,
  function: inspectFunction,
  Function: inspectFunction,
  symbol: inspectSymbol,
  // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
  Symbol: inspectSymbol,
  Array: inspectArray,
  Date: inspectDate,
  Map: inspectMap,
  Set: inspectSet,
  RegExp: inspectRegExp,
  Promise: promise_default,
  // WeakSet, WeakMap are totally opaque to us
  WeakSet: /* @__PURE__ */__name(function (value, options) {
    return options.stylize("WeakSet{\u2026}", "special");
  }, "WeakSet"),
  WeakMap: /* @__PURE__ */__name(function (value, options) {
    return options.stylize("WeakMap{\u2026}", "special");
  }, "WeakMap"),
  Arguments: inspectArguments,
  Int8Array: inspectTypedArray,
  Uint8Array: inspectTypedArray,
  Uint8ClampedArray: inspectTypedArray,
  Int16Array: inspectTypedArray,
  Uint16Array: inspectTypedArray,
  Int32Array: inspectTypedArray,
  Uint32Array: inspectTypedArray,
  Float32Array: inspectTypedArray,
  Float64Array: inspectTypedArray,
  Generator: /* @__PURE__ */__name(function () {
    return "";
  }, "Generator"),
  DataView: /* @__PURE__ */__name(function () {
    return "";
  }, "DataView"),
  ArrayBuffer: /* @__PURE__ */__name(function () {
    return "";
  }, "ArrayBuffer"),
  Error: inspectObject2,
  HTMLCollection: inspectNodeCollection,
  NodeList: inspectNodeCollection
};
var inspectCustom = /* @__PURE__ */__name(function (value, options, type3) {
  if (chaiInspect in value && typeof value[chaiInspect] === "function") {
    return value[chaiInspect](options);
  }
  if (nodeInspect in value && typeof value[nodeInspect] === "function") {
    return value[nodeInspect](options.depth, options);
  }
  if ("inspect" in value && typeof value.inspect === "function") {
    return value.inspect(options.depth, options);
  }
  if ("constructor" in value && constructorMap.has(value.constructor)) {
    return constructorMap.get(value.constructor)(value, options);
  }
  if (stringTagMap[type3]) {
    return stringTagMap[type3](value, options);
  }
  return "";
}, "inspectCustom");
var toString = Object.prototype.toString;
function inspect(value) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var options = normaliseOptions(opts, inspect);
  var customInspect = options.customInspect;
  var type3 = value === null ? "null" : _typeof(value);
  if (type3 === "object") {
    type3 = toString.call(value).slice(8, -1);
  }
  if (type3 in baseTypesMap) {
    return baseTypesMap[type3](value, options);
  }
  if (customInspect && value) {
    var output = inspectCustom(value, options, type3);
    if (output) {
      if (typeof output === "string") return output;
      return inspect(output, options);
    }
  }
  var proto = value ? Object.getPrototypeOf(value) : false;
  if (proto === Object.prototype || proto === null) {
    return inspectObject(value, options);
  }
  if (value && typeof HTMLElement === "function" && value instanceof HTMLElement) {
    return inspectHTML(value, options);
  }
  if ("constructor" in value) {
    if (value.constructor !== Object) {
      return inspectClass(value, options);
    }
    return inspectObject(value, options);
  }
  if (value === Object(value)) {
    return inspectObject(value, options);
  }
  return options.stylize(String(value), type3);
}
__name(inspect, "inspect");

// lib/chai/config.js
var config = {
  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {boolean}
   * @public
   */
  includeStack: false,
  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {boolean}
   * @public
   */
  showDiff: true,
  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {number}
   * @public
   */
  truncateThreshold: 40,
  /**
   * ### config.useProxy
   *
   * User configurable property, defines if chai will use a Proxy to throw
   * an error when a non-existent property is read, which protects users
   * from typos when using property-based assertions.
   *
   * Set it to false if you want to disable this feature.
   *
   *     chai.config.useProxy = false;  // disable use of Proxy
   *
   * This feature is automatically disabled regardless of this config value
   * in environments that don't support proxies.
   *
   * @param {boolean}
   * @public
   */
  useProxy: true,
  /**
   * ### config.proxyExcludedKeys
   *
   * User configurable property, defines which properties should be ignored
   * instead of throwing an error if they do not exist on the assertion.
   * This is only applied if the environment Chai is running in supports proxies and
   * if the `useProxy` configuration setting is enabled.
   * By default, `then` and `inspect` will not throw an error if they do not exist on the
   * assertion object because the `.inspect` property is read by `util.inspect` (for example, when
   * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.
   *
   *     // By default these keys will not throw an error if they do not exist on the assertion object
   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
   *
   * @param {Array}
   * @public
   */
  proxyExcludedKeys: ["then", "catch", "inspect", "toJSON"],
  /**
   * ### config.deepEqual
   *
   * User configurable property, defines which a custom function to use for deepEqual
   * comparisons.
   * By default, the function used is the one from the `deep-eql` package without custom comparator.
   *
   *     // use a custom comparator
   *     chai.config.deepEqual = (expected, actual) => {
   *         return chai.util.eql(expected, actual, {
   *             comparator: (expected, actual) => {
   *                 // for non number comparison, use the default behavior
   *                 if(typeof expected !== 'number') return null;
   *                 // allow a difference of 10 between compared numbers
   *                 return typeof actual === 'number' && Math.abs(actual - expected) < 10
   *             }
   *         })
   *     };
   *
   * @param {Function}
   * @public
   */
  deepEqual: null
};

// lib/chai/utils/inspect.js
function inspect2(obj, showHidden, depth, colors) {
  var options = {
    colors: colors,
    depth: typeof depth === "undefined" ? 2 : depth,
    showHidden: showHidden,
    truncate: config.truncateThreshold ? config.truncateThreshold : Infinity
  };
  return inspect(obj, options);
}
__name(inspect2, "inspect");

// lib/chai/utils/objDisplay.js
function _objDisplay(obj) {
  var str = inspect2(obj),
    type3 = Object.prototype.toString.call(obj);
  if (config.truncateThreshold && str.length >= config.truncateThreshold) {
    if (type3 === "[object Function]") {
      return !obj.name || obj.name === "" ? "[Function]" : "[Function: " + obj.name + "]";
    } else if (type3 === "[object Array]") {
      return "[ Array(" + obj.length + ") ]";
    } else if (type3 === "[object Object]") {
      var keys = Object.keys(obj),
        kstr = keys.length > 2 ? keys.splice(0, 2).join(", ") + ", ..." : keys.join(", ");
      return "{ Object (" + kstr + ") }";
    } else {
      return str;
    }
  } else {
    return str;
  }
}
__name(_objDisplay, "objDisplay");

// lib/chai/utils/getMessage.js
function getMessage2(obj, args) {
  var negate = _flag(obj, "negate");
  var val = _flag(obj, "object");
  var expected = args[3];
  var actual = _getActual(obj, args);
  var msg = negate ? args[2] : args[1];
  var flagMsg = _flag(obj, "message");
  if (typeof msg === "function") msg = msg();
  msg = msg || "";
  msg = msg.replace(/#\{this\}/g, function () {
    return _objDisplay(val);
  }).replace(/#\{act\}/g, function () {
    return _objDisplay(actual);
  }).replace(/#\{exp\}/g, function () {
    return _objDisplay(expected);
  });
  return flagMsg ? flagMsg + ": " + msg : msg;
}
__name(getMessage2, "getMessage");

// lib/chai/utils/transferFlags.js
function _transferFlags(assertion, object, includeAll) {
  var flags = assertion.__flags || (assertion.__flags = /* @__PURE__ */Object.create(null));
  if (!object.__flags) {
    object.__flags = /* @__PURE__ */Object.create(null);
  }
  includeAll = arguments.length === 3 ? includeAll : true;
  for (var flag3 in flags) {
    if (includeAll || flag3 !== "object" && flag3 !== "ssfi" && flag3 !== "lockSsfi" && flag3 != "message") {
      object.__flags[flag3] = flags[flag3];
    }
  }
}
__name(_transferFlags, "transferFlags");

// node_modules/deep-eql/index.js
function type2(obj) {
  if (typeof obj === "undefined") {
    return "undefined";
  }
  if (obj === null) {
    return "null";
  }
  var stringTag = obj[Symbol.toStringTag];
  if (typeof stringTag === "string") {
    return stringTag;
  }
  var sliceStart = 8;
  var sliceEnd = -1;
  return Object.prototype.toString.call(obj).slice(sliceStart, sliceEnd);
}
__name(type2, "type");
function FakeMap() {
  this._key = "chai/deep-eql__" + Math.random() + Date.now();
}
__name(FakeMap, "FakeMap");
FakeMap.prototype = {
  get: /* @__PURE__ */__name(function get(key) {
    return key[this._key];
  }, "get"),
  set: /* @__PURE__ */__name(function set(key, value) {
    if (Object.isExtensible(key)) {
      Object.defineProperty(key, this._key, {
        value: value,
        configurable: true
      });
    }
  }, "set")
};
var MemoizeMap = typeof WeakMap === "function" ? WeakMap : FakeMap;
function memoizeCompare(leftHandOperand, rightHandOperand, memoizeMap) {
  if (!memoizeMap || isPrimitive$1(leftHandOperand) || isPrimitive$1(rightHandOperand)) {
    return null;
  }
  var leftHandMap = memoizeMap.get(leftHandOperand);
  if (leftHandMap) {
    var result = leftHandMap.get(rightHandOperand);
    if (typeof result === "boolean") {
      return result;
    }
  }
  return null;
}
__name(memoizeCompare, "memoizeCompare");
function memoizeSet(leftHandOperand, rightHandOperand, memoizeMap, result) {
  if (!memoizeMap || isPrimitive$1(leftHandOperand) || isPrimitive$1(rightHandOperand)) {
    return;
  }
  var leftHandMap = memoizeMap.get(leftHandOperand);
  if (leftHandMap) {
    leftHandMap.set(rightHandOperand, result);
  } else {
    leftHandMap = new MemoizeMap();
    leftHandMap.set(rightHandOperand, result);
    memoizeMap.set(leftHandOperand, leftHandMap);
  }
}
__name(memoizeSet, "memoizeSet");
var deep_eql_default = deepEqual;
function deepEqual(leftHandOperand, rightHandOperand, options) {
  if (options && options.comparator) {
    return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
  }
  var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
  if (simpleResult !== null) {
    return simpleResult;
  }
  return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
}
__name(deepEqual, "deepEqual");
function simpleEqual(leftHandOperand, rightHandOperand) {
  if (leftHandOperand === rightHandOperand) {
    return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand;
  }
  if (leftHandOperand !== leftHandOperand &&
  // eslint-disable-line no-self-compare
  rightHandOperand !== rightHandOperand) {
    return true;
  }
  if (isPrimitive$1(leftHandOperand) || isPrimitive$1(rightHandOperand)) {
    return false;
  }
  return null;
}
__name(simpleEqual, "simpleEqual");
function extensiveDeepEqual(leftHandOperand, rightHandOperand, options) {
  options = options || {};
  options.memoize = options.memoize === false ? false : options.memoize || new MemoizeMap();
  var comparator = options && options.comparator;
  var memoizeResultLeft = memoizeCompare(leftHandOperand, rightHandOperand, options.memoize);
  if (memoizeResultLeft !== null) {
    return memoizeResultLeft;
  }
  var memoizeResultRight = memoizeCompare(rightHandOperand, leftHandOperand, options.memoize);
  if (memoizeResultRight !== null) {
    return memoizeResultRight;
  }
  if (comparator) {
    var comparatorResult = comparator(leftHandOperand, rightHandOperand);
    if (comparatorResult === false || comparatorResult === true) {
      memoizeSet(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);
      return comparatorResult;
    }
    var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
    if (simpleResult !== null) {
      return simpleResult;
    }
  }
  var leftHandType = type2(leftHandOperand);
  if (leftHandType !== type2(rightHandOperand)) {
    memoizeSet(leftHandOperand, rightHandOperand, options.memoize, false);
    return false;
  }
  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, true);
  var result = extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options);
  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, result);
  return result;
}
__name(extensiveDeepEqual, "extensiveDeepEqual");
function extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options) {
  switch (leftHandType) {
    case "String":
    case "Number":
    case "Boolean":
    case "Date":
      return deepEqual(leftHandOperand.valueOf(), rightHandOperand.valueOf());
    case "Promise":
    case "Symbol":
    case "function":
    case "WeakMap":
    case "WeakSet":
      return leftHandOperand === rightHandOperand;
    case "Error":
      return keysEqual(leftHandOperand, rightHandOperand, ["name", "message", "code"], options);
    case "Arguments":
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float32Array":
    case "Float64Array":
    case "Array":
      return iterableEqual(leftHandOperand, rightHandOperand, options);
    case "RegExp":
      return regexpEqual(leftHandOperand, rightHandOperand);
    case "Generator":
      return generatorEqual(leftHandOperand, rightHandOperand, options);
    case "DataView":
      return iterableEqual(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);
    case "ArrayBuffer":
      return iterableEqual(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);
    case "Set":
      return entriesEqual(leftHandOperand, rightHandOperand, options);
    case "Map":
      return entriesEqual(leftHandOperand, rightHandOperand, options);
    case "Temporal.PlainDate":
    case "Temporal.PlainTime":
    case "Temporal.PlainDateTime":
    case "Temporal.Instant":
    case "Temporal.ZonedDateTime":
    case "Temporal.PlainYearMonth":
    case "Temporal.PlainMonthDay":
      return leftHandOperand.equals(rightHandOperand);
    case "Temporal.Duration":
      return leftHandOperand.total("nanoseconds") === rightHandOperand.total("nanoseconds");
    case "Temporal.TimeZone":
    case "Temporal.Calendar":
      return leftHandOperand.toString() === rightHandOperand.toString();
    default:
      return objectEqual(leftHandOperand, rightHandOperand, options);
  }
}
__name(extensiveDeepEqualByType, "extensiveDeepEqualByType");
function regexpEqual(leftHandOperand, rightHandOperand) {
  return leftHandOperand.toString() === rightHandOperand.toString();
}
__name(regexpEqual, "regexpEqual");
function entriesEqual(leftHandOperand, rightHandOperand, options) {
  try {
    if (leftHandOperand.size !== rightHandOperand.size) {
      return false;
    }
    if (leftHandOperand.size === 0) {
      return true;
    }
  } catch (sizeError) {
    return false;
  }
  var leftHandItems = [];
  var rightHandItems = [];
  leftHandOperand.forEach(/* @__PURE__ */__name(function gatherEntries(key, value) {
    leftHandItems.push([key, value]);
  }, "gatherEntries"));
  rightHandOperand.forEach(/* @__PURE__ */__name(function gatherEntries(key, value) {
    rightHandItems.push([key, value]);
  }, "gatherEntries"));
  return iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options);
}
__name(entriesEqual, "entriesEqual");
function iterableEqual(leftHandOperand, rightHandOperand, options) {
  var length = leftHandOperand.length;
  if (length !== rightHandOperand.length) {
    return false;
  }
  if (length === 0) {
    return true;
  }
  var index = -1;
  while (++index < length) {
    if (deepEqual(leftHandOperand[index], rightHandOperand[index], options) === false) {
      return false;
    }
  }
  return true;
}
__name(iterableEqual, "iterableEqual");
function generatorEqual(leftHandOperand, rightHandOperand, options) {
  return iterableEqual(getGeneratorEntries(leftHandOperand), getGeneratorEntries(rightHandOperand), options);
}
__name(generatorEqual, "generatorEqual");
function hasIteratorFunction(target) {
  return typeof Symbol !== "undefined" && _typeof(target) === "object" && typeof Symbol.iterator !== "undefined" && typeof target[Symbol.iterator] === "function";
}
__name(hasIteratorFunction, "hasIteratorFunction");
function getIteratorEntries(target) {
  if (hasIteratorFunction(target)) {
    try {
      return getGeneratorEntries(target[Symbol.iterator]());
    } catch (iteratorError) {
      return [];
    }
  }
  return [];
}
__name(getIteratorEntries, "getIteratorEntries");
function getGeneratorEntries(generator) {
  var generatorResult = generator.next();
  var accumulator = [generatorResult.value];
  while (generatorResult.done === false) {
    generatorResult = generator.next();
    accumulator.push(generatorResult.value);
  }
  return accumulator;
}
__name(getGeneratorEntries, "getGeneratorEntries");
function getEnumerableKeys(target) {
  var keys = [];
  for (var key in target) {
    keys.push(key);
  }
  return keys;
}
__name(getEnumerableKeys, "getEnumerableKeys");
function getEnumerableSymbols(target) {
  var keys = [];
  var allKeys = Object.getOwnPropertySymbols(target);
  for (var i = 0; i < allKeys.length; i += 1) {
    var key = allKeys[i];
    if (Object.getOwnPropertyDescriptor(target, key).enumerable) {
      keys.push(key);
    }
  }
  return keys;
}
__name(getEnumerableSymbols, "getEnumerableSymbols");
function keysEqual(leftHandOperand, rightHandOperand, keys, options) {
  var length = keys.length;
  if (length === 0) {
    return true;
  }
  for (var i = 0; i < length; i += 1) {
    if (deepEqual(leftHandOperand[keys[i]], rightHandOperand[keys[i]], options) === false) {
      return false;
    }
  }
  return true;
}
__name(keysEqual, "keysEqual");
function objectEqual(leftHandOperand, rightHandOperand, options) {
  var leftHandKeys = getEnumerableKeys(leftHandOperand);
  var rightHandKeys = getEnumerableKeys(rightHandOperand);
  var leftHandSymbols = getEnumerableSymbols(leftHandOperand);
  var rightHandSymbols = getEnumerableSymbols(rightHandOperand);
  leftHandKeys = leftHandKeys.concat(leftHandSymbols);
  rightHandKeys = rightHandKeys.concat(rightHandSymbols);
  if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {
    if (iterableEqual(mapSymbols(leftHandKeys).sort(), mapSymbols(rightHandKeys).sort()) === false) {
      return false;
    }
    return keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options);
  }
  var leftHandEntries = getIteratorEntries(leftHandOperand);
  var rightHandEntries = getIteratorEntries(rightHandOperand);
  if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {
    leftHandEntries.sort();
    rightHandEntries.sort();
    return iterableEqual(leftHandEntries, rightHandEntries, options);
  }
  if (leftHandKeys.length === 0 && leftHandEntries.length === 0 && rightHandKeys.length === 0 && rightHandEntries.length === 0) {
    return true;
  }
  return false;
}
__name(objectEqual, "objectEqual");
function isPrimitive$1(value) {
  return value === null || _typeof(value) !== "object";
}
__name(isPrimitive$1, "isPrimitive");
function mapSymbols(arr) {
  return arr.map(/* @__PURE__ */__name(function mapSymbol(entry) {
    if (_typeof(entry) === "symbol") {
      return entry.toString();
    }
    return entry;
  }, "mapSymbol"));
}
__name(mapSymbols, "mapSymbols");

// node_modules/pathval/index.js
function _hasProperty(obj, name) {
  if (typeof obj === "undefined" || obj === null) {
    return false;
  }
  return name in Object(obj);
}
__name(_hasProperty, "hasProperty");
function parsePath(path) {
  var str = path.replace(/([^\\])\[/g, "$1.[");
  var parts = str.match(/(\\\.|[^.]+?)+/g);
  return parts.map(function (value) {
    if (value === "constructor" || value === "__proto__" || value === "prototype") {
      return {};
    }
    var regexp = /^\[(\d+)\]$/;
    var mArr = regexp.exec(value);
    var parsed = null;
    if (mArr) {
      parsed = {
        i: parseFloat(mArr[1])
      };
    } else {
      parsed = {
        p: value.replace(/\\([.[\]])/g, "$1")
      };
    }
    return parsed;
  });
}
__name(parsePath, "parsePath");
function internalGetPathValue(obj, parsed, pathDepth) {
  var temporaryValue = obj;
  var res = null;
  pathDepth = typeof pathDepth === "undefined" ? parsed.length : pathDepth;
  for (var i = 0; i < pathDepth; i++) {
    var part = parsed[i];
    if (temporaryValue) {
      if (typeof part.p === "undefined") {
        temporaryValue = temporaryValue[part.i];
      } else {
        temporaryValue = temporaryValue[part.p];
      }
      if (i === pathDepth - 1) {
        res = temporaryValue;
      }
    }
  }
  return res;
}
__name(internalGetPathValue, "internalGetPathValue");
function _getPathInfo(obj, path) {
  var parsed = parsePath(path);
  var last = parsed[parsed.length - 1];
  var info = {
    parent: parsed.length > 1 ? internalGetPathValue(obj, parsed, parsed.length - 1) : obj,
    name: last.p || last.i,
    value: internalGetPathValue(obj, parsed)
  };
  info.exists = _hasProperty(info.parent, info.name);
  return info;
}
__name(_getPathInfo, "getPathInfo");

// lib/chai/assertion.js
var Assertion = (_Assertion2 = /*#__PURE__*/function () {
  /**
   * Creates object for chaining.
   * `Assertion` objects contain metadata in the form of flags. Three flags can
   * be assigned during instantiation by passing arguments to this constructor:
   *
   * - `object`: This flag contains the target of the assertion. For example, in
   * the assertion `expect(numKittens).to.equal(7);`, the `object` flag will
   * contain `numKittens` so that the `equal` assertion can reference it when
   * needed.
   *
   * - `message`: This flag contains an optional custom error message to be
   * prepended to the error message that's generated by the assertion when it
   * fails.
   *
   * - `ssfi`: This flag stands for "start stack function indicator". It
   * contains a function reference that serves as the starting point for
   * removing frames from the stack trace of the error that's created by the
   * assertion when it fails. The goal is to provide a cleaner stack trace to
   * end users by removing Chai's internal functions. Note that it only works
   * in environments that support `Error.captureStackTrace`, and only when
   * `Chai.config.includeStack` hasn't been set to `false`.
   *
   * - `lockSsfi`: This flag controls whether or not the given `ssfi` flag
   * should retain its current value, even as assertions are chained off of
   * this object. This is usually set to `true` when creating a new assertion
   * from within another assertion. It's also temporarily set to `true` before
   * an overwritten assertion gets called by the overwriting assertion.
   *
   * - `eql`: This flag contains the deepEqual function to be used by the assertion.
   *
   * @param {unknown} obj target of the assertion
   * @param {string} [msg] (optional) custom error message
   * @param {Function} [ssfi] (optional) starting point for removing stack frames
   * @param {boolean} [lockSsfi] (optional) whether or not the ssfi flag is locked
   */
  function _Assertion(obj, msg, ssfi, lockSsfi) {
    _classCallCheck(this, _Assertion);
    /** @type {{}} */
    _defineProperty(this, "__flags", {});
    _flag(this, "ssfi", ssfi || _Assertion);
    _flag(this, "lockSsfi", lockSsfi);
    _flag(this, "object", obj);
    _flag(this, "message", msg);
    _flag(this, "eql", config.deepEqual || deep_eql_default);
    return _proxify(this);
  }
  /** @returns {boolean} */
  return _createClass(_Assertion, [{
    key: "assert",
    value:
    /**
     * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
     *
     * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
     *
     * @name assert
     * @param {unknown} _expr to be tested
     * @param {string | Function} msg or function that returns message to display if expression fails
     * @param {string | Function} _negateMsg or function that returns negatedMessage to display if negated expression fails
     * @param {unknown} expected value (remember to check for negation)
     * @param {unknown} _actual (optional) will default to `this.obj`
     * @param {boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
     * @returns {void}
     */
    function assert(_expr, msg, _negateMsg, expected, _actual, showDiff) {
      var ok = _test$1(this, arguments);
      if (false !== showDiff) showDiff = true;
      if (void 0 === expected && void 0 === _actual) showDiff = false;
      if (true !== config.showDiff) showDiff = false;
      if (!ok) {
        msg = getMessage2(this, arguments);
        var actual = _getActual(this, arguments);
        var assertionErrorObjectProperties = {
          actual: actual,
          expected: expected,
          showDiff: showDiff
        };
        var operator = _getOperator(this, arguments);
        if (operator) {
          assertionErrorObjectProperties.operator = operator;
        }
        throw new AssertionError(msg, assertionErrorObjectProperties,
        // @ts-expect-error Not sure what to do about these types yet
        config.includeStack ? this.assert : _flag(this, "ssfi"));
      }
    }
    /**
     * Quick reference to stored `actual` value for plugin developers.
     *
     * @returns {unknown}
     */
  }, {
    key: "_obj",
    get: function get() {
      return _flag(this, "object");
    }
    /**
     * Quick reference to stored `actual` value for plugin developers.
     *
     * @param {unknown} val
     */,
    set: function set(val) {
      _flag(this, "object", val);
    }
  }], [{
    key: "includeStack",
    get: function get() {
      console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead.");
      return config.includeStack;
    }
    /** @param {boolean} value */,
    set: function set(value) {
      console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead.");
      config.includeStack = value;
    }
    /** @returns {boolean} */
  }, {
    key: "showDiff",
    get: function get() {
      console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead.");
      return config.showDiff;
    }
    /** @param {boolean} value */,
    set: function set(value) {
      console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead.");
      config.showDiff = value;
    }
    /**
     * @param {string} name
     * @param {Function} fn
     */
  }, {
    key: "addProperty",
    value: function addProperty(name, fn) {
      _addProperty(this.prototype, name, fn);
    }
    /**
     * @param {string} name
     * @param {Function} fn
     */
  }, {
    key: "addMethod",
    value: function addMethod(name, fn) {
      _addMethod(this.prototype, name, fn);
    }
    /**
     * @param {string} name
     * @param {Function} fn
     * @param {Function} chainingBehavior
     */
  }, {
    key: "addChainableMethod",
    value: function addChainableMethod(name, fn, chainingBehavior) {
      _addChainableMethod(this.prototype, name, fn, chainingBehavior);
    }
    /**
     * @param {string} name
     * @param {Function} fn
     */
  }, {
    key: "overwriteProperty",
    value: function overwriteProperty(name, fn) {
      _overwriteProperty(this.prototype, name, fn);
    }
    /**
     * @param {string} name
     * @param {Function} fn
     */
  }, {
    key: "overwriteMethod",
    value: function overwriteMethod(name, fn) {
      _overwriteMethod(this.prototype, name, fn);
    }
    /**
     * @param {string} name
     * @param {Function} fn
     * @param {Function} chainingBehavior
     */
  }, {
    key: "overwriteChainableMethod",
    value: function overwriteChainableMethod(name, fn, chainingBehavior) {
      _overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
    }
  }]);
}(), __name(_Assertion2, "Assertion"), _Assertion2);

// lib/chai/utils/isProxyEnabled.js
function _isProxyEnabled() {
  return config.useProxy && typeof Proxy !== "undefined" && typeof Reflect !== "undefined";
}
__name(_isProxyEnabled, "isProxyEnabled");

// lib/chai/utils/addProperty.js
function _addProperty(ctx, name, getter) {
  getter = getter === void 0 ? function () {} : getter;
  Object.defineProperty(ctx, name, {
    get: /* @__PURE__ */__name(function propertyGetter() {
      if (!_isProxyEnabled() && !_flag(this, "lockSsfi")) {
        _flag(this, "ssfi", propertyGetter);
      }
      var result = getter.call(this);
      if (result !== void 0) return result;
      var newAssertion = new Assertion();
      _transferFlags(this, newAssertion);
      return newAssertion;
    }, "propertyGetter"),
    configurable: true
  });
}
__name(_addProperty, "addProperty");

// lib/chai/utils/addLengthGuard.js
var fnLengthDesc = Object.getOwnPropertyDescriptor(function () {}, "length");
function _addLengthGuard(fn, assertionName, isChainable) {
  if (!fnLengthDesc.configurable) return fn;
  Object.defineProperty(fn, "length", {
    get: /* @__PURE__ */__name(function () {
      if (isChainable) {
        throw Error("Invalid Chai property: " + assertionName + '.length. Due to a compatibility issue, "length" cannot directly follow "' + assertionName + '". Use "' + assertionName + '.lengthOf" instead.');
      }
      throw Error("Invalid Chai property: " + assertionName + '.length. See docs for proper usage of "' + assertionName + '".');
    }, "get")
  });
  return fn;
}
__name(_addLengthGuard, "addLengthGuard");

// lib/chai/utils/getProperties.js
function getProperties(object) {
  var result = Object.getOwnPropertyNames(object);
  function addProperty2(property) {
    if (result.indexOf(property) === -1) {
      result.push(property);
    }
  }
  __name(addProperty2, "addProperty");
  var proto = Object.getPrototypeOf(object);
  while (proto !== null) {
    Object.getOwnPropertyNames(proto).forEach(addProperty2);
    proto = Object.getPrototypeOf(proto);
  }
  return result;
}
__name(getProperties, "getProperties");

// lib/chai/utils/proxify.js
var builtins = ["__flags", "__methods", "_obj", "assert"];
function _proxify(obj, nonChainableMethodName) {
  if (!_isProxyEnabled()) return obj;
  return new Proxy(obj, {
    get: /* @__PURE__ */__name(function proxyGetter(target, property) {
      if (typeof property === "string" && config.proxyExcludedKeys.indexOf(property) === -1 && !Reflect.has(target, property)) {
        if (nonChainableMethodName) {
          throw Error("Invalid Chai property: " + nonChainableMethodName + "." + property + '. See docs for proper usage of "' + nonChainableMethodName + '".');
        }
        var suggestion = null;
        var suggestionDistance = 4;
        getProperties(target).forEach(function (prop) {
          if (
          // we actually mean to check `Object.prototype` here
          // eslint-disable-next-line no-prototype-builtins
          !Object.prototype.hasOwnProperty(prop) && builtins.indexOf(prop) === -1) {
            var dist = stringDistanceCapped(property, prop, suggestionDistance);
            if (dist < suggestionDistance) {
              suggestion = prop;
              suggestionDistance = dist;
            }
          }
        });
        if (suggestion !== null) {
          throw Error("Invalid Chai property: " + property + '. Did you mean "' + suggestion + '"?');
        } else {
          throw Error("Invalid Chai property: " + property);
        }
      }
      if (builtins.indexOf(property) === -1 && !_flag(target, "lockSsfi")) {
        _flag(target, "ssfi", proxyGetter);
      }
      return Reflect.get(target, property);
    }, "proxyGetter")
  });
}
__name(_proxify, "proxify");
function stringDistanceCapped(strA, strB, cap) {
  if (Math.abs(strA.length - strB.length) >= cap) {
    return cap;
  }
  var memo = [];
  for (var i = 0; i <= strA.length; i++) {
    memo[i] = Array(strB.length + 1).fill(0);
    memo[i][0] = i;
  }
  for (var j = 0; j < strB.length; j++) {
    memo[0][j] = j;
  }
  for (var _i = 1; _i <= strA.length; _i++) {
    var ch = strA.charCodeAt(_i - 1);
    for (var _j = 1; _j <= strB.length; _j++) {
      if (Math.abs(_i - _j) >= cap) {
        memo[_i][_j] = cap;
        continue;
      }
      memo[_i][_j] = Math.min(memo[_i - 1][_j] + 1, memo[_i][_j - 1] + 1, memo[_i - 1][_j - 1] + (ch === strB.charCodeAt(_j - 1) ? 0 : 1));
    }
  }
  return memo[strA.length][strB.length];
}
__name(stringDistanceCapped, "stringDistanceCapped");

// lib/chai/utils/addMethod.js
function _addMethod(ctx, name, method) {
  var methodWrapper = /* @__PURE__ */__name(function () {
    if (!_flag(this, "lockSsfi")) {
      _flag(this, "ssfi", methodWrapper);
    }
    var result = method.apply(this, arguments);
    if (result !== void 0) return result;
    var newAssertion = new Assertion();
    _transferFlags(this, newAssertion);
    return newAssertion;
  }, "methodWrapper");
  _addLengthGuard(methodWrapper, name, false);
  ctx[name] = _proxify(methodWrapper, name);
}
__name(_addMethod, "addMethod");

// lib/chai/utils/overwriteProperty.js
function _overwriteProperty(ctx, name, getter) {
  var _get = Object.getOwnPropertyDescriptor(ctx, name),
    _super = /* @__PURE__ */__name(function () {}, "_super");
  if (_get && "function" === typeof _get.get) _super = _get.get;
  Object.defineProperty(ctx, name, {
    get: /* @__PURE__ */__name(function overwritingPropertyGetter() {
      if (!_isProxyEnabled() && !_flag(this, "lockSsfi")) {
        _flag(this, "ssfi", overwritingPropertyGetter);
      }
      var origLockSsfi = _flag(this, "lockSsfi");
      _flag(this, "lockSsfi", true);
      var result = getter(_super).call(this);
      _flag(this, "lockSsfi", origLockSsfi);
      if (result !== void 0) {
        return result;
      }
      var newAssertion = new Assertion();
      _transferFlags(this, newAssertion);
      return newAssertion;
    }, "overwritingPropertyGetter"),
    configurable: true
  });
}
__name(_overwriteProperty, "overwriteProperty");

// lib/chai/utils/overwriteMethod.js
function _overwriteMethod(ctx, name, method) {
  var _method = ctx[name],
    _super = /* @__PURE__ */__name(function () {
      throw new Error(name + " is not a function");
    }, "_super");
  if (_method && "function" === typeof _method) _super = _method;
  var overwritingMethodWrapper = /* @__PURE__ */__name(function () {
    if (!_flag(this, "lockSsfi")) {
      _flag(this, "ssfi", overwritingMethodWrapper);
    }
    var origLockSsfi = _flag(this, "lockSsfi");
    _flag(this, "lockSsfi", true);
    var result = method(_super).apply(this, arguments);
    _flag(this, "lockSsfi", origLockSsfi);
    if (result !== void 0) {
      return result;
    }
    var newAssertion = new Assertion();
    _transferFlags(this, newAssertion);
    return newAssertion;
  }, "overwritingMethodWrapper");
  _addLengthGuard(overwritingMethodWrapper, name, false);
  ctx[name] = _proxify(overwritingMethodWrapper, name);
}
__name(_overwriteMethod, "overwriteMethod");

// lib/chai/utils/addChainableMethod.js
var canSetPrototype = typeof Object.setPrototypeOf === "function";
var testFn = /* @__PURE__ */__name(function () {}, "testFn");
var excludeNames = Object.getOwnPropertyNames(testFn).filter(function (name) {
  var propDesc = Object.getOwnPropertyDescriptor(testFn, name);
  if (_typeof(propDesc) !== "object") return true;
  return !propDesc.configurable;
});
var call = Function.prototype.call;
var apply = Function.prototype.apply;
function _addChainableMethod(ctx, name, method, chainingBehavior) {
  if (typeof chainingBehavior !== "function") {
    chainingBehavior = /* @__PURE__ */__name(function () {}, "chainingBehavior");
  }
  var chainableBehavior = {
    method: method,
    chainingBehavior: chainingBehavior
  };
  if (!ctx.__methods) {
    ctx.__methods = {};
  }
  ctx.__methods[name] = chainableBehavior;
  Object.defineProperty(ctx, name, {
    get: /* @__PURE__ */__name(function chainableMethodGetter() {
      chainableBehavior.chainingBehavior.call(this);
      var chainableMethodWrapper = /* @__PURE__ */__name(function () {
        if (!_flag(this, "lockSsfi")) {
          _flag(this, "ssfi", chainableMethodWrapper);
        }
        var result = chainableBehavior.method.apply(this, arguments);
        if (result !== void 0) {
          return result;
        }
        var newAssertion = new Assertion();
        _transferFlags(this, newAssertion);
        return newAssertion;
      }, "chainableMethodWrapper");
      _addLengthGuard(chainableMethodWrapper, name, true);
      if (canSetPrototype) {
        var prototype = Object.create(this);
        prototype.call = call;
        prototype.apply = apply;
        Object.setPrototypeOf(chainableMethodWrapper, prototype);
      } else {
        var asserterNames = Object.getOwnPropertyNames(ctx);
        asserterNames.forEach(function (asserterName) {
          if (excludeNames.indexOf(asserterName) !== -1) {
            return;
          }
          var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
          Object.defineProperty(chainableMethodWrapper, asserterName, pd);
        });
      }
      _transferFlags(this, chainableMethodWrapper);
      return _proxify(chainableMethodWrapper);
    }, "chainableMethodGetter"),
    configurable: true
  });
}
__name(_addChainableMethod, "addChainableMethod");

// lib/chai/utils/overwriteChainableMethod.js
function _overwriteChainableMethod(ctx, name, method, chainingBehavior) {
  var chainableBehavior = ctx.__methods[name];
  var _chainingBehavior = chainableBehavior.chainingBehavior;
  chainableBehavior.chainingBehavior = /* @__PURE__ */__name(function overwritingChainableMethodGetter() {
    var result = chainingBehavior(_chainingBehavior).call(this);
    if (result !== void 0) {
      return result;
    }
    var newAssertion = new Assertion();
    _transferFlags(this, newAssertion);
    return newAssertion;
  }, "overwritingChainableMethodGetter");
  var _method = chainableBehavior.method;
  chainableBehavior.method = /* @__PURE__ */__name(function overwritingChainableMethodWrapper() {
    var result = method(_method).apply(this, arguments);
    if (result !== void 0) {
      return result;
    }
    var newAssertion = new Assertion();
    _transferFlags(this, newAssertion);
    return newAssertion;
  }, "overwritingChainableMethodWrapper");
}
__name(_overwriteChainableMethod, "overwriteChainableMethod");

// lib/chai/utils/compareByInspect.js
function _compareByInspect(a, b) {
  return inspect2(a) < inspect2(b) ? -1 : 1;
}
__name(_compareByInspect, "compareByInspect");

// lib/chai/utils/getOwnEnumerablePropertySymbols.js
function _getOwnEnumerablePropertySymbols(obj) {
  if (typeof Object.getOwnPropertySymbols !== "function") return [];
  return Object.getOwnPropertySymbols(obj).filter(function (sym) {
    return Object.getOwnPropertyDescriptor(obj, sym).enumerable;
  });
}
__name(_getOwnEnumerablePropertySymbols, "getOwnEnumerablePropertySymbols");

// lib/chai/utils/getOwnEnumerableProperties.js
function _getOwnEnumerableProperties(obj) {
  return Object.keys(obj).concat(_getOwnEnumerablePropertySymbols(obj));
}
__name(_getOwnEnumerableProperties, "getOwnEnumerableProperties");

// lib/chai/utils/isNaN.js
var isNaN2 = Number.isNaN;

// lib/chai/utils/getOperator.js
function isObjectType(obj) {
  var objectType = _type(obj);
  var objectTypes = ["Array", "Object", "Function"];
  return objectTypes.indexOf(objectType) !== -1;
}
__name(isObjectType, "isObjectType");
function _getOperator(obj, args) {
  var operator = _flag(obj, "operator");
  var negate = _flag(obj, "negate");
  var expected = args[3];
  var msg = negate ? args[2] : args[1];
  if (operator) {
    return operator;
  }
  if (typeof msg === "function") msg = msg();
  msg = msg || "";
  if (!msg) {
    return void 0;
  }
  if (/\shave\s/.test(msg)) {
    return void 0;
  }
  var isObject = isObjectType(expected);
  if (/\snot\s/.test(msg)) {
    return isObject ? "notDeepStrictEqual" : "notStrictEqual";
  }
  return isObject ? "deepStrictEqual" : "strictEqual";
}
__name(_getOperator, "getOperator");

// lib/chai/utils/index.js
function _getName(fn) {
  return fn.name;
}
__name(_getName, "getName");
function isRegExp2(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
}
__name(isRegExp2, "isRegExp");
function _isNumeric(obj) {
  return ["Number", "BigInt"].includes(_type(obj));
}
__name(_isNumeric, "isNumeric");

// lib/chai/core/assertions.js
var flag2 = utils_exports.flag;
["to", "be", "been", "is", "and", "has", "have", "with", "that", "which", "at", "of", "same", "but", "does", "still", "also"].forEach(function (chain) {
  Assertion.addProperty(chain);
});
Assertion.addProperty("not", function () {
  flag2(this, "negate", true);
});
Assertion.addProperty("deep", function () {
  flag2(this, "deep", true);
});
Assertion.addProperty("nested", function () {
  flag2(this, "nested", true);
});
Assertion.addProperty("own", function () {
  flag2(this, "own", true);
});
Assertion.addProperty("ordered", function () {
  flag2(this, "ordered", true);
});
Assertion.addProperty("any", function () {
  flag2(this, "any", true);
  flag2(this, "all", false);
});
Assertion.addProperty("all", function () {
  flag2(this, "all", true);
  flag2(this, "any", false);
});
var functionTypes = {
  function: ["function", "asyncfunction", "generatorfunction", "asyncgeneratorfunction"],
  asyncfunction: ["asyncfunction", "asyncgeneratorfunction"],
  generatorfunction: ["generatorfunction", "asyncgeneratorfunction"],
  asyncgeneratorfunction: ["asyncgeneratorfunction"]
};
function an(type3, msg) {
  if (msg) flag2(this, "message", msg);
  type3 = type3.toLowerCase();
  var obj = flag2(this, "object"),
    article = ~["a", "e", "i", "o", "u"].indexOf(type3.charAt(0)) ? "an " : "a ";
  var detectedType = _type(obj).toLowerCase();
  if (functionTypes["function"].includes(type3)) {
    this.assert(functionTypes[type3].includes(detectedType), "expected #{this} to be " + article + type3, "expected #{this} not to be " + article + type3);
  } else {
    this.assert(type3 === detectedType, "expected #{this} to be " + article + type3, "expected #{this} not to be " + article + type3);
  }
}
__name(an, "an");
Assertion.addChainableMethod("an", an);
Assertion.addChainableMethod("a", an);
function SameValueZero(a, b) {
  return isNaN2(a) && isNaN2(b) || a === b;
}
__name(SameValueZero, "SameValueZero");
function includeChainingBehavior() {
  flag2(this, "contains", true);
}
__name(includeChainingBehavior, "includeChainingBehavior");
function include(val, msg) {
  if (msg) flag2(this, "message", msg);
  var obj = flag2(this, "object"),
    objType = _type(obj).toLowerCase(),
    flagMsg = flag2(this, "message"),
    negate = flag2(this, "negate"),
    ssfi = flag2(this, "ssfi"),
    isDeep = flag2(this, "deep"),
    descriptor = isDeep ? "deep " : "",
    isEql = isDeep ? flag2(this, "eql") : SameValueZero;
  flagMsg = flagMsg ? flagMsg + ": " : "";
  var included = false;
  switch (objType) {
    case "string":
      included = obj.indexOf(val) !== -1;
      break;
    case "weakset":
      if (isDeep) {
        throw new AssertionError(flagMsg + "unable to use .deep.include with WeakSet", void 0, ssfi);
      }
      included = obj.has(val);
      break;
    case "map":
      obj.forEach(function (item) {
        included = included || isEql(item, val);
      });
      break;
    case "set":
      if (isDeep) {
        obj.forEach(function (item) {
          included = included || isEql(item, val);
        });
      } else {
        included = obj.has(val);
      }
      break;
    case "array":
      if (isDeep) {
        included = obj.some(function (item) {
          return isEql(item, val);
        });
      } else {
        included = obj.indexOf(val) !== -1;
      }
      break;
    default:
      {
        if (val !== Object(val)) {
          throw new AssertionError(flagMsg + "the given combination of arguments (" + objType + " and " + _type(val).toLowerCase() + ") is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a " + _type(val).toLowerCase(), void 0, ssfi);
        }
        var props = Object.keys(val);
        var firstErr = null;
        var numErrs = 0;
        props.forEach(function (prop) {
          var propAssertion = new Assertion(obj);
          _transferFlags(this, propAssertion, true);
          flag2(propAssertion, "lockSsfi", true);
          if (!negate || props.length === 1) {
            propAssertion.property(prop, val[prop]);
            return;
          }
          try {
            propAssertion.property(prop, val[prop]);
          } catch (err) {
            if (!check_error_exports.compatibleConstructor(err, AssertionError)) {
              throw err;
            }
            if (firstErr === null) firstErr = err;
            numErrs++;
          }
        }, this);
        if (negate && props.length > 1 && numErrs === props.length) {
          throw firstErr;
        }
        return;
      }
  }
  this.assert(included, "expected #{this} to " + descriptor + "include " + inspect2(val), "expected #{this} to not " + descriptor + "include " + inspect2(val));
}
__name(include, "include");
Assertion.addChainableMethod("include", include, includeChainingBehavior);
Assertion.addChainableMethod("contain", include, includeChainingBehavior);
Assertion.addChainableMethod("contains", include, includeChainingBehavior);
Assertion.addChainableMethod("includes", include, includeChainingBehavior);
Assertion.addProperty("ok", function () {
  this.assert(flag2(this, "object"), "expected #{this} to be truthy", "expected #{this} to be falsy");
});
Assertion.addProperty("true", function () {
  this.assert(true === flag2(this, "object"), "expected #{this} to be true", "expected #{this} to be false", flag2(this, "negate") ? false : true);
});
Assertion.addProperty("numeric", function () {
  var object = flag2(this, "object");
  this.assert(["Number", "BigInt"].includes(_type(object)), "expected #{this} to be numeric", "expected #{this} to not be numeric", flag2(this, "negate") ? false : true);
});
Assertion.addProperty("callable", function () {
  var val = flag2(this, "object");
  var ssfi = flag2(this, "ssfi");
  var message = flag2(this, "message");
  var msg = message ? "".concat(message, ": ") : "";
  var negate = flag2(this, "negate");
  var assertionMessage = negate ? "".concat(msg, "expected ").concat(inspect2(val), " not to be a callable function") : "".concat(msg, "expected ").concat(inspect2(val), " to be a callable function");
  var isCallable = ["Function", "AsyncFunction", "GeneratorFunction", "AsyncGeneratorFunction"].includes(_type(val));
  if (isCallable && negate || !isCallable && !negate) {
    throw new AssertionError(assertionMessage, void 0, ssfi);
  }
});
Assertion.addProperty("false", function () {
  this.assert(false === flag2(this, "object"), "expected #{this} to be false", "expected #{this} to be true", flag2(this, "negate") ? true : false);
});
Assertion.addProperty("null", function () {
  this.assert(null === flag2(this, "object"), "expected #{this} to be null", "expected #{this} not to be null");
});
Assertion.addProperty("undefined", function () {
  this.assert(void 0 === flag2(this, "object"), "expected #{this} to be undefined", "expected #{this} not to be undefined");
});
Assertion.addProperty("NaN", function () {
  this.assert(isNaN2(flag2(this, "object")), "expected #{this} to be NaN", "expected #{this} not to be NaN");
});
function assertExist() {
  var val = flag2(this, "object");
  this.assert(val !== null && val !== void 0, "expected #{this} to exist", "expected #{this} to not exist");
}
__name(assertExist, "assertExist");
Assertion.addProperty("exist", assertExist);
Assertion.addProperty("exists", assertExist);
Assertion.addProperty("empty", function () {
  var val = flag2(this, "object"),
    ssfi = flag2(this, "ssfi"),
    flagMsg = flag2(this, "message"),
    itemsCount;
  flagMsg = flagMsg ? flagMsg + ": " : "";
  switch (_type(val).toLowerCase()) {
    case "array":
    case "string":
      itemsCount = val.length;
      break;
    case "map":
    case "set":
      itemsCount = val.size;
      break;
    case "weakmap":
    case "weakset":
      throw new AssertionError(flagMsg + ".empty was passed a weak collection", void 0, ssfi);
    case "function":
      {
        var msg = flagMsg + ".empty was passed a function " + _getName(val);
        throw new AssertionError(msg.trim(), void 0, ssfi);
      }
    default:
      if (val !== Object(val)) {
        throw new AssertionError(flagMsg + ".empty was passed non-string primitive " + inspect2(val), void 0, ssfi);
      }
      itemsCount = Object.keys(val).length;
  }
  this.assert(0 === itemsCount, "expected #{this} to be empty", "expected #{this} not to be empty");
});
function checkArguments() {
  var obj = flag2(this, "object"),
    type3 = _type(obj);
  this.assert("Arguments" === type3, "expected #{this} to be arguments but got " + type3, "expected #{this} to not be arguments");
}
__name(checkArguments, "checkArguments");
Assertion.addProperty("arguments", checkArguments);
Assertion.addProperty("Arguments", checkArguments);
function assertEqual(val, msg) {
  if (msg) flag2(this, "message", msg);
  var obj = flag2(this, "object");
  if (flag2(this, "deep")) {
    var prevLockSsfi = flag2(this, "lockSsfi");
    flag2(this, "lockSsfi", true);
    this.eql(val);
    flag2(this, "lockSsfi", prevLockSsfi);
  } else {
    this.assert(val === obj, "expected #{this} to equal #{exp}", "expected #{this} to not equal #{exp}", val, this._obj, true);
  }
}
__name(assertEqual, "assertEqual");
Assertion.addMethod("equal", assertEqual);
Assertion.addMethod("equals", assertEqual);
Assertion.addMethod("eq", assertEqual);
function assertEql(obj, msg) {
  if (msg) flag2(this, "message", msg);
  var eql = flag2(this, "eql");
  this.assert(eql(obj, flag2(this, "object")), "expected #{this} to deeply equal #{exp}", "expected #{this} to not deeply equal #{exp}", obj, this._obj, true);
}
__name(assertEql, "assertEql");
Assertion.addMethod("eql", assertEql);
Assertion.addMethod("eqls", assertEql);
function assertAbove(n, msg) {
  if (msg) flag2(this, "message", msg);
  var obj = flag2(this, "object"),
    doLength = flag2(this, "doLength"),
    flagMsg = flag2(this, "message"),
    msgPrefix = flagMsg ? flagMsg + ": " : "",
    ssfi = flag2(this, "ssfi"),
    objType = _type(obj).toLowerCase(),
    nType = _type(n).toLowerCase();
  if (doLength && objType !== "map" && objType !== "set") {
    new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
  }
  if (!doLength && objType === "date" && nType !== "date") {
    throw new AssertionError(msgPrefix + "the argument to above must be a date", void 0, ssfi);
  } else if (!_isNumeric(n) && (doLength || _isNumeric(obj))) {
    throw new AssertionError(msgPrefix + "the argument to above must be a number", void 0, ssfi);
  } else if (!doLength && objType !== "date" && !_isNumeric(obj)) {
    var printObj = objType === "string" ? "'" + obj + "'" : obj;
    throw new AssertionError(msgPrefix + "expected " + printObj + " to be a number or a date", void 0, ssfi);
  }
  if (doLength) {
    var descriptor = "length",
      itemsCount;
    if (objType === "map" || objType === "set") {
      descriptor = "size";
      itemsCount = obj.size;
    } else {
      itemsCount = obj.length;
    }
    this.assert(itemsCount > n, "expected #{this} to have a " + descriptor + " above #{exp} but got #{act}", "expected #{this} to not have a " + descriptor + " above #{exp}", n, itemsCount);
  } else {
    this.assert(obj > n, "expected #{this} to be above #{exp}", "expected #{this} to be at most #{exp}", n);
  }
}
__name(assertAbove, "assertAbove");
Assertion.addMethod("above", assertAbove);
Assertion.addMethod("gt", assertAbove);
Assertion.addMethod("greaterThan", assertAbove);
function assertLeast(n, msg) {
  if (msg) flag2(this, "message", msg);
  var obj = flag2(this, "object"),
    doLength = flag2(this, "doLength"),
    flagMsg = flag2(this, "message"),
    msgPrefix = flagMsg ? flagMsg + ": " : "",
    ssfi = flag2(this, "ssfi"),
    objType = _type(obj).toLowerCase(),
    nType = _type(n).toLowerCase(),
    errorMessage,
    shouldThrow = true;
  if (doLength && objType !== "map" && objType !== "set") {
    new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
  }
  if (!doLength && objType === "date" && nType !== "date") {
    errorMessage = msgPrefix + "the argument to least must be a date";
  } else if (!_isNumeric(n) && (doLength || _isNumeric(obj))) {
    errorMessage = msgPrefix + "the argument to least must be a number";
  } else if (!doLength && objType !== "date" && !_isNumeric(obj)) {
    var printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else {
    shouldThrow = false;
  }
  if (shouldThrow) {
    throw new AssertionError(errorMessage, void 0, ssfi);
  }
  if (doLength) {
    var descriptor = "length",
      itemsCount;
    if (objType === "map" || objType === "set") {
      descriptor = "size";
      itemsCount = obj.size;
    } else {
      itemsCount = obj.length;
    }
    this.assert(itemsCount >= n, "expected #{this} to have a " + descriptor + " at least #{exp} but got #{act}", "expected #{this} to have a " + descriptor + " below #{exp}", n, itemsCount);
  } else {
    this.assert(obj >= n, "expected #{this} to be at least #{exp}", "expected #{this} to be below #{exp}", n);
  }
}
__name(assertLeast, "assertLeast");
Assertion.addMethod("least", assertLeast);
Assertion.addMethod("gte", assertLeast);
Assertion.addMethod("greaterThanOrEqual", assertLeast);
function assertBelow(n, msg) {
  if (msg) flag2(this, "message", msg);
  var obj = flag2(this, "object"),
    doLength = flag2(this, "doLength"),
    flagMsg = flag2(this, "message"),
    msgPrefix = flagMsg ? flagMsg + ": " : "",
    ssfi = flag2(this, "ssfi"),
    objType = _type(obj).toLowerCase(),
    nType = _type(n).toLowerCase(),
    errorMessage,
    shouldThrow = true;
  if (doLength && objType !== "map" && objType !== "set") {
    new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
  }
  if (!doLength && objType === "date" && nType !== "date") {
    errorMessage = msgPrefix + "the argument to below must be a date";
  } else if (!_isNumeric(n) && (doLength || _isNumeric(obj))) {
    errorMessage = msgPrefix + "the argument to below must be a number";
  } else if (!doLength && objType !== "date" && !_isNumeric(obj)) {
    var printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else {
    shouldThrow = false;
  }
  if (shouldThrow) {
    throw new AssertionError(errorMessage, void 0, ssfi);
  }
  if (doLength) {
    var descriptor = "length",
      itemsCount;
    if (objType === "map" || objType === "set") {
      descriptor = "size";
      itemsCount = obj.size;
    } else {
      itemsCount = obj.length;
    }
    this.assert(itemsCount < n, "expected #{this} to have a " + descriptor + " below #{exp} but got #{act}", "expected #{this} to not have a " + descriptor + " below #{exp}", n, itemsCount);
  } else {
    this.assert(obj < n, "expected #{this} to be below #{exp}", "expected #{this} to be at least #{exp}", n);
  }
}
__name(assertBelow, "assertBelow");
Assertion.addMethod("below", assertBelow);
Assertion.addMethod("lt", assertBelow);
Assertion.addMethod("lessThan", assertBelow);
function assertMost(n, msg) {
  if (msg) flag2(this, "message", msg);
  var obj = flag2(this, "object"),
    doLength = flag2(this, "doLength"),
    flagMsg = flag2(this, "message"),
    msgPrefix = flagMsg ? flagMsg + ": " : "",
    ssfi = flag2(this, "ssfi"),
    objType = _type(obj).toLowerCase(),
    nType = _type(n).toLowerCase(),
    errorMessage,
    shouldThrow = true;
  if (doLength && objType !== "map" && objType !== "set") {
    new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
  }
  if (!doLength && objType === "date" && nType !== "date") {
    errorMessage = msgPrefix + "the argument to most must be a date";
  } else if (!_isNumeric(n) && (doLength || _isNumeric(obj))) {
    errorMessage = msgPrefix + "the argument to most must be a number";
  } else if (!doLength && objType !== "date" && !_isNumeric(obj)) {
    var printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else {
    shouldThrow = false;
  }
  if (shouldThrow) {
    throw new AssertionError(errorMessage, void 0, ssfi);
  }
  if (doLength) {
    var descriptor = "length",
      itemsCount;
    if (objType === "map" || objType === "set") {
      descriptor = "size";
      itemsCount = obj.size;
    } else {
      itemsCount = obj.length;
    }
    this.assert(itemsCount <= n, "expected #{this} to have a " + descriptor + " at most #{exp} but got #{act}", "expected #{this} to have a " + descriptor + " above #{exp}", n, itemsCount);
  } else {
    this.assert(obj <= n, "expected #{this} to be at most #{exp}", "expected #{this} to be above #{exp}", n);
  }
}
__name(assertMost, "assertMost");
Assertion.addMethod("most", assertMost);
Assertion.addMethod("lte", assertMost);
Assertion.addMethod("lessThanOrEqual", assertMost);
Assertion.addMethod("within", function (start, finish, msg) {
  if (msg) flag2(this, "message", msg);
  var obj = flag2(this, "object"),
    doLength = flag2(this, "doLength"),
    flagMsg = flag2(this, "message"),
    msgPrefix = flagMsg ? flagMsg + ": " : "",
    ssfi = flag2(this, "ssfi"),
    objType = _type(obj).toLowerCase(),
    startType = _type(start).toLowerCase(),
    finishType = _type(finish).toLowerCase(),
    errorMessage,
    shouldThrow = true,
    range = startType === "date" && finishType === "date" ? start.toISOString() + ".." + finish.toISOString() : start + ".." + finish;
  if (doLength && objType !== "map" && objType !== "set") {
    new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
  }
  if (!doLength && objType === "date" && (startType !== "date" || finishType !== "date")) {
    errorMessage = msgPrefix + "the arguments to within must be dates";
  } else if ((!_isNumeric(start) || !_isNumeric(finish)) && (doLength || _isNumeric(obj))) {
    errorMessage = msgPrefix + "the arguments to within must be numbers";
  } else if (!doLength && objType !== "date" && !_isNumeric(obj)) {
    var printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else {
    shouldThrow = false;
  }
  if (shouldThrow) {
    throw new AssertionError(errorMessage, void 0, ssfi);
  }
  if (doLength) {
    var descriptor = "length",
      itemsCount;
    if (objType === "map" || objType === "set") {
      descriptor = "size";
      itemsCount = obj.size;
    } else {
      itemsCount = obj.length;
    }
    this.assert(itemsCount >= start && itemsCount <= finish, "expected #{this} to have a " + descriptor + " within " + range, "expected #{this} to not have a " + descriptor + " within " + range);
  } else {
    this.assert(obj >= start && obj <= finish, "expected #{this} to be within " + range, "expected #{this} to not be within " + range);
  }
});
function assertInstanceOf(constructor, msg) {
  if (msg) flag2(this, "message", msg);
  var target = flag2(this, "object");
  var ssfi = flag2(this, "ssfi");
  var flagMsg = flag2(this, "message");
  var isInstanceOf;
  try {
    isInstanceOf = target instanceof constructor;
  } catch (err) {
    if (err instanceof TypeError) {
      flagMsg = flagMsg ? flagMsg + ": " : "";
      throw new AssertionError(flagMsg + "The instanceof assertion needs a constructor but " + _type(constructor) + " was given.", void 0, ssfi);
    }
    throw err;
  }
  var name = _getName(constructor);
  if (name == null) {
    name = "an unnamed constructor";
  }
  this.assert(isInstanceOf, "expected #{this} to be an instance of " + name, "expected #{this} to not be an instance of " + name);
}
__name(assertInstanceOf, "assertInstanceOf");
Assertion.addMethod("instanceof", assertInstanceOf);
Assertion.addMethod("instanceOf", assertInstanceOf);
function assertProperty(name, val, msg) {
  if (msg) flag2(this, "message", msg);
  var isNested = flag2(this, "nested"),
    isOwn = flag2(this, "own"),
    flagMsg = flag2(this, "message"),
    obj = flag2(this, "object"),
    ssfi = flag2(this, "ssfi"),
    nameType = _typeof(name);
  flagMsg = flagMsg ? flagMsg + ": " : "";
  if (isNested) {
    if (nameType !== "string") {
      throw new AssertionError(flagMsg + "the argument to property must be a string when using nested syntax", void 0, ssfi);
    }
  } else {
    if (nameType !== "string" && nameType !== "number" && nameType !== "symbol") {
      throw new AssertionError(flagMsg + "the argument to property must be a string, number, or symbol", void 0, ssfi);
    }
  }
  if (isNested && isOwn) {
    throw new AssertionError(flagMsg + 'The "nested" and "own" flags cannot be combined.', void 0, ssfi);
  }
  if (obj === null || obj === void 0) {
    throw new AssertionError(flagMsg + "Target cannot be null or undefined.", void 0, ssfi);
  }
  var isDeep = flag2(this, "deep"),
    negate = flag2(this, "negate"),
    pathInfo = isNested ? _getPathInfo(obj, name) : null,
    value = isNested ? pathInfo.value : obj[name],
    isEql = isDeep ? flag2(this, "eql") : function (val1, val2) {
      return val1 === val2;
    };
  var descriptor = "";
  if (isDeep) descriptor += "deep ";
  if (isOwn) descriptor += "own ";
  if (isNested) descriptor += "nested ";
  descriptor += "property ";
  var hasProperty2;
  if (isOwn) hasProperty2 = Object.prototype.hasOwnProperty.call(obj, name);else if (isNested) hasProperty2 = pathInfo.exists;else hasProperty2 = _hasProperty(obj, name);
  if (!negate || arguments.length === 1) {
    this.assert(hasProperty2, "expected #{this} to have " + descriptor + inspect2(name), "expected #{this} to not have " + descriptor + inspect2(name));
  }
  if (arguments.length > 1) {
    this.assert(hasProperty2 && isEql(val, value), "expected #{this} to have " + descriptor + inspect2(name) + " of #{exp}, but got #{act}", "expected #{this} to not have " + descriptor + inspect2(name) + " of #{act}", val, value);
  }
  flag2(this, "object", value);
}
__name(assertProperty, "assertProperty");
Assertion.addMethod("property", assertProperty);
function assertOwnProperty(_name, _value, _msg) {
  flag2(this, "own", true);
  assertProperty.apply(this, arguments);
}
__name(assertOwnProperty, "assertOwnProperty");
Assertion.addMethod("ownProperty", assertOwnProperty);
Assertion.addMethod("haveOwnProperty", assertOwnProperty);
function assertOwnPropertyDescriptor(name, descriptor, msg) {
  if (typeof descriptor === "string") {
    msg = descriptor;
    descriptor = null;
  }
  if (msg) flag2(this, "message", msg);
  var obj = flag2(this, "object");
  var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);
  var eql = flag2(this, "eql");
  if (actualDescriptor && descriptor) {
    this.assert(eql(descriptor, actualDescriptor), "expected the own property descriptor for " + inspect2(name) + " on #{this} to match " + inspect2(descriptor) + ", got " + inspect2(actualDescriptor), "expected the own property descriptor for " + inspect2(name) + " on #{this} to not match " + inspect2(descriptor), descriptor, actualDescriptor, true);
  } else {
    this.assert(actualDescriptor, "expected #{this} to have an own property descriptor for " + inspect2(name), "expected #{this} to not have an own property descriptor for " + inspect2(name));
  }
  flag2(this, "object", actualDescriptor);
}
__name(assertOwnPropertyDescriptor, "assertOwnPropertyDescriptor");
Assertion.addMethod("ownPropertyDescriptor", assertOwnPropertyDescriptor);
Assertion.addMethod("haveOwnPropertyDescriptor", assertOwnPropertyDescriptor);
function assertLengthChain() {
  flag2(this, "doLength", true);
}
__name(assertLengthChain, "assertLengthChain");
function assertLength(n, msg) {
  if (msg) flag2(this, "message", msg);
  var obj = flag2(this, "object"),
    objType = _type(obj).toLowerCase(),
    flagMsg = flag2(this, "message"),
    ssfi = flag2(this, "ssfi"),
    descriptor = "length",
    itemsCount;
  switch (objType) {
    case "map":
    case "set":
      descriptor = "size";
      itemsCount = obj.size;
      break;
    default:
      new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
      itemsCount = obj.length;
  }
  this.assert(itemsCount == n, "expected #{this} to have a " + descriptor + " of #{exp} but got #{act}", "expected #{this} to not have a " + descriptor + " of #{act}", n, itemsCount);
}
__name(assertLength, "assertLength");
Assertion.addChainableMethod("length", assertLength, assertLengthChain);
Assertion.addChainableMethod("lengthOf", assertLength, assertLengthChain);
function assertMatch(re, msg) {
  if (msg) flag2(this, "message", msg);
  var obj = flag2(this, "object");
  this.assert(re.exec(obj), "expected #{this} to match " + re, "expected #{this} not to match " + re);
}
__name(assertMatch, "assertMatch");
Assertion.addMethod("match", assertMatch);
Assertion.addMethod("matches", assertMatch);
Assertion.addMethod("string", function (str, msg) {
  if (msg) flag2(this, "message", msg);
  var obj = flag2(this, "object"),
    flagMsg = flag2(this, "message"),
    ssfi = flag2(this, "ssfi");
  new Assertion(obj, flagMsg, ssfi, true).is.a("string");
  this.assert(~obj.indexOf(str), "expected #{this} to contain " + inspect2(str), "expected #{this} to not contain " + inspect2(str));
});
function assertKeys(keys) {
  var obj = flag2(this, "object"),
    objType = _type(obj),
    keysType = _type(keys),
    ssfi = flag2(this, "ssfi"),
    isDeep = flag2(this, "deep"),
    str,
    deepStr = "",
    actual,
    ok = true,
    flagMsg = flag2(this, "message");
  flagMsg = flagMsg ? flagMsg + ": " : "";
  var mixedArgsMsg = flagMsg + "when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments";
  if (objType === "Map" || objType === "Set") {
    deepStr = isDeep ? "deeply " : "";
    actual = [];
    obj.forEach(function (val, key) {
      actual.push(key);
    });
    if (keysType !== "Array") {
      keys = Array.prototype.slice.call(arguments);
    }
  } else {
    actual = _getOwnEnumerableProperties(obj);
    switch (keysType) {
      case "Array":
        if (arguments.length > 1) {
          throw new AssertionError(mixedArgsMsg, void 0, ssfi);
        }
        break;
      case "Object":
        if (arguments.length > 1) {
          throw new AssertionError(mixedArgsMsg, void 0, ssfi);
        }
        keys = Object.keys(keys);
        break;
      default:
        keys = Array.prototype.slice.call(arguments);
    }
    keys = keys.map(function (val) {
      return _typeof(val) === "symbol" ? val : String(val);
    });
  }
  if (!keys.length) {
    throw new AssertionError(flagMsg + "keys required", void 0, ssfi);
  }
  var len = keys.length,
    any = flag2(this, "any"),
    all = flag2(this, "all"),
    expected = keys,
    isEql = isDeep ? flag2(this, "eql") : function (val1, val2) {
      return val1 === val2;
    };
  if (!any && !all) {
    all = true;
  }
  if (any) {
    ok = expected.some(function (expectedKey) {
      return actual.some(function (actualKey) {
        return isEql(expectedKey, actualKey);
      });
    });
  }
  if (all) {
    ok = expected.every(function (expectedKey) {
      return actual.some(function (actualKey) {
        return isEql(expectedKey, actualKey);
      });
    });
    if (!flag2(this, "contains")) {
      ok = ok && keys.length == actual.length;
    }
  }
  if (len > 1) {
    keys = keys.map(function (key) {
      return inspect2(key);
    });
    var last = keys.pop();
    if (all) {
      str = keys.join(", ") + ", and " + last;
    }
    if (any) {
      str = keys.join(", ") + ", or " + last;
    }
  } else {
    str = inspect2(keys[0]);
  }
  str = (len > 1 ? "keys " : "key ") + str;
  str = (flag2(this, "contains") ? "contain " : "have ") + str;
  this.assert(ok, "expected #{this} to " + deepStr + str, "expected #{this} to not " + deepStr + str, expected.slice(0).sort(_compareByInspect), actual.sort(_compareByInspect), true);
}
__name(assertKeys, "assertKeys");
Assertion.addMethod("keys", assertKeys);
Assertion.addMethod("key", assertKeys);
function assertThrows(errorLike, errMsgMatcher, msg) {
  if (msg) flag2(this, "message", msg);
  var obj = flag2(this, "object"),
    ssfi = flag2(this, "ssfi"),
    flagMsg = flag2(this, "message"),
    negate = flag2(this, "negate") || false;
  new Assertion(obj, flagMsg, ssfi, true).is.a("function");
  if (isRegExp2(errorLike) || typeof errorLike === "string") {
    errMsgMatcher = errorLike;
    errorLike = null;
  }
  var caughtErr;
  var errorWasThrown = false;
  try {
    obj();
  } catch (err) {
    errorWasThrown = true;
    caughtErr = err;
  }
  var everyArgIsUndefined = errorLike === void 0 && errMsgMatcher === void 0;
  var everyArgIsDefined = Boolean(errorLike && errMsgMatcher);
  var errorLikeFail = false;
  var errMsgMatcherFail = false;
  if (everyArgIsUndefined || !everyArgIsUndefined && !negate) {
    var errorLikeString = "an error";
    if (errorLike instanceof Error) {
      errorLikeString = "#{exp}";
    } else if (errorLike) {
      errorLikeString = check_error_exports.getConstructorName(errorLike);
    }
    var actual = caughtErr;
    if (caughtErr instanceof Error) {
      actual = caughtErr.toString();
    } else if (typeof caughtErr === "string") {
      actual = caughtErr;
    } else if (caughtErr && (_typeof(caughtErr) === "object" || typeof caughtErr === "function")) {
      try {
        actual = check_error_exports.getConstructorName(caughtErr);
      } catch (_err) {}
    }
    this.assert(errorWasThrown, "expected #{this} to throw " + errorLikeString, "expected #{this} to not throw an error but #{act} was thrown", errorLike && errorLike.toString(), actual);
  }
  if (errorLike && caughtErr) {
    if (errorLike instanceof Error) {
      var isCompatibleInstance = check_error_exports.compatibleInstance(caughtErr, errorLike);
      if (isCompatibleInstance === negate) {
        if (everyArgIsDefined && negate) {
          errorLikeFail = true;
        } else {
          this.assert(negate, "expected #{this} to throw #{exp} but #{act} was thrown", "expected #{this} to not throw #{exp}" + (caughtErr && !negate ? " but #{act} was thrown" : ""), errorLike.toString(), caughtErr.toString());
        }
      }
    }
    var isCompatibleConstructor = check_error_exports.compatibleConstructor(caughtErr, errorLike);
    if (isCompatibleConstructor === negate) {
      if (everyArgIsDefined && negate) {
        errorLikeFail = true;
      } else {
        this.assert(negate, "expected #{this} to throw #{exp} but #{act} was thrown", "expected #{this} to not throw #{exp}" + (caughtErr ? " but #{act} was thrown" : ""), errorLike instanceof Error ? errorLike.toString() : errorLike && check_error_exports.getConstructorName(errorLike), caughtErr instanceof Error ? caughtErr.toString() : caughtErr && check_error_exports.getConstructorName(caughtErr));
      }
    }
  }
  if (caughtErr && errMsgMatcher !== void 0 && errMsgMatcher !== null) {
    var placeholder = "including";
    if (isRegExp2(errMsgMatcher)) {
      placeholder = "matching";
    }
    var isCompatibleMessage = check_error_exports.compatibleMessage(caughtErr, errMsgMatcher);
    if (isCompatibleMessage === negate) {
      if (everyArgIsDefined && negate) {
        errMsgMatcherFail = true;
      } else {
        this.assert(negate, "expected #{this} to throw error " + placeholder + " #{exp} but got #{act}", "expected #{this} to throw error not " + placeholder + " #{exp}", errMsgMatcher, check_error_exports.getMessage(caughtErr));
      }
    }
  }
  if (errorLikeFail && errMsgMatcherFail) {
    this.assert(negate, "expected #{this} to throw #{exp} but #{act} was thrown", "expected #{this} to not throw #{exp}" + (caughtErr ? " but #{act} was thrown" : ""), errorLike instanceof Error ? errorLike.toString() : errorLike && check_error_exports.getConstructorName(errorLike), caughtErr instanceof Error ? caughtErr.toString() : caughtErr && check_error_exports.getConstructorName(caughtErr));
  }
  flag2(this, "object", caughtErr);
}
__name(assertThrows, "assertThrows");
Assertion.addMethod("throw", assertThrows);
Assertion.addMethod("throws", assertThrows);
Assertion.addMethod("Throw", assertThrows);
function respondTo(method, msg) {
  if (msg) flag2(this, "message", msg);
  var obj = flag2(this, "object"),
    itself = flag2(this, "itself"),
    context = "function" === typeof obj && !itself ? obj.prototype[method] : obj[method];
  this.assert("function" === typeof context, "expected #{this} to respond to " + inspect2(method), "expected #{this} to not respond to " + inspect2(method));
}
__name(respondTo, "respondTo");
Assertion.addMethod("respondTo", respondTo);
Assertion.addMethod("respondsTo", respondTo);
Assertion.addProperty("itself", function () {
  flag2(this, "itself", true);
});
function satisfy(matcher, msg) {
  if (msg) flag2(this, "message", msg);
  var obj = flag2(this, "object");
  var result = matcher(obj);
  this.assert(result, "expected #{this} to satisfy " + _objDisplay(matcher), "expected #{this} to not satisfy" + _objDisplay(matcher), flag2(this, "negate") ? false : true, result);
}
__name(satisfy, "satisfy");
Assertion.addMethod("satisfy", satisfy);
Assertion.addMethod("satisfies", satisfy);
function closeTo(expected, delta, msg) {
  if (msg) flag2(this, "message", msg);
  var obj = flag2(this, "object"),
    flagMsg = flag2(this, "message"),
    ssfi = flag2(this, "ssfi");
  new Assertion(obj, flagMsg, ssfi, true).is.numeric;
  var message = "A `delta` value is required for `closeTo`";
  if (delta == void 0) {
    throw new AssertionError(flagMsg ? "".concat(flagMsg, ": ").concat(message) : message, void 0, ssfi);
  }
  new Assertion(delta, flagMsg, ssfi, true).is.numeric;
  message = "A `expected` value is required for `closeTo`";
  if (expected == void 0) {
    throw new AssertionError(flagMsg ? "".concat(flagMsg, ": ").concat(message) : message, void 0, ssfi);
  }
  new Assertion(expected, flagMsg, ssfi, true).is.numeric;
  var abs = /* @__PURE__ */__name(function (x) {
    return x < 0n ? -x : x;
  }, "abs");
  var strip = /* @__PURE__ */__name(function (number) {
    return parseFloat(parseFloat(number).toPrecision(12));
  }, "strip");
  this.assert(strip(abs(obj - expected)) <= delta, "expected #{this} to be close to " + expected + " +/- " + delta, "expected #{this} not to be close to " + expected + " +/- " + delta);
}
__name(closeTo, "closeTo");
Assertion.addMethod("closeTo", closeTo);
Assertion.addMethod("approximately", closeTo);
function isSubsetOf(_subset, _superset, cmp, contains, ordered) {
  var superset = Array.from(_superset);
  var subset = Array.from(_subset);
  if (!contains) {
    if (subset.length !== superset.length) return false;
    superset = superset.slice();
  }
  return subset.every(function (elem, idx) {
    if (ordered) return cmp ? cmp(elem, superset[idx]) : elem === superset[idx];
    if (!cmp) {
      var matchIdx = superset.indexOf(elem);
      if (matchIdx === -1) return false;
      if (!contains) superset.splice(matchIdx, 1);
      return true;
    }
    return superset.some(function (elem2, matchIdx) {
      if (!cmp(elem, elem2)) return false;
      if (!contains) superset.splice(matchIdx, 1);
      return true;
    });
  });
}
__name(isSubsetOf, "isSubsetOf");
Assertion.addMethod("members", function (subset, msg) {
  if (msg) flag2(this, "message", msg);
  var obj = flag2(this, "object"),
    flagMsg = flag2(this, "message"),
    ssfi = flag2(this, "ssfi");
  new Assertion(obj, flagMsg, ssfi, true).to.be.iterable;
  new Assertion(subset, flagMsg, ssfi, true).to.be.iterable;
  var contains = flag2(this, "contains");
  var ordered = flag2(this, "ordered");
  var subject, failMsg, failNegateMsg;
  if (contains) {
    subject = ordered ? "an ordered superset" : "a superset";
    failMsg = "expected #{this} to be " + subject + " of #{exp}";
    failNegateMsg = "expected #{this} to not be " + subject + " of #{exp}";
  } else {
    subject = ordered ? "ordered members" : "members";
    failMsg = "expected #{this} to have the same " + subject + " as #{exp}";
    failNegateMsg = "expected #{this} to not have the same " + subject + " as #{exp}";
  }
  var cmp = flag2(this, "deep") ? flag2(this, "eql") : void 0;
  this.assert(isSubsetOf(subset, obj, cmp, contains, ordered), failMsg, failNegateMsg, subset, obj, true);
});
Assertion.addProperty("iterable", function (msg) {
  if (msg) flag2(this, "message", msg);
  var obj = flag2(this, "object");
  this.assert(obj != void 0 && obj[Symbol.iterator], "expected #{this} to be an iterable", "expected #{this} to not be an iterable", obj);
});
function oneOf(list, msg) {
  if (msg) flag2(this, "message", msg);
  var expected = flag2(this, "object"),
    flagMsg = flag2(this, "message"),
    ssfi = flag2(this, "ssfi"),
    contains = flag2(this, "contains"),
    isDeep = flag2(this, "deep"),
    eql = flag2(this, "eql");
  new Assertion(list, flagMsg, ssfi, true).to.be.an("array");
  if (contains) {
    this.assert(list.some(function (possibility) {
      return expected.indexOf(possibility) > -1;
    }), "expected #{this} to contain one of #{exp}", "expected #{this} to not contain one of #{exp}", list, expected);
  } else {
    if (isDeep) {
      this.assert(list.some(function (possibility) {
        return eql(expected, possibility);
      }), "expected #{this} to deeply equal one of #{exp}", "expected #{this} to deeply equal one of #{exp}", list, expected);
    } else {
      this.assert(list.indexOf(expected) > -1, "expected #{this} to be one of #{exp}", "expected #{this} to not be one of #{exp}", list, expected);
    }
  }
}
__name(oneOf, "oneOf");
Assertion.addMethod("oneOf", oneOf);
function assertChanges(subject, prop, msg) {
  if (msg) flag2(this, "message", msg);
  var fn = flag2(this, "object"),
    flagMsg = flag2(this, "message"),
    ssfi = flag2(this, "ssfi");
  new Assertion(fn, flagMsg, ssfi, true).is.a("function");
  var initial;
  if (!prop) {
    new Assertion(subject, flagMsg, ssfi, true).is.a("function");
    initial = subject();
  } else {
    new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
    initial = subject[prop];
  }
  fn();
  var final = prop === void 0 || prop === null ? subject() : subject[prop];
  var msgObj = prop === void 0 || prop === null ? initial : "." + prop;
  flag2(this, "deltaMsgObj", msgObj);
  flag2(this, "initialDeltaValue", initial);
  flag2(this, "finalDeltaValue", final);
  flag2(this, "deltaBehavior", "change");
  flag2(this, "realDelta", final !== initial);
  this.assert(initial !== final, "expected " + msgObj + " to change", "expected " + msgObj + " to not change");
}
__name(assertChanges, "assertChanges");
Assertion.addMethod("change", assertChanges);
Assertion.addMethod("changes", assertChanges);
function assertIncreases(subject, prop, msg) {
  if (msg) flag2(this, "message", msg);
  var fn = flag2(this, "object"),
    flagMsg = flag2(this, "message"),
    ssfi = flag2(this, "ssfi");
  new Assertion(fn, flagMsg, ssfi, true).is.a("function");
  var initial;
  if (!prop) {
    new Assertion(subject, flagMsg, ssfi, true).is.a("function");
    initial = subject();
  } else {
    new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
    initial = subject[prop];
  }
  new Assertion(initial, flagMsg, ssfi, true).is.a("number");
  fn();
  var final = prop === void 0 || prop === null ? subject() : subject[prop];
  var msgObj = prop === void 0 || prop === null ? initial : "." + prop;
  flag2(this, "deltaMsgObj", msgObj);
  flag2(this, "initialDeltaValue", initial);
  flag2(this, "finalDeltaValue", final);
  flag2(this, "deltaBehavior", "increase");
  flag2(this, "realDelta", final - initial);
  this.assert(final - initial > 0, "expected " + msgObj + " to increase", "expected " + msgObj + " to not increase");
}
__name(assertIncreases, "assertIncreases");
Assertion.addMethod("increase", assertIncreases);
Assertion.addMethod("increases", assertIncreases);
function assertDecreases(subject, prop, msg) {
  if (msg) flag2(this, "message", msg);
  var fn = flag2(this, "object"),
    flagMsg = flag2(this, "message"),
    ssfi = flag2(this, "ssfi");
  new Assertion(fn, flagMsg, ssfi, true).is.a("function");
  var initial;
  if (!prop) {
    new Assertion(subject, flagMsg, ssfi, true).is.a("function");
    initial = subject();
  } else {
    new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
    initial = subject[prop];
  }
  new Assertion(initial, flagMsg, ssfi, true).is.a("number");
  fn();
  var final = prop === void 0 || prop === null ? subject() : subject[prop];
  var msgObj = prop === void 0 || prop === null ? initial : "." + prop;
  flag2(this, "deltaMsgObj", msgObj);
  flag2(this, "initialDeltaValue", initial);
  flag2(this, "finalDeltaValue", final);
  flag2(this, "deltaBehavior", "decrease");
  flag2(this, "realDelta", initial - final);
  this.assert(final - initial < 0, "expected " + msgObj + " to decrease", "expected " + msgObj + " to not decrease");
}
__name(assertDecreases, "assertDecreases");
Assertion.addMethod("decrease", assertDecreases);
Assertion.addMethod("decreases", assertDecreases);
function assertDelta(delta, msg) {
  if (msg) flag2(this, "message", msg);
  var msgObj = flag2(this, "deltaMsgObj");
  var initial = flag2(this, "initialDeltaValue");
  var final = flag2(this, "finalDeltaValue");
  var behavior = flag2(this, "deltaBehavior");
  var realDelta = flag2(this, "realDelta");
  var expression;
  if (behavior === "change") {
    expression = Math.abs(final - initial) === Math.abs(delta);
  } else {
    expression = realDelta === Math.abs(delta);
  }
  this.assert(expression, "expected " + msgObj + " to " + behavior + " by " + delta, "expected " + msgObj + " to not " + behavior + " by " + delta);
}
__name(assertDelta, "assertDelta");
Assertion.addMethod("by", assertDelta);
Assertion.addProperty("extensible", function () {
  var obj = flag2(this, "object");
  var isExtensible = obj === Object(obj) && Object.isExtensible(obj);
  this.assert(isExtensible, "expected #{this} to be extensible", "expected #{this} to not be extensible");
});
Assertion.addProperty("sealed", function () {
  var obj = flag2(this, "object");
  var isSealed = obj === Object(obj) ? Object.isSealed(obj) : true;
  this.assert(isSealed, "expected #{this} to be sealed", "expected #{this} to not be sealed");
});
Assertion.addProperty("frozen", function () {
  var obj = flag2(this, "object");
  var isFrozen = obj === Object(obj) ? Object.isFrozen(obj) : true;
  this.assert(isFrozen, "expected #{this} to be frozen", "expected #{this} to not be frozen");
});
Assertion.addProperty("finite", function (_msg) {
  var obj = flag2(this, "object");
  this.assert(typeof obj === "number" && isFinite(obj), "expected #{this} to be a finite number", "expected #{this} to not be a finite number");
});
function compareSubset(expected, actual) {
  if (expected === actual) {
    return true;
  }
  if (_typeof(actual) !== _typeof(expected)) {
    return false;
  }
  if (_typeof(expected) !== "object" || expected === null) {
    return expected === actual;
  }
  if (!actual) {
    return false;
  }
  if (Array.isArray(expected)) {
    if (!Array.isArray(actual)) {
      return false;
    }
    return expected.every(function (exp) {
      return actual.some(function (act) {
        return compareSubset(exp, act);
      });
    });
  }
  if (expected instanceof Date) {
    if (actual instanceof Date) {
      return expected.getTime() === actual.getTime();
    } else {
      return false;
    }
  }
  return Object.keys(expected).every(function (key) {
    var expectedValue = expected[key];
    var actualValue = actual[key];
    if (_typeof(expectedValue) === "object" && expectedValue !== null && actualValue !== null) {
      return compareSubset(expectedValue, actualValue);
    }
    if (typeof expectedValue === "function") {
      return expectedValue(actualValue);
    }
    return actualValue === expectedValue;
  });
}
__name(compareSubset, "compareSubset");
Assertion.addMethod("containSubset", function (expected) {
  var actual = _flag(this, "object");
  var showDiff = config.showDiff;
  this.assert(compareSubset(expected, actual), "expected #{act} to contain subset #{exp}", "expected #{act} to not contain subset #{exp}", expected, actual, showDiff);
});

// lib/chai/interface/expect.js
function expect(val, message) {
  return new Assertion(val, message);
}
__name(expect, "expect");
expect.fail = function (actual, expected, message, operator) {
  if (arguments.length < 2) {
    message = actual;
    actual = void 0;
  }
  message = message || "expect.fail()";
  throw new AssertionError(message, {
    actual: actual,
    expected: expected,
    operator: operator
  }, expect.fail);
};

// lib/chai/interface/should.js
var should_exports = {};
__export(should_exports, {
  Should: function Should() {
    return _Should;
  },
  should: function should() {
    return _should;
  }
});
function loadShould() {
  function shouldGetter() {
    if (this instanceof String || this instanceof Number || this instanceof Boolean || typeof Symbol === "function" && this instanceof Symbol || typeof BigInt === "function" && this instanceof BigInt) {
      return new Assertion(this.valueOf(), null, shouldGetter);
    }
    return new Assertion(this, null, shouldGetter);
  }
  __name(shouldGetter, "shouldGetter");
  function shouldSetter(value) {
    Object.defineProperty(this, "should", {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  }
  __name(shouldSetter, "shouldSetter");
  Object.defineProperty(Object.prototype, "should", {
    set: shouldSetter,
    get: shouldGetter,
    configurable: true
  });
  var should2 = {};
  should2.fail = function (actual, expected, message, operator) {
    if (arguments.length < 2) {
      message = actual;
      actual = void 0;
    }
    message = message || "should.fail()";
    throw new AssertionError(message, {
      actual: actual,
      expected: expected,
      operator: operator
    }, should2.fail);
  };
  should2.equal = function (actual, expected, message) {
    new Assertion(actual, message).to.equal(expected);
  };
  should2.Throw = function (fn, errt, errs, msg) {
    new Assertion(fn, msg).to.Throw(errt, errs);
  };
  should2.exist = function (val, msg) {
    new Assertion(val, msg).to.exist;
  };
  should2.not = {};
  should2.not.equal = function (actual, expected, msg) {
    new Assertion(actual, msg).to.not.equal(expected);
  };
  should2.not.Throw = function (fn, errt, errs, msg) {
    new Assertion(fn, msg).to.not.Throw(errt, errs);
  };
  should2.not.exist = function (val, msg) {
    new Assertion(val, msg).to.not.exist;
  };
  should2["throw"] = should2["Throw"];
  should2.not["throw"] = should2.not["Throw"];
  return should2;
}
__name(loadShould, "loadShould");
var _should = loadShould;
var _Should = loadShould;

// lib/chai/interface/assert.js
function assert$1(express, errmsg) {
  var test2 = new Assertion(null, null, assert$1, true);
  test2.assert(express, errmsg, "[ negation message unavailable ]");
}
__name(assert$1, "assert");
assert$1.fail = function (actual, expected, message, operator) {
  if (arguments.length < 2) {
    message = actual;
    actual = void 0;
  }
  message = message || "assert.fail()";
  throw new AssertionError(message, {
    actual: actual,
    expected: expected,
    operator: operator
  }, assert$1.fail);
};
assert$1.isOk = function (val, msg) {
  new Assertion(val, msg, assert$1.isOk, true).is.ok;
};
assert$1.isNotOk = function (val, msg) {
  new Assertion(val, msg, assert$1.isNotOk, true).is.not.ok;
};
assert$1.equal = function (act, exp, msg) {
  var test2 = new Assertion(act, msg, assert$1.equal, true);
  test2.assert(exp == _flag(test2, "object"), "expected #{this} to equal #{exp}", "expected #{this} to not equal #{act}", exp, act, true);
};
assert$1.notEqual = function (act, exp, msg) {
  var test2 = new Assertion(act, msg, assert$1.notEqual, true);
  test2.assert(exp != _flag(test2, "object"), "expected #{this} to not equal #{exp}", "expected #{this} to equal #{act}", exp, act, true);
};
assert$1.strictEqual = function (act, exp, msg) {
  new Assertion(act, msg, assert$1.strictEqual, true).to.equal(exp);
};
assert$1.notStrictEqual = function (act, exp, msg) {
  new Assertion(act, msg, assert$1.notStrictEqual, true).to.not.equal(exp);
};
assert$1.deepEqual = assert$1.deepStrictEqual = function (act, exp, msg) {
  new Assertion(act, msg, assert$1.deepEqual, true).to.eql(exp);
};
assert$1.notDeepEqual = function (act, exp, msg) {
  new Assertion(act, msg, assert$1.notDeepEqual, true).to.not.eql(exp);
};
assert$1.isAbove = function (val, abv, msg) {
  new Assertion(val, msg, assert$1.isAbove, true).to.be.above(abv);
};
assert$1.isAtLeast = function (val, atlst, msg) {
  new Assertion(val, msg, assert$1.isAtLeast, true).to.be.least(atlst);
};
assert$1.isBelow = function (val, blw, msg) {
  new Assertion(val, msg, assert$1.isBelow, true).to.be.below(blw);
};
assert$1.isAtMost = function (val, atmst, msg) {
  new Assertion(val, msg, assert$1.isAtMost, true).to.be.most(atmst);
};
assert$1.isTrue = function (val, msg) {
  new Assertion(val, msg, assert$1.isTrue, true).is["true"];
};
assert$1.isNotTrue = function (val, msg) {
  new Assertion(val, msg, assert$1.isNotTrue, true).to.not.equal(true);
};
assert$1.isFalse = function (val, msg) {
  new Assertion(val, msg, assert$1.isFalse, true).is["false"];
};
assert$1.isNotFalse = function (val, msg) {
  new Assertion(val, msg, assert$1.isNotFalse, true).to.not.equal(false);
};
assert$1.isNull = function (val, msg) {
  new Assertion(val, msg, assert$1.isNull, true).to.equal(null);
};
assert$1.isNotNull = function (val, msg) {
  new Assertion(val, msg, assert$1.isNotNull, true).to.not.equal(null);
};
assert$1.isNaN = function (val, msg) {
  new Assertion(val, msg, assert$1.isNaN, true).to.be.NaN;
};
assert$1.isNotNaN = function (value, message) {
  new Assertion(value, message, assert$1.isNotNaN, true).not.to.be.NaN;
};
assert$1.exists = function (val, msg) {
  new Assertion(val, msg, assert$1.exists, true).to.exist;
};
assert$1.notExists = function (val, msg) {
  new Assertion(val, msg, assert$1.notExists, true).to.not.exist;
};
assert$1.isUndefined = function (val, msg) {
  new Assertion(val, msg, assert$1.isUndefined, true).to.equal(void 0);
};
assert$1.isDefined = function (val, msg) {
  new Assertion(val, msg, assert$1.isDefined, true).to.not.equal(void 0);
};
assert$1.isCallable = function (value, message) {
  new Assertion(value, message, assert$1.isCallable, true).is.callable;
};
assert$1.isNotCallable = function (value, message) {
  new Assertion(value, message, assert$1.isNotCallable, true).is.not.callable;
};
assert$1.isObject = function (val, msg) {
  new Assertion(val, msg, assert$1.isObject, true).to.be.a("object");
};
assert$1.isNotObject = function (val, msg) {
  new Assertion(val, msg, assert$1.isNotObject, true).to.not.be.a("object");
};
assert$1.isArray = function (val, msg) {
  new Assertion(val, msg, assert$1.isArray, true).to.be.an("array");
};
assert$1.isNotArray = function (val, msg) {
  new Assertion(val, msg, assert$1.isNotArray, true).to.not.be.an("array");
};
assert$1.isString = function (val, msg) {
  new Assertion(val, msg, assert$1.isString, true).to.be.a("string");
};
assert$1.isNotString = function (val, msg) {
  new Assertion(val, msg, assert$1.isNotString, true).to.not.be.a("string");
};
assert$1.isNumber = function (val, msg) {
  new Assertion(val, msg, assert$1.isNumber, true).to.be.a("number");
};
assert$1.isNotNumber = function (val, msg) {
  new Assertion(val, msg, assert$1.isNotNumber, true).to.not.be.a("number");
};
assert$1.isNumeric = function (val, msg) {
  new Assertion(val, msg, assert$1.isNumeric, true).is.numeric;
};
assert$1.isNotNumeric = function (val, msg) {
  new Assertion(val, msg, assert$1.isNotNumeric, true).is.not.numeric;
};
assert$1.isFinite = function (val, msg) {
  new Assertion(val, msg, assert$1.isFinite, true).to.be.finite;
};
assert$1.isBoolean = function (val, msg) {
  new Assertion(val, msg, assert$1.isBoolean, true).to.be.a("boolean");
};
assert$1.isNotBoolean = function (val, msg) {
  new Assertion(val, msg, assert$1.isNotBoolean, true).to.not.be.a("boolean");
};
assert$1.typeOf = function (val, type3, msg) {
  new Assertion(val, msg, assert$1.typeOf, true).to.be.a(type3);
};
assert$1.notTypeOf = function (value, type3, message) {
  new Assertion(value, message, assert$1.notTypeOf, true).to.not.be.a(type3);
};
assert$1.instanceOf = function (val, type3, msg) {
  new Assertion(val, msg, assert$1.instanceOf, true).to.be.instanceOf(type3);
};
assert$1.notInstanceOf = function (val, type3, msg) {
  new Assertion(val, msg, assert$1.notInstanceOf, true).to.not.be.instanceOf(type3);
};
assert$1.include = function (exp, inc, msg) {
  new Assertion(exp, msg, assert$1.include, true).include(inc);
};
assert$1.notInclude = function (exp, inc, msg) {
  new Assertion(exp, msg, assert$1.notInclude, true).not.include(inc);
};
assert$1.deepInclude = function (exp, inc, msg) {
  new Assertion(exp, msg, assert$1.deepInclude, true).deep.include(inc);
};
assert$1.notDeepInclude = function (exp, inc, msg) {
  new Assertion(exp, msg, assert$1.notDeepInclude, true).not.deep.include(inc);
};
assert$1.nestedInclude = function (exp, inc, msg) {
  new Assertion(exp, msg, assert$1.nestedInclude, true).nested.include(inc);
};
assert$1.notNestedInclude = function (exp, inc, msg) {
  new Assertion(exp, msg, assert$1.notNestedInclude, true).not.nested.include(inc);
};
assert$1.deepNestedInclude = function (exp, inc, msg) {
  new Assertion(exp, msg, assert$1.deepNestedInclude, true).deep.nested.include(inc);
};
assert$1.notDeepNestedInclude = function (exp, inc, msg) {
  new Assertion(exp, msg, assert$1.notDeepNestedInclude, true).not.deep.nested.include(inc);
};
assert$1.ownInclude = function (exp, inc, msg) {
  new Assertion(exp, msg, assert$1.ownInclude, true).own.include(inc);
};
assert$1.notOwnInclude = function (exp, inc, msg) {
  new Assertion(exp, msg, assert$1.notOwnInclude, true).not.own.include(inc);
};
assert$1.deepOwnInclude = function (exp, inc, msg) {
  new Assertion(exp, msg, assert$1.deepOwnInclude, true).deep.own.include(inc);
};
assert$1.notDeepOwnInclude = function (exp, inc, msg) {
  new Assertion(exp, msg, assert$1.notDeepOwnInclude, true).not.deep.own.include(inc);
};
assert$1.match = function (exp, re, msg) {
  new Assertion(exp, msg, assert$1.match, true).to.match(re);
};
assert$1.notMatch = function (exp, re, msg) {
  new Assertion(exp, msg, assert$1.notMatch, true).to.not.match(re);
};
assert$1.property = function (obj, prop, msg) {
  new Assertion(obj, msg, assert$1.property, true).to.have.property(prop);
};
assert$1.notProperty = function (obj, prop, msg) {
  new Assertion(obj, msg, assert$1.notProperty, true).to.not.have.property(prop);
};
assert$1.propertyVal = function (obj, prop, val, msg) {
  new Assertion(obj, msg, assert$1.propertyVal, true).to.have.property(prop, val);
};
assert$1.notPropertyVal = function (obj, prop, val, msg) {
  new Assertion(obj, msg, assert$1.notPropertyVal, true).to.not.have.property(prop, val);
};
assert$1.deepPropertyVal = function (obj, prop, val, msg) {
  new Assertion(obj, msg, assert$1.deepPropertyVal, true).to.have.deep.property(prop, val);
};
assert$1.notDeepPropertyVal = function (obj, prop, val, msg) {
  new Assertion(obj, msg, assert$1.notDeepPropertyVal, true).to.not.have.deep.property(prop, val);
};
assert$1.ownProperty = function (obj, prop, msg) {
  new Assertion(obj, msg, assert$1.ownProperty, true).to.have.own.property(prop);
};
assert$1.notOwnProperty = function (obj, prop, msg) {
  new Assertion(obj, msg, assert$1.notOwnProperty, true).to.not.have.own.property(prop);
};
assert$1.ownPropertyVal = function (obj, prop, value, msg) {
  new Assertion(obj, msg, assert$1.ownPropertyVal, true).to.have.own.property(prop, value);
};
assert$1.notOwnPropertyVal = function (obj, prop, value, msg) {
  new Assertion(obj, msg, assert$1.notOwnPropertyVal, true).to.not.have.own.property(prop, value);
};
assert$1.deepOwnPropertyVal = function (obj, prop, value, msg) {
  new Assertion(obj, msg, assert$1.deepOwnPropertyVal, true).to.have.deep.own.property(prop, value);
};
assert$1.notDeepOwnPropertyVal = function (obj, prop, value, msg) {
  new Assertion(obj, msg, assert$1.notDeepOwnPropertyVal, true).to.not.have.deep.own.property(prop, value);
};
assert$1.nestedProperty = function (obj, prop, msg) {
  new Assertion(obj, msg, assert$1.nestedProperty, true).to.have.nested.property(prop);
};
assert$1.notNestedProperty = function (obj, prop, msg) {
  new Assertion(obj, msg, assert$1.notNestedProperty, true).to.not.have.nested.property(prop);
};
assert$1.nestedPropertyVal = function (obj, prop, val, msg) {
  new Assertion(obj, msg, assert$1.nestedPropertyVal, true).to.have.nested.property(prop, val);
};
assert$1.notNestedPropertyVal = function (obj, prop, val, msg) {
  new Assertion(obj, msg, assert$1.notNestedPropertyVal, true).to.not.have.nested.property(prop, val);
};
assert$1.deepNestedPropertyVal = function (obj, prop, val, msg) {
  new Assertion(obj, msg, assert$1.deepNestedPropertyVal, true).to.have.deep.nested.property(prop, val);
};
assert$1.notDeepNestedPropertyVal = function (obj, prop, val, msg) {
  new Assertion(obj, msg, assert$1.notDeepNestedPropertyVal, true).to.not.have.deep.nested.property(prop, val);
};
assert$1.lengthOf = function (exp, len, msg) {
  new Assertion(exp, msg, assert$1.lengthOf, true).to.have.lengthOf(len);
};
assert$1.hasAnyKeys = function (obj, keys, msg) {
  new Assertion(obj, msg, assert$1.hasAnyKeys, true).to.have.any.keys(keys);
};
assert$1.hasAllKeys = function (obj, keys, msg) {
  new Assertion(obj, msg, assert$1.hasAllKeys, true).to.have.all.keys(keys);
};
assert$1.containsAllKeys = function (obj, keys, msg) {
  new Assertion(obj, msg, assert$1.containsAllKeys, true).to.contain.all.keys(keys);
};
assert$1.doesNotHaveAnyKeys = function (obj, keys, msg) {
  new Assertion(obj, msg, assert$1.doesNotHaveAnyKeys, true).to.not.have.any.keys(keys);
};
assert$1.doesNotHaveAllKeys = function (obj, keys, msg) {
  new Assertion(obj, msg, assert$1.doesNotHaveAllKeys, true).to.not.have.all.keys(keys);
};
assert$1.hasAnyDeepKeys = function (obj, keys, msg) {
  new Assertion(obj, msg, assert$1.hasAnyDeepKeys, true).to.have.any.deep.keys(keys);
};
assert$1.hasAllDeepKeys = function (obj, keys, msg) {
  new Assertion(obj, msg, assert$1.hasAllDeepKeys, true).to.have.all.deep.keys(keys);
};
assert$1.containsAllDeepKeys = function (obj, keys, msg) {
  new Assertion(obj, msg, assert$1.containsAllDeepKeys, true).to.contain.all.deep.keys(keys);
};
assert$1.doesNotHaveAnyDeepKeys = function (obj, keys, msg) {
  new Assertion(obj, msg, assert$1.doesNotHaveAnyDeepKeys, true).to.not.have.any.deep.keys(keys);
};
assert$1.doesNotHaveAllDeepKeys = function (obj, keys, msg) {
  new Assertion(obj, msg, assert$1.doesNotHaveAllDeepKeys, true).to.not.have.all.deep.keys(keys);
};
assert$1.throws = function (fn, errorLike, errMsgMatcher, msg) {
  if ("string" === typeof errorLike || errorLike instanceof RegExp) {
    errMsgMatcher = errorLike;
    errorLike = null;
  }
  var assertErr = new Assertion(fn, msg, assert$1.throws, true).to.throw(errorLike, errMsgMatcher);
  return _flag(assertErr, "object");
};
assert$1.doesNotThrow = function (fn, errorLike, errMsgMatcher, message) {
  if ("string" === typeof errorLike || errorLike instanceof RegExp) {
    errMsgMatcher = errorLike;
    errorLike = null;
  }
  new Assertion(fn, message, assert$1.doesNotThrow, true).to.not.throw(errorLike, errMsgMatcher);
};
assert$1.operator = function (val, operator, val2, msg) {
  var ok;
  switch (operator) {
    case "==":
      ok = val == val2;
      break;
    case "===":
      ok = val === val2;
      break;
    case ">":
      ok = val > val2;
      break;
    case ">=":
      ok = val >= val2;
      break;
    case "<":
      ok = val < val2;
      break;
    case "<=":
      ok = val <= val2;
      break;
    case "!=":
      ok = val != val2;
      break;
    case "!==":
      ok = val !== val2;
      break;
    default:
      msg = msg ? msg + ": " : msg;
      throw new AssertionError(msg + 'Invalid operator "' + operator + '"', void 0, assert$1.operator);
  }
  var test2 = new Assertion(ok, msg, assert$1.operator, true);
  test2.assert(true === _flag(test2, "object"), "expected " + inspect2(val) + " to be " + operator + " " + inspect2(val2), "expected " + inspect2(val) + " to not be " + operator + " " + inspect2(val2));
};
assert$1.closeTo = function (act, exp, delta, msg) {
  new Assertion(act, msg, assert$1.closeTo, true).to.be.closeTo(exp, delta);
};
assert$1.approximately = function (act, exp, delta, msg) {
  new Assertion(act, msg, assert$1.approximately, true).to.be.approximately(exp, delta);
};
assert$1.sameMembers = function (set1, set2, msg) {
  new Assertion(set1, msg, assert$1.sameMembers, true).to.have.same.members(set2);
};
assert$1.notSameMembers = function (set1, set2, msg) {
  new Assertion(set1, msg, assert$1.notSameMembers, true).to.not.have.same.members(set2);
};
assert$1.sameDeepMembers = function (set1, set2, msg) {
  new Assertion(set1, msg, assert$1.sameDeepMembers, true).to.have.same.deep.members(set2);
};
assert$1.notSameDeepMembers = function (set1, set2, msg) {
  new Assertion(set1, msg, assert$1.notSameDeepMembers, true).to.not.have.same.deep.members(set2);
};
assert$1.sameOrderedMembers = function (set1, set2, msg) {
  new Assertion(set1, msg, assert$1.sameOrderedMembers, true).to.have.same.ordered.members(set2);
};
assert$1.notSameOrderedMembers = function (set1, set2, msg) {
  new Assertion(set1, msg, assert$1.notSameOrderedMembers, true).to.not.have.same.ordered.members(set2);
};
assert$1.sameDeepOrderedMembers = function (set1, set2, msg) {
  new Assertion(set1, msg, assert$1.sameDeepOrderedMembers, true).to.have.same.deep.ordered.members(set2);
};
assert$1.notSameDeepOrderedMembers = function (set1, set2, msg) {
  new Assertion(set1, msg, assert$1.notSameDeepOrderedMembers, true).to.not.have.same.deep.ordered.members(set2);
};
assert$1.includeMembers = function (superset, subset, msg) {
  new Assertion(superset, msg, assert$1.includeMembers, true).to.include.members(subset);
};
assert$1.notIncludeMembers = function (superset, subset, msg) {
  new Assertion(superset, msg, assert$1.notIncludeMembers, true).to.not.include.members(subset);
};
assert$1.includeDeepMembers = function (superset, subset, msg) {
  new Assertion(superset, msg, assert$1.includeDeepMembers, true).to.include.deep.members(subset);
};
assert$1.notIncludeDeepMembers = function (superset, subset, msg) {
  new Assertion(superset, msg, assert$1.notIncludeDeepMembers, true).to.not.include.deep.members(subset);
};
assert$1.includeOrderedMembers = function (superset, subset, msg) {
  new Assertion(superset, msg, assert$1.includeOrderedMembers, true).to.include.ordered.members(subset);
};
assert$1.notIncludeOrderedMembers = function (superset, subset, msg) {
  new Assertion(superset, msg, assert$1.notIncludeOrderedMembers, true).to.not.include.ordered.members(subset);
};
assert$1.includeDeepOrderedMembers = function (superset, subset, msg) {
  new Assertion(superset, msg, assert$1.includeDeepOrderedMembers, true).to.include.deep.ordered.members(subset);
};
assert$1.notIncludeDeepOrderedMembers = function (superset, subset, msg) {
  new Assertion(superset, msg, assert$1.notIncludeDeepOrderedMembers, true).to.not.include.deep.ordered.members(subset);
};
assert$1.oneOf = function (inList, list, msg) {
  new Assertion(inList, msg, assert$1.oneOf, true).to.be.oneOf(list);
};
assert$1.isIterable = function (obj, msg) {
  if (obj == void 0 || !obj[Symbol.iterator]) {
    msg = msg ? "".concat(msg, " expected ").concat(inspect2(obj), " to be an iterable") : "expected ".concat(inspect2(obj), " to be an iterable");
    throw new AssertionError(msg, void 0, assert$1.isIterable);
  }
};
assert$1.changes = function (fn, obj, prop, msg) {
  if (arguments.length === 3 && typeof obj === "function") {
    msg = prop;
    prop = null;
  }
  new Assertion(fn, msg, assert$1.changes, true).to.change(obj, prop);
};
assert$1.changesBy = function (fn, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj === "function") {
    var tmpMsg = delta;
    delta = prop;
    msg = tmpMsg;
  } else if (arguments.length === 3) {
    delta = prop;
    prop = null;
  }
  new Assertion(fn, msg, assert$1.changesBy, true).to.change(obj, prop).by(delta);
};
assert$1.doesNotChange = function (fn, obj, prop, msg) {
  if (arguments.length === 3 && typeof obj === "function") {
    msg = prop;
    prop = null;
  }
  return new Assertion(fn, msg, assert$1.doesNotChange, true).to.not.change(obj, prop);
};
assert$1.changesButNotBy = function (fn, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj === "function") {
    var tmpMsg = delta;
    delta = prop;
    msg = tmpMsg;
  } else if (arguments.length === 3) {
    delta = prop;
    prop = null;
  }
  new Assertion(fn, msg, assert$1.changesButNotBy, true).to.change(obj, prop).but.not.by(delta);
};
assert$1.increases = function (fn, obj, prop, msg) {
  if (arguments.length === 3 && typeof obj === "function") {
    msg = prop;
    prop = null;
  }
  return new Assertion(fn, msg, assert$1.increases, true).to.increase(obj, prop);
};
assert$1.increasesBy = function (fn, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj === "function") {
    var tmpMsg = delta;
    delta = prop;
    msg = tmpMsg;
  } else if (arguments.length === 3) {
    delta = prop;
    prop = null;
  }
  new Assertion(fn, msg, assert$1.increasesBy, true).to.increase(obj, prop).by(delta);
};
assert$1.doesNotIncrease = function (fn, obj, prop, msg) {
  if (arguments.length === 3 && typeof obj === "function") {
    msg = prop;
    prop = null;
  }
  return new Assertion(fn, msg, assert$1.doesNotIncrease, true).to.not.increase(obj, prop);
};
assert$1.increasesButNotBy = function (fn, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj === "function") {
    var tmpMsg = delta;
    delta = prop;
    msg = tmpMsg;
  } else if (arguments.length === 3) {
    delta = prop;
    prop = null;
  }
  new Assertion(fn, msg, assert$1.increasesButNotBy, true).to.increase(obj, prop).but.not.by(delta);
};
assert$1.decreases = function (fn, obj, prop, msg) {
  if (arguments.length === 3 && typeof obj === "function") {
    msg = prop;
    prop = null;
  }
  return new Assertion(fn, msg, assert$1.decreases, true).to.decrease(obj, prop);
};
assert$1.decreasesBy = function (fn, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj === "function") {
    var tmpMsg = delta;
    delta = prop;
    msg = tmpMsg;
  } else if (arguments.length === 3) {
    delta = prop;
    prop = null;
  }
  new Assertion(fn, msg, assert$1.decreasesBy, true).to.decrease(obj, prop).by(delta);
};
assert$1.doesNotDecrease = function (fn, obj, prop, msg) {
  if (arguments.length === 3 && typeof obj === "function") {
    msg = prop;
    prop = null;
  }
  return new Assertion(fn, msg, assert$1.doesNotDecrease, true).to.not.decrease(obj, prop);
};
assert$1.doesNotDecreaseBy = function (fn, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj === "function") {
    var tmpMsg = delta;
    delta = prop;
    msg = tmpMsg;
  } else if (arguments.length === 3) {
    delta = prop;
    prop = null;
  }
  return new Assertion(fn, msg, assert$1.doesNotDecreaseBy, true).to.not.decrease(obj, prop).by(delta);
};
assert$1.decreasesButNotBy = function (fn, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj === "function") {
    var tmpMsg = delta;
    delta = prop;
    msg = tmpMsg;
  } else if (arguments.length === 3) {
    delta = prop;
    prop = null;
  }
  new Assertion(fn, msg, assert$1.decreasesButNotBy, true).to.decrease(obj, prop).but.not.by(delta);
};
assert$1.ifError = function (val) {
  if (val) {
    throw val;
  }
};
assert$1.isExtensible = function (obj, msg) {
  new Assertion(obj, msg, assert$1.isExtensible, true).to.be.extensible;
};
assert$1.isNotExtensible = function (obj, msg) {
  new Assertion(obj, msg, assert$1.isNotExtensible, true).to.not.be.extensible;
};
assert$1.isSealed = function (obj, msg) {
  new Assertion(obj, msg, assert$1.isSealed, true).to.be.sealed;
};
assert$1.isNotSealed = function (obj, msg) {
  new Assertion(obj, msg, assert$1.isNotSealed, true).to.not.be.sealed;
};
assert$1.isFrozen = function (obj, msg) {
  new Assertion(obj, msg, assert$1.isFrozen, true).to.be.frozen;
};
assert$1.isNotFrozen = function (obj, msg) {
  new Assertion(obj, msg, assert$1.isNotFrozen, true).to.not.be.frozen;
};
assert$1.isEmpty = function (val, msg) {
  new Assertion(val, msg, assert$1.isEmpty, true).to.be.empty;
};
assert$1.isNotEmpty = function (val, msg) {
  new Assertion(val, msg, assert$1.isNotEmpty, true).to.not.be.empty;
};
assert$1.containsSubset = function (val, exp, msg) {
  new Assertion(val, msg).to.containSubset(exp);
};
assert$1.doesNotContainSubset = function (val, exp, msg) {
  new Assertion(val, msg).to.not.containSubset(exp);
};
var aliases = [["isOk", "ok"], ["isNotOk", "notOk"], ["throws", "throw"], ["throws", "Throw"], ["isExtensible", "extensible"], ["isNotExtensible", "notExtensible"], ["isSealed", "sealed"], ["isNotSealed", "notSealed"], ["isFrozen", "frozen"], ["isNotFrozen", "notFrozen"], ["isEmpty", "empty"], ["isNotEmpty", "notEmpty"], ["isCallable", "isFunction"], ["isNotCallable", "isNotFunction"], ["containsSubset", "containSubset"]];
for (var _i2$1 = 0, _aliases = aliases; _i2$1 < _aliases.length; _i2$1++) {
  var _aliases$_i = _slicedToArray(_aliases[_i2$1], 2),
    name = _aliases$_i[0],
    as = _aliases$_i[1];
  assert$1[as] = assert$1[name];
}

// lib/chai.js
var used = [];
function use(fn) {
  var exports = _objectSpread$4({
    use: use,
    AssertionError: AssertionError,
    util: utils_exports,
    config: config,
    expect: expect,
    assert: assert$1,
    Assertion: Assertion
  }, should_exports);
  if (!~used.indexOf(fn)) {
    fn(exports, utils_exports);
    used.push(fn);
  }
  return exports;
}
__name(use, "use");
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - expectTypes utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - isProxyEnabled helper
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addLengthGuard utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - proxify utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - compareByInspect utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getOwnEnumerablePropertySymbols utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getOwnEnumerableProperties utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - isNaN utility
 * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>
 * MIT Licensed
 */
/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*! Bundled license information:

deep-eql/index.js:
  (*!
   * deep-eql
   * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Check to see if the MemoizeMap has recorded a result of the two operands
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {MemoizeMap} memoizeMap
   * @returns {Boolean|null} result
  *)
  (*!
   * Set the result of the equality into the MemoizeMap
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {MemoizeMap} memoizeMap
   * @param {Boolean} result
  *)
  (*!
   * Primary Export
   *)
  (*!
   * The main logic of the `deepEqual` function.
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Object} [options] (optional) Additional options
   * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
   * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
      complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
      references to blow the stack.
   * @return {Boolean} equal match
  *)
  (*!
   * Compare two Regular Expressions for equality.
   *
   * @param {RegExp} leftHandOperand
   * @param {RegExp} rightHandOperand
   * @return {Boolean} result
   *)
  (*!
   * Compare two Sets/Maps for equality. Faster than other equality functions.
   *
   * @param {Set} leftHandOperand
   * @param {Set} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
   *
   * @param {Iterable} leftHandOperand
   * @param {Iterable} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Simple equality for generator objects such as those returned by generator functions.
   *
   * @param {Iterable} leftHandOperand
   * @param {Iterable} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Determine if the given object has an @@iterator function.
   *
   * @param {Object} target
   * @return {Boolean} `true` if the object has an @@iterator function.
   *)
  (*!
   * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
   * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
   *
   * @param {Object} target
   * @returns {Array} an array of entries from the @@iterator function
   *)
  (*!
   * Gets all entries from a Generator. This will consume the generator - which could have side effects.
   *
   * @param {Generator} target
   * @returns {Array} an array of entries from the Generator.
   *)
  (*!
   * Gets all own and inherited enumerable keys from a target.
   *
   * @param {Object} target
   * @returns {Array} an array of own and inherited enumerable keys from the target.
   *)
  (*!
   * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
   * each key. If any value of the given key is not equal, the function will return false (early).
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
   * for each enumerable key in the object.
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Returns true if the argument is a primitive.
   *
   * This intentionally returns true for all objects that can be compared by reference,
   * including functions and symbols.
   *
   * @param {Mixed} value
   * @return {Boolean} result
   *)
*/

function _callSuper$4(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$4() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$4() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$4 = function _isNativeReflectConstruct() { return !!t; })(); }
function _createForOfIteratorHelper$5(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$5(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray$5(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray$5(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$5(r, a) : void 0; } }
function _arrayLikeToArray$5(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys$3(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$3(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$3(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var MATCHERS_OBJECT = Symbol.for("matchers-object");
var JEST_MATCHERS_OBJECT = Symbol.for("$$jest-matchers-object");
var GLOBAL_EXPECT = Symbol.for("expect-global");
var ASYMMETRIC_MATCHERS_OBJECT = Symbol.for("asymmetric-matchers-object");

// selectively ported from https://github.com/jest-community/jest-extended
var customMatchers = {
  toSatisfy: function toSatisfy(actual, expected, _message) {
    var _this$utils = this.utils,
      printReceived = _this$utils.printReceived,
      printExpected = _this$utils.printExpected,
      matcherHint = _this$utils.matcherHint;
    var pass = expected(actual);
    return {
      pass: pass,
      message: function message() {
        return pass ? "".concat(matcherHint(".not.toSatisfy", "received", ""), "\n\nExpected value to not satisfy:\n").concat(_message || printExpected(expected), "\nReceived:\n").concat(printReceived(actual)) : "".concat(matcherHint(".toSatisfy", "received", ""), "\n\nExpected value to satisfy:\n").concat(_message || printExpected(expected), "\n\nReceived:\n").concat(printReceived(actual));
      }
    };
  },
  toBeOneOf: function toBeOneOf(actual, expected) {
    var equals = this.equals,
      customTesters = this.customTesters;
    var _this$utils2 = this.utils,
      printReceived = _this$utils2.printReceived,
      printExpected = _this$utils2.printExpected,
      matcherHint = _this$utils2.matcherHint;
    if (!Array.isArray(expected)) {
      throw new TypeError("You must provide an array to ".concat(matcherHint(".toBeOneOf"), ", not '").concat(_typeof(expected), "'."));
    }
    var pass = expected.length === 0 || expected.some(function (item) {
      return equals(item, actual, customTesters);
    });
    return {
      pass: pass,
      message: function message() {
        return pass ? "".concat(matcherHint(".not.toBeOneOf", "received", ""), "\n\nExpected value to not be one of:\n").concat(printExpected(expected), "\nReceived:\n").concat(printReceived(actual)) : "".concat(matcherHint(".toBeOneOf", "received", ""), "\n\nExpected value to be one of:\n").concat(printExpected(expected), "\n\nReceived:\n").concat(printReceived(actual));
      }
    };
  }
};
var EXPECTED_COLOR = s.green;
var RECEIVED_COLOR = s.red;
var INVERTED_COLOR = s.inverse;
var BOLD_WEIGHT = s.bold;
var DIM_COLOR = s.dim;
function matcherHint(matcherName) {
  var received = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "received";
  var expected = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "expected";
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var _options$comment = options.comment,
    comment = _options$comment === void 0 ? "" : _options$comment,
    _options$isDirectExpe = options.isDirectExpectCall,
    isDirectExpectCall = _options$isDirectExpe === void 0 ? false : _options$isDirectExpe,
    _options$isNot = options.isNot,
    isNot = _options$isNot === void 0 ? false : _options$isNot,
    _options$promise = options.promise,
    promise = _options$promise === void 0 ? "" : _options$promise,
    _options$secondArgume = options.secondArgument,
    secondArgument = _options$secondArgume === void 0 ? "" : _options$secondArgume,
    _options$expectedColo = options.expectedColor,
    expectedColor = _options$expectedColo === void 0 ? EXPECTED_COLOR : _options$expectedColo,
    _options$receivedColo = options.receivedColor,
    receivedColor = _options$receivedColo === void 0 ? RECEIVED_COLOR : _options$receivedColo,
    _options$secondArgume2 = options.secondArgumentColor,
    secondArgumentColor = _options$secondArgume2 === void 0 ? EXPECTED_COLOR : _options$secondArgume2;
  var hint = "";
  var dimString = "expect";
  if (!isDirectExpectCall && received !== "") {
    hint += DIM_COLOR("".concat(dimString, "(")) + receivedColor(received);
    dimString = ")";
  }
  if (promise !== "") {
    hint += DIM_COLOR("".concat(dimString, ".")) + promise;
    dimString = "";
  }
  if (isNot) {
    hint += "".concat(DIM_COLOR("".concat(dimString, ".")), "not");
    dimString = "";
  }
  if (matcherName.includes(".")) {
    // Old format: for backward compatibility,
    // especially without promise or isNot options
    dimString += matcherName;
  } else {
    // New format: omit period from matcherName arg
    hint += DIM_COLOR("".concat(dimString, ".")) + matcherName;
    dimString = "";
  }
  if (expected === "") {
    dimString += "()";
  } else {
    hint += DIM_COLOR("".concat(dimString, "(")) + expectedColor(expected);
    if (secondArgument) {
      hint += DIM_COLOR(", ") + secondArgumentColor(secondArgument);
    }
    dimString = ")";
  }
  if (comment !== "") {
    dimString += " // ".concat(comment);
  }
  if (dimString !== "") {
    hint += DIM_COLOR(dimString);
  }
  return hint;
}
var SPACE_SYMBOL = "·";
// Instead of inverse highlight which now implies a change,
// replace common spaces with middle dot at the end of any line.
function replaceTrailingSpaces(text) {
  return text.replace(/\s+$/gm, function (spaces) {
    return SPACE_SYMBOL.repeat(spaces.length);
  });
}
function printReceived(object) {
  return RECEIVED_COLOR(replaceTrailingSpaces(stringify(object)));
}
function printExpected(value) {
  return EXPECTED_COLOR(replaceTrailingSpaces(stringify(value)));
}
function getMatcherUtils() {
  return {
    EXPECTED_COLOR: EXPECTED_COLOR,
    RECEIVED_COLOR: RECEIVED_COLOR,
    INVERTED_COLOR: INVERTED_COLOR,
    BOLD_WEIGHT: BOLD_WEIGHT,
    DIM_COLOR: DIM_COLOR,
    diff: diff,
    matcherHint: matcherHint,
    printReceived: printReceived,
    printExpected: printExpected,
    printDiffOrStringify: printDiffOrStringify,
    printWithType: printWithType
  };
}
function printWithType(name, value, print) {
  var type = getType$1(value);
  var hasType = type !== "null" && type !== "undefined" ? "".concat(name, " has type:  ").concat(type, "\n") : "";
  var hasValue = "".concat(name, " has value: ").concat(print(value));
  return hasType + hasValue;
}
function addCustomEqualityTesters(newTesters) {
  var _globalThis$JEST_MATC;
  if (!Array.isArray(newTesters)) {
    throw new TypeError("expect.customEqualityTesters: Must be set to an array of Testers. Was given \"".concat(getType$1(newTesters), "\""));
  }
  (_globalThis$JEST_MATC = globalThis[JEST_MATCHERS_OBJECT].customEqualityTesters).push.apply(_globalThis$JEST_MATC, _toConsumableArray(newTesters));
}
function getCustomEqualityTesters() {
  return globalThis[JEST_MATCHERS_OBJECT].customEqualityTesters;
}

// Extracted out of jasmine 2.5.2
function equals(a, b, customTesters, strictCheck) {
  customTesters = customTesters || [];
  return eq(a, b, [], [], customTesters, strictCheck ? hasKey : hasDefinedKey);
}
function isAsymmetric(obj) {
  return !!obj && _typeof(obj) === "object" && "asymmetricMatch" in obj && isA("Function", obj.asymmetricMatch);
}
function asymmetricMatch(a, b) {
  var asymmetricA = isAsymmetric(a);
  var asymmetricB = isAsymmetric(b);
  if (asymmetricA && asymmetricB) {
    return undefined;
  }
  if (asymmetricA) {
    return a.asymmetricMatch(b);
  }
  if (asymmetricB) {
    return b.asymmetricMatch(a);
  }
}
// Equality function lovingly adapted from isEqual in
//   [Underscore](http://underscorejs.org)
function eq(a, b, aStack, bStack, customTesters, hasKey) {
  var result = true;
  var asymmetricResult = asymmetricMatch(a, b);
  if (asymmetricResult !== undefined) {
    return asymmetricResult;
  }
  var testerContext = {
    equals: equals
  };
  for (var i = 0; i < customTesters.length; i++) {
    var customTesterResult = customTesters[i].call(testerContext, a, b, customTesters);
    if (customTesterResult !== undefined) {
      return customTesterResult;
    }
  }
  if (typeof URL === "function" && a instanceof URL && b instanceof URL) {
    return a.href === b.href;
  }
  if (Object.is(a, b)) {
    return true;
  }
  // A strict comparison is necessary because `null == undefined`.
  if (a === null || b === null) {
    return a === b;
  }
  var className = Object.prototype.toString.call(a);
  if (className !== Object.prototype.toString.call(b)) {
    return false;
  }
  switch (className) {
    case "[object Boolean]":
    case "[object String]":
    case "[object Number]":
      if (_typeof(a) !== _typeof(b)) {
        // One is a primitive, one a `new Primitive()`
        return false;
      } else if (_typeof(a) !== "object" && _typeof(b) !== "object") {
        // both are proper primitives
        return Object.is(a, b);
      } else {
        // both are `new Primitive()`s
        return Object.is(a.valueOf(), b.valueOf());
      }
    case "[object Date]":
      {
        var numA = +a;
        var numB = +b;
        // Coerce dates to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are equivalent.
        return numA === numB || Number.isNaN(numA) && Number.isNaN(numB);
      }
    case "[object RegExp]":
      return a.source === b.source && a.flags === b.flags;
    case "[object Temporal.Instant]":
    case "[object Temporal.ZonedDateTime]":
    case "[object Temporal.PlainDateTime]":
    case "[object Temporal.PlainDate]":
    case "[object Temporal.PlainTime]":
    case "[object Temporal.PlainYearMonth]":
    case "[object Temporal.PlainMonthDay]":
      return a.equals(b);
    case "[object Temporal.Duration]":
      return a.toString() === b.toString();
  }
  if (_typeof(a) !== "object" || _typeof(b) !== "object") {
    return false;
  }
  // Use DOM3 method isEqualNode (IE>=9)
  if (isDomNode(a) && isDomNode(b)) {
    return a.isEqualNode(b);
  }
  // Used to detect circular references.
  var length = aStack.length;
  while (length--) {
    // Linear search. Performance is inversely proportional to the number of
    // unique nested structures.
    // circular references at same depth are equal
    // circular reference is not equal to non-circular one
    if (aStack[length] === a) {
      return bStack[length] === b;
    } else if (bStack[length] === b) {
      return false;
    }
  }
  // Add the first object to the stack of traversed objects.
  aStack.push(a);
  bStack.push(b);
  // Recursively compare objects and arrays.
  // Compare array lengths to determine if a deep comparison is necessary.
  if (className === "[object Array]" && a.length !== b.length) {
    return false;
  }
  if (a instanceof Error && b instanceof Error) {
    try {
      return isErrorEqual(a, b, aStack, bStack, customTesters, hasKey);
    } finally {
      aStack.pop();
      bStack.pop();
    }
  }
  // Deep compare objects.
  var aKeys = keys(a, hasKey);
  var key;
  var size = aKeys.length;
  // Ensure that both objects contain the same number of properties before comparing deep equality.
  if (keys(b, hasKey).length !== size) {
    return false;
  }
  while (size--) {
    key = aKeys[size];
    // Deep compare each member
    result = hasKey(b, key) && eq(a[key], b[key], aStack, bStack, customTesters, hasKey);
    if (!result) {
      return false;
    }
  }
  // Remove the first object from the stack of traversed objects.
  aStack.pop();
  bStack.pop();
  return result;
}
function isErrorEqual(a, b, aStack, bStack, customTesters, hasKey) {
  // https://nodejs.org/docs/latest-v22.x/api/assert.html#comparison-details
  // - [[Prototype]] of objects are compared using the === operator.
  // - Only enumerable "own" properties are considered.
  // - Error names, messages, causes, and errors are always compared, even if these are not enumerable properties. errors is also compared.
  var result = Object.getPrototypeOf(a) === Object.getPrototypeOf(b) && a.name === b.name && a.message === b.message;
  // check Error.cause asymmetrically
  if (typeof b.cause !== "undefined") {
    result && (result = eq(a.cause, b.cause, aStack, bStack, customTesters, hasKey));
  }
  // AggregateError.errors
  if (a instanceof AggregateError && b instanceof AggregateError) {
    result && (result = eq(a.errors, b.errors, aStack, bStack, customTesters, hasKey));
  }
  // spread to compare enumerable properties
  result && (result = eq(_objectSpread$3({}, a), _objectSpread$3({}, b), aStack, bStack, customTesters, hasKey));
  return result;
}
function keys(obj, hasKey) {
  var keys = [];
  for (var key in obj) {
    if (hasKey(obj, key)) {
      keys.push(key);
    }
  }
  return keys.concat(Object.getOwnPropertySymbols(obj).filter(function (symbol) {
    return Object.getOwnPropertyDescriptor(obj, symbol).enumerable;
  }));
}
function hasDefinedKey(obj, key) {
  return hasKey(obj, key) && obj[key] !== undefined;
}
function hasKey(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function isA(typeName, value) {
  return Object.prototype.toString.apply(value) === "[object ".concat(typeName, "]");
}
function isDomNode(obj) {
  return obj !== null && _typeof(obj) === "object" && "nodeType" in obj && typeof obj.nodeType === "number" && "nodeName" in obj && typeof obj.nodeName === "string" && "isEqualNode" in obj && typeof obj.isEqualNode === "function";
}
// SENTINEL constants are from https://github.com/facebook/immutable-js
var IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@";
var IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@";
var IS_LIST_SENTINEL = "@@__IMMUTABLE_LIST__@@";
var IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@";
var IS_RECORD_SYMBOL = "@@__IMMUTABLE_RECORD__@@";
function isImmutableUnorderedKeyed(maybeKeyed) {
  return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL] && !maybeKeyed[IS_ORDERED_SENTINEL]);
}
function isImmutableUnorderedSet(maybeSet) {
  return !!(maybeSet && maybeSet[IS_SET_SENTINEL] && !maybeSet[IS_ORDERED_SENTINEL]);
}
function isObjectLiteral(source) {
  return source != null && _typeof(source) === "object" && !Array.isArray(source);
}
function isImmutableList(source) {
  return Boolean(source && isObjectLiteral(source) && source[IS_LIST_SENTINEL]);
}
function isImmutableOrderedKeyed(source) {
  return Boolean(source && isObjectLiteral(source) && source[IS_KEYED_SENTINEL] && source[IS_ORDERED_SENTINEL]);
}
function isImmutableOrderedSet(source) {
  return Boolean(source && isObjectLiteral(source) && source[IS_SET_SENTINEL] && source[IS_ORDERED_SENTINEL]);
}
function isImmutableRecord(source) {
  return Boolean(source && isObjectLiteral(source) && source[IS_RECORD_SYMBOL]);
}
/**
* Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*
*/
var IteratorSymbol = Symbol.iterator;
function hasIterator(object) {
  return !!(object != null && object[IteratorSymbol]);
}
function iterableEquality(a, b) {
  var customTesters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var aStack = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  var bStack = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
  if (_typeof(a) !== "object" || _typeof(b) !== "object" || Array.isArray(a) || Array.isArray(b) || !hasIterator(a) || !hasIterator(b)) {
    return undefined;
  }
  if (a.constructor !== b.constructor) {
    return false;
  }
  var length = aStack.length;
  while (length--) {
    // Linear search. Performance is inversely proportional to the number of
    // unique nested structures.
    // circular references at same depth are equal
    // circular reference is not equal to non-circular one
    if (aStack[length] === a) {
      return bStack[length] === b;
    }
  }
  aStack.push(a);
  bStack.push(b);
  var filteredCustomTesters = [].concat(_toConsumableArray(customTesters.filter(function (t) {
    return t !== iterableEquality;
  })), [iterableEqualityWithStack]);
  function iterableEqualityWithStack(a, b) {
    return iterableEquality(a, b, _toConsumableArray(customTesters), _toConsumableArray(aStack), _toConsumableArray(bStack));
  }
  if (a.size !== undefined) {
    if (a.size !== b.size) {
      return false;
    } else if (isA("Set", a) || isImmutableUnorderedSet(a)) {
      var allFound = true;
      var _iterator = _createForOfIteratorHelper$5(a),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var aValue = _step.value;
          if (!b.has(aValue)) {
            var has = false;
            var _iterator2 = _createForOfIteratorHelper$5(b),
              _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var bValue = _step2.value;
                var isEqual = equals(aValue, bValue, filteredCustomTesters);
                if (isEqual === true) {
                  has = true;
                }
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
            if (has === false) {
              allFound = false;
              break;
            }
          }
        }
        // Remove the first value from the stack of traversed values.
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      aStack.pop();
      bStack.pop();
      return allFound;
    } else if (isA("Map", a) || isImmutableUnorderedKeyed(a)) {
      var _allFound = true;
      var _iterator3 = _createForOfIteratorHelper$5(a),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var aEntry = _step3.value;
          if (!b.has(aEntry[0]) || !equals(aEntry[1], b.get(aEntry[0]), filteredCustomTesters)) {
            var _has = false;
            var _iterator4 = _createForOfIteratorHelper$5(b),
              _step4;
            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                var bEntry = _step4.value;
                var matchedKey = equals(aEntry[0], bEntry[0], filteredCustomTesters);
                var matchedValue = false;
                if (matchedKey === true) {
                  matchedValue = equals(aEntry[1], bEntry[1], filteredCustomTesters);
                }
                if (matchedValue === true) {
                  _has = true;
                }
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
            if (_has === false) {
              _allFound = false;
              break;
            }
          }
        }
        // Remove the first value from the stack of traversed values.
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      aStack.pop();
      bStack.pop();
      return _allFound;
    }
  }
  var bIterator = b[IteratorSymbol]();
  var _iterator5 = _createForOfIteratorHelper$5(a),
    _step5;
  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var _aValue = _step5.value;
      var nextB = bIterator.next();
      if (nextB.done || !equals(_aValue, nextB.value, filteredCustomTesters)) {
        return false;
      }
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }
  if (!bIterator.next().done) {
    return false;
  }
  if (!isImmutableList(a) && !isImmutableOrderedKeyed(a) && !isImmutableOrderedSet(a) && !isImmutableRecord(a)) {
    var aEntries = Object.entries(a);
    var bEntries = Object.entries(b);
    if (!equals(aEntries, bEntries, filteredCustomTesters)) {
      return false;
    }
  }
  // Remove the first value from the stack of traversed values.
  aStack.pop();
  bStack.pop();
  return true;
}
/**
* Checks if `hasOwnProperty(object, key)` up the prototype chain, stopping at `Object.prototype`.
*/
function hasPropertyInObject(object, key) {
  var shouldTerminate = !object || _typeof(object) !== "object" || object === Object.prototype;
  if (shouldTerminate) {
    return false;
  }
  return Object.prototype.hasOwnProperty.call(object, key) || hasPropertyInObject(Object.getPrototypeOf(object), key);
}
function isObjectWithKeys(a) {
  return isObject$1(a) && !(a instanceof Error) && !Array.isArray(a) && !(a instanceof Date);
}
function subsetEquality(object, subset) {
  var customTesters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var filteredCustomTesters = customTesters.filter(function (t) {
    return t !== subsetEquality;
  });
  // subsetEquality needs to keep track of the references
  // it has already visited to avoid infinite loops in case
  // there are circular references in the subset passed to it.
  var _subsetEqualityWithContext = function subsetEqualityWithContext() {
    var seenReferences = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new WeakMap();
    return function (object, subset) {
      if (!isObjectWithKeys(subset)) {
        return undefined;
      }
      return Object.keys(subset).every(function (key) {
        if (subset[key] != null && _typeof(subset[key]) === "object") {
          if (seenReferences.has(subset[key])) {
            return equals(object[key], subset[key], filteredCustomTesters);
          }
          seenReferences.set(subset[key], true);
        }
        var result = object != null && hasPropertyInObject(object, key) && equals(object[key], subset[key], [].concat(_toConsumableArray(filteredCustomTesters), [_subsetEqualityWithContext(seenReferences)]));
        // The main goal of using seenReference is to avoid circular node on tree.
        // It will only happen within a parent and its child, not a node and nodes next to it (same level)
        // We should keep the reference for a parent and its child only
        // Thus we should delete the reference immediately so that it doesn't interfere
        // other nodes within the same level on tree.
        seenReferences.delete(subset[key]);
        return result;
      });
    };
  };
  return _subsetEqualityWithContext()(object, subset);
}
function typeEquality(a, b) {
  if (a == null || b == null || a.constructor === b.constructor) {
    return undefined;
  }
  return false;
}
function arrayBufferEquality(a, b) {
  var dataViewA = a;
  var dataViewB = b;
  if (!(a instanceof DataView && b instanceof DataView)) {
    if (!(a instanceof ArrayBuffer) || !(b instanceof ArrayBuffer)) {
      return undefined;
    }
    try {
      dataViewA = new DataView(a);
      dataViewB = new DataView(b);
    } catch (_unused) {
      return undefined;
    }
  }
  // Buffers are not equal when they do not have the same byte length
  if (dataViewA.byteLength !== dataViewB.byteLength) {
    return false;
  }
  // Check if every byte value is equal to each other
  for (var i = 0; i < dataViewA.byteLength; i++) {
    if (dataViewA.getUint8(i) !== dataViewB.getUint8(i)) {
      return false;
    }
  }
  return true;
}
function sparseArrayEquality(a, b) {
  var customTesters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  if (!Array.isArray(a) || !Array.isArray(b)) {
    return undefined;
  }
  // A sparse array [, , 1] will have keys ["2"] whereas [undefined, undefined, 1] will have keys ["0", "1", "2"]
  var aKeys = Object.keys(a);
  var bKeys = Object.keys(b);
  var filteredCustomTesters = customTesters.filter(function (t) {
    return t !== sparseArrayEquality;
  });
  return equals(a, b, filteredCustomTesters, true) && equals(aKeys, bKeys);
}
function generateToBeMessage(deepEqualityName) {
  var expected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "#{this}";
  var actual = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "#{exp}";
  var toBeMessage = "expected ".concat(expected, " to be ").concat(actual, " // Object.is equality");
  if (["toStrictEqual", "toEqual"].includes(deepEqualityName)) {
    return "".concat(toBeMessage, "\n\nIf it should pass with deep equality, replace \"toBe\" with \"").concat(deepEqualityName, "\"\n\nExpected: ").concat(expected, "\nReceived: serializes to the same string\n");
  }
  return toBeMessage;
}
function pluralize(word, count) {
  return "".concat(count, " ").concat(word).concat(count === 1 ? "" : "s");
}
function getObjectKeys(object) {
  return [].concat(_toConsumableArray(Object.keys(object)), _toConsumableArray(Object.getOwnPropertySymbols(object).filter(function (s) {
    var _Object$getOwnPropert;
    return (_Object$getOwnPropert = Object.getOwnPropertyDescriptor(object, s)) === null || _Object$getOwnPropert === void 0 ? void 0 : _Object$getOwnPropert.enumerable;
  })));
}
function getObjectSubset(object, subset, customTesters) {
  var stripped = 0;
  var _getObjectSubsetWithContext = function getObjectSubsetWithContext() {
    var seenReferences = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new WeakMap();
    return function (object, subset) {
      if (Array.isArray(object)) {
        if (Array.isArray(subset) && subset.length === object.length) {
          // The map method returns correct subclass of subset.
          return subset.map(function (sub, i) {
            return _getObjectSubsetWithContext(seenReferences)(object[i], sub);
          });
        }
      } else if (object instanceof Date) {
        return object;
      } else if (isObject$1(object) && isObject$1(subset)) {
        if (equals(object, subset, [].concat(_toConsumableArray(customTesters), [iterableEquality, subsetEquality]))) {
          // return "expected" subset to avoid showing irrelevant toMatchObject diff
          return subset;
        }
        var trimmed = {};
        seenReferences.set(object, trimmed);
        // preserve constructor for toMatchObject diff
        if (typeof object.constructor === "function" && typeof object.constructor.name === "string") {
          Object.defineProperty(trimmed, "constructor", {
            enumerable: false,
            value: object.constructor
          });
        }
        var _iterator6 = _createForOfIteratorHelper$5(getObjectKeys(object)),
          _step6;
        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var key = _step6.value;
            if (hasPropertyInObject(subset, key)) {
              trimmed[key] = seenReferences.has(object[key]) ? seenReferences.get(object[key]) : _getObjectSubsetWithContext(seenReferences)(object[key], subset[key]);
            } else {
              if (!seenReferences.has(object[key])) {
                stripped += 1;
                if (isObject$1(object[key])) {
                  stripped += getObjectKeys(object[key]).length;
                }
                _getObjectSubsetWithContext(seenReferences)(object[key], subset[key]);
              }
            }
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }
        if (getObjectKeys(trimmed).length > 0) {
          return trimmed;
        }
      }
      return object;
    };
  };
  return {
    subset: _getObjectSubsetWithContext()(object, subset),
    stripped: stripped
  };
}
if (!Object.prototype.hasOwnProperty.call(globalThis, MATCHERS_OBJECT)) {
  var globalState = new WeakMap();
  var matchers = Object.create(null);
  var customEqualityTesters = [];
  var asymmetricMatchers = Object.create(null);
  Object.defineProperty(globalThis, MATCHERS_OBJECT, {
    get: function get() {
      return globalState;
    }
  });
  Object.defineProperty(globalThis, JEST_MATCHERS_OBJECT, {
    configurable: true,
    get: function get() {
      return {
        state: globalState.get(globalThis[GLOBAL_EXPECT]),
        matchers: matchers,
        customEqualityTesters: customEqualityTesters
      };
    }
  });
  Object.defineProperty(globalThis, ASYMMETRIC_MATCHERS_OBJECT, {
    get: function get() {
      return asymmetricMatchers;
    }
  });
}
function getState(expect) {
  return globalThis[MATCHERS_OBJECT].get(expect);
}
function setState(state, expect) {
  var map = globalThis[MATCHERS_OBJECT];
  var current = map.get(expect) || {};
  // so it keeps getters from `testPath`
  var results = Object.defineProperties(current, _objectSpread$3(_objectSpread$3({}, Object.getOwnPropertyDescriptors(current)), Object.getOwnPropertyDescriptors(state)));
  map.set(expect, results);
}
var AsymmetricMatcher$1 = /*#__PURE__*/function () {
  function AsymmetricMatcher(sample) {
    var inverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    _classCallCheck(this, AsymmetricMatcher);
    // should have "jest" to be compatible with its ecosystem
    _defineProperty(this, "$$typeof", Symbol.for("jest.asymmetricMatcher"));
    this.sample = sample;
    this.inverse = inverse;
  }
  return _createClass(AsymmetricMatcher, [{
    key: "getMatcherContext",
    value: function getMatcherContext(expect) {
      return _objectSpread$3(_objectSpread$3({}, getState(expect || globalThis[GLOBAL_EXPECT])), {}, {
        equals: equals,
        isNot: this.inverse,
        customTesters: getCustomEqualityTesters(),
        utils: _objectSpread$3(_objectSpread$3({}, getMatcherUtils()), {}, {
          diff: diff,
          stringify: stringify,
          iterableEquality: iterableEquality,
          subsetEquality: subsetEquality
        })
      });
    }
  }]);
}(); // implement custom chai/loupe inspect for better AssertionError.message formatting
// https://github.com/chaijs/loupe/blob/9b8a6deabcd50adc056a64fb705896194710c5c6/src/index.ts#L29
// @ts-expect-error computed properties is not supported when isolatedDeclarations is enabled
// FIXME: https://github.com/microsoft/TypeScript/issues/61068
AsymmetricMatcher$1.prototype[Symbol.for("chai/inspect")] = function (options) {
  // minimal pretty-format with simple manual truncation
  var result = stringify(this, options.depth, {
    min: true
  });
  if (result.length <= options.truncate) {
    return result;
  }
  return "".concat(this.toString(), "{\u2026}");
};
var StringContaining = /*#__PURE__*/function (_AsymmetricMatcher2) {
  function StringContaining(sample) {
    var inverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    _classCallCheck(this, StringContaining);
    if (!isA("String", sample)) {
      throw new Error("Expected is not a string");
    }
    return _callSuper$4(this, StringContaining, [sample, inverse]);
  }
  _inherits(StringContaining, _AsymmetricMatcher2);
  return _createClass(StringContaining, [{
    key: "asymmetricMatch",
    value: function asymmetricMatch(other) {
      var result = isA("String", other) && other.includes(this.sample);
      return this.inverse ? !result : result;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "String".concat(this.inverse ? "Not" : "", "Containing");
    }
  }, {
    key: "getExpectedType",
    value: function getExpectedType() {
      return "string";
    }
  }]);
}(AsymmetricMatcher$1);
var Anything = /*#__PURE__*/function (_AsymmetricMatcher3) {
  function Anything() {
    _classCallCheck(this, Anything);
    return _callSuper$4(this, Anything, arguments);
  }
  _inherits(Anything, _AsymmetricMatcher3);
  return _createClass(Anything, [{
    key: "asymmetricMatch",
    value: function asymmetricMatch(other) {
      return other != null;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "Anything";
    }
  }, {
    key: "toAsymmetricMatcher",
    value: function toAsymmetricMatcher() {
      return "Anything";
    }
  }]);
}(AsymmetricMatcher$1);
var ObjectContaining = /*#__PURE__*/function (_AsymmetricMatcher4) {
  function ObjectContaining(sample) {
    var inverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    _classCallCheck(this, ObjectContaining);
    return _callSuper$4(this, ObjectContaining, [sample, inverse]);
  }
  _inherits(ObjectContaining, _AsymmetricMatcher4);
  return _createClass(ObjectContaining, [{
    key: "getPrototype",
    value: function getPrototype(obj) {
      if (Object.getPrototypeOf) {
        return Object.getPrototypeOf(obj);
      }
      if (obj.constructor.prototype === obj) {
        return null;
      }
      return obj.constructor.prototype;
    }
  }, {
    key: "hasProperty",
    value: function hasProperty(obj, property) {
      if (!obj) {
        return false;
      }
      if (Object.prototype.hasOwnProperty.call(obj, property)) {
        return true;
      }
      return this.hasProperty(this.getPrototype(obj), property);
    }
  }, {
    key: "asymmetricMatch",
    value: function asymmetricMatch(other) {
      if (_typeof(this.sample) !== "object") {
        throw new TypeError("You must provide an object to ".concat(this.toString(), ", not '").concat(_typeof(this.sample), "'."));
      }
      var result = true;
      var matcherContext = this.getMatcherContext();
      for (var property in this.sample) {
        if (!this.hasProperty(other, property) || !equals(this.sample[property], other[property], matcherContext.customTesters)) {
          result = false;
          break;
        }
      }
      return this.inverse ? !result : result;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "Object".concat(this.inverse ? "Not" : "", "Containing");
    }
  }, {
    key: "getExpectedType",
    value: function getExpectedType() {
      return "object";
    }
  }]);
}(AsymmetricMatcher$1);
var ArrayContaining = /*#__PURE__*/function (_AsymmetricMatcher5) {
  function ArrayContaining(sample) {
    var inverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    _classCallCheck(this, ArrayContaining);
    return _callSuper$4(this, ArrayContaining, [sample, inverse]);
  }
  _inherits(ArrayContaining, _AsymmetricMatcher5);
  return _createClass(ArrayContaining, [{
    key: "asymmetricMatch",
    value: function asymmetricMatch(other) {
      if (!Array.isArray(this.sample)) {
        throw new TypeError("You must provide an array to ".concat(this.toString(), ", not '").concat(_typeof(this.sample), "'."));
      }
      var matcherContext = this.getMatcherContext();
      var result = this.sample.length === 0 || Array.isArray(other) && this.sample.every(function (item) {
        return other.some(function (another) {
          return equals(item, another, matcherContext.customTesters);
        });
      });
      return this.inverse ? !result : result;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "Array".concat(this.inverse ? "Not" : "", "Containing");
    }
  }, {
    key: "getExpectedType",
    value: function getExpectedType() {
      return "array";
    }
  }]);
}(AsymmetricMatcher$1);
var Any = /*#__PURE__*/function (_AsymmetricMatcher6) {
  function Any(sample) {
    _classCallCheck(this, Any);
    if (typeof sample === "undefined") {
      throw new TypeError("any() expects to be passed a constructor function. " + "Please pass one or use anything() to match any object.");
    }
    return _callSuper$4(this, Any, [sample]);
  }
  _inherits(Any, _AsymmetricMatcher6);
  return _createClass(Any, [{
    key: "fnNameFor",
    value: function fnNameFor(func) {
      if (func.name) {
        return func.name;
      }
      var functionToString = Function.prototype.toString;
      var matches = functionToString.call(func).match(/^(?:async)?\s*function\s*(?:\*\s*)?([\w$]+)\s*\(/);
      return matches ? matches[1] : "<anonymous>";
    }
  }, {
    key: "asymmetricMatch",
    value: function asymmetricMatch(other) {
      if (this.sample === String) {
        return typeof other == "string" || other instanceof String;
      }
      if (this.sample === Number) {
        return typeof other == "number" || other instanceof Number;
      }
      if (this.sample === Function) {
        return typeof other == "function" || typeof other === "function";
      }
      if (this.sample === Boolean) {
        return typeof other == "boolean" || other instanceof Boolean;
      }
      if (this.sample === BigInt) {
        return typeof other == "bigint" || other instanceof BigInt;
      }
      if (this.sample === Symbol) {
        return _typeof(other) == "symbol" || other instanceof Symbol;
      }
      if (this.sample === Object) {
        return _typeof(other) == "object";
      }
      return other instanceof this.sample;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "Any";
    }
  }, {
    key: "getExpectedType",
    value: function getExpectedType() {
      if (this.sample === String) {
        return "string";
      }
      if (this.sample === Number) {
        return "number";
      }
      if (this.sample === Function) {
        return "function";
      }
      if (this.sample === Object) {
        return "object";
      }
      if (this.sample === Boolean) {
        return "boolean";
      }
      return this.fnNameFor(this.sample);
    }
  }, {
    key: "toAsymmetricMatcher",
    value: function toAsymmetricMatcher() {
      return "Any<".concat(this.fnNameFor(this.sample), ">");
    }
  }]);
}(AsymmetricMatcher$1);
var StringMatching = /*#__PURE__*/function (_AsymmetricMatcher7) {
  function StringMatching(sample) {
    var inverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    _classCallCheck(this, StringMatching);
    if (!isA("String", sample) && !isA("RegExp", sample)) {
      throw new Error("Expected is not a String or a RegExp");
    }
    return _callSuper$4(this, StringMatching, [new RegExp(sample), inverse]);
  }
  _inherits(StringMatching, _AsymmetricMatcher7);
  return _createClass(StringMatching, [{
    key: "asymmetricMatch",
    value: function asymmetricMatch(other) {
      var result = isA("String", other) && this.sample.test(other);
      return this.inverse ? !result : result;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "String".concat(this.inverse ? "Not" : "", "Matching");
    }
  }, {
    key: "getExpectedType",
    value: function getExpectedType() {
      return "string";
    }
  }]);
}(AsymmetricMatcher$1);
var CloseTo = /*#__PURE__*/function (_AsymmetricMatcher8) {
  function CloseTo(sample) {
    var _this;
    var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
    var inverse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    _classCallCheck(this, CloseTo);
    if (!isA("Number", sample)) {
      throw new Error("Expected is not a Number");
    }
    if (!isA("Number", precision)) {
      throw new Error("Precision is not a Number");
    }
    _this = _callSuper$4(this, CloseTo, [sample]);
    _defineProperty(_this, "precision", void 0);
    _this.inverse = inverse;
    _this.precision = precision;
    return _this;
  }
  _inherits(CloseTo, _AsymmetricMatcher8);
  return _createClass(CloseTo, [{
    key: "asymmetricMatch",
    value: function asymmetricMatch(other) {
      if (!isA("Number", other)) {
        return false;
      }
      var result = false;
      if (other === Number.POSITIVE_INFINITY && this.sample === Number.POSITIVE_INFINITY) {
        result = true;
      } else if (other === Number.NEGATIVE_INFINITY && this.sample === Number.NEGATIVE_INFINITY) {
        result = true;
      } else {
        result = Math.abs(this.sample - other) < Math.pow(10, -this.precision) / 2;
      }
      return this.inverse ? !result : result;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "Number".concat(this.inverse ? "Not" : "", "CloseTo");
    }
  }, {
    key: "getExpectedType",
    value: function getExpectedType() {
      return "number";
    }
  }, {
    key: "toAsymmetricMatcher",
    value: function toAsymmetricMatcher() {
      return [this.toString(), this.sample, "(".concat(pluralize("digit", this.precision), ")")].join(" ");
    }
  }]);
}(AsymmetricMatcher$1);
var JestAsymmetricMatchers = function JestAsymmetricMatchers(chai, utils) {
  utils.addMethod(chai.expect, "anything", function () {
    return new Anything();
  });
  utils.addMethod(chai.expect, "any", function (expected) {
    return new Any(expected);
  });
  utils.addMethod(chai.expect, "stringContaining", function (expected) {
    return new StringContaining(expected);
  });
  utils.addMethod(chai.expect, "objectContaining", function (expected) {
    return new ObjectContaining(expected);
  });
  utils.addMethod(chai.expect, "arrayContaining", function (expected) {
    return new ArrayContaining(expected);
  });
  utils.addMethod(chai.expect, "stringMatching", function (expected) {
    return new StringMatching(expected);
  });
  utils.addMethod(chai.expect, "closeTo", function (expected, precision) {
    return new CloseTo(expected, precision);
  });
  // defineProperty does not work
  chai.expect.not = {
    stringContaining: function stringContaining(expected) {
      return new StringContaining(expected, true);
    },
    objectContaining: function objectContaining(expected) {
      return new ObjectContaining(expected, true);
    },
    arrayContaining: function arrayContaining(expected) {
      return new ArrayContaining(expected, true);
    },
    stringMatching: function stringMatching(expected) {
      return new StringMatching(expected, true);
    },
    closeTo: function closeTo(expected, precision) {
      return new CloseTo(expected, precision, true);
    }
  };
};
function createAssertionMessage$1(util, assertion, hasArgs) {
  var not = util.flag(assertion, "negate") ? "not." : "";
  var name = "".concat(util.flag(assertion, "_name"), "(").concat(hasArgs ? "expected" : "", ")");
  var promiseName = util.flag(assertion, "promise");
  var promise = promiseName ? ".".concat(promiseName) : "";
  return "expect(actual)".concat(promise, ".").concat(not).concat(name);
}
function recordAsyncExpect$1(_test, promise, assertion, error) {
  var test = _test;
  // record promise for test, that resolves before test ends
  if (test && promise instanceof Promise) {
    var _test$onFinished;
    // if promise is explicitly awaited, remove it from the list
    promise = promise.finally(function () {
      if (!test.promises) {
        return;
      }
      var index = test.promises.indexOf(promise);
      if (index !== -1) {
        test.promises.splice(index, 1);
      }
    });
    // record promise
    if (!test.promises) {
      test.promises = [];
    }
    test.promises.push(promise);
    var resolved = false;
    (_test$onFinished = test.onFinished) !== null && _test$onFinished !== void 0 ? _test$onFinished : test.onFinished = [];
    test.onFinished.push(function () {
      if (!resolved) {
        var _vitest_worker__;
        var processor = ((_vitest_worker__ = globalThis.__vitest_worker__) === null || _vitest_worker__ === void 0 ? void 0 : _vitest_worker__.onFilterStackTrace) || function (s) {
          return s || "";
        };
        var stack = processor(error.stack);
        console.warn(["Promise returned by `".concat(assertion, "` was not awaited. "), "Vitest currently auto-awaits hanging assertions at the end of the test, but this will cause the test to fail in Vitest 3. ", "Please remember to await the assertion.\n", stack].join(""));
      }
    });
    return _defineProperty({
      then: function then(onFulfilled, onRejected) {
        resolved = true;
        return promise.then(onFulfilled, onRejected);
      },
      catch: function _catch(onRejected) {
        return promise.catch(onRejected);
      },
      finally: function _finally(onFinally) {
        return promise.finally(onFinally);
      }
    }, Symbol.toStringTag, "Promise");
  }
  return promise;
}
function handleTestError(test, err) {
  var _test$result;
  test.result || (test.result = {
    state: "fail"
  });
  test.result.state = "fail";
  (_test$result = test.result).errors || (_test$result.errors = []);
  test.result.errors.push(processError(err));
}
function wrapAssertion(utils, name, fn) {
  return function () {
    // private
    if (name !== "withTest") {
      utils.flag(this, "_name", name);
    }
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (!utils.flag(this, "soft")) {
      return fn.apply(this, args);
    }
    var test = utils.flag(this, "vitest-test");
    if (!test) {
      throw new Error("expect.soft() can only be used inside a test");
    }
    try {
      var result = fn.apply(this, args);
      if (result && _typeof(result) === "object" && typeof result.then === "function") {
        return result.then(noop, function (err) {
          handleTestError(test, err);
        });
      }
      return result;
    } catch (err) {
      handleTestError(test, err);
    }
  };
}

// Jest Expect Compact
var JestChaiExpect = function JestChaiExpect(chai, utils) {
  var AssertionError = chai.AssertionError;
  var customTesters = getCustomEqualityTesters();
  function def(name, fn) {
    var addMethod = function addMethod(n) {
      var softWrapper = wrapAssertion(utils, n, fn);
      utils.addMethod(chai.Assertion.prototype, n, softWrapper);
      utils.addMethod(globalThis[JEST_MATCHERS_OBJECT].matchers, n, softWrapper);
    };
    if (Array.isArray(name)) {
      name.forEach(function (n) {
        return addMethod(n);
      });
    } else {
      addMethod(name);
    }
  }
  ["throw", "throws", "Throw"].forEach(function (m) {
    utils.overwriteMethod(chai.Assertion.prototype, m, function (_super) {
      return function () {
        var promise = utils.flag(this, "promise");
        var object = utils.flag(this, "object");
        var isNot = utils.flag(this, "negate");
        if (promise === "rejects") {
          utils.flag(this, "object", function () {
            throw object;
          });
        } else if (promise === "resolves" && typeof object !== "function") {
          if (!isNot) {
            var message = utils.flag(this, "message") || "expected promise to throw an error, but it didn't";
            var error = {
              showDiff: false
            };
            throw new AssertionError(message, error, utils.flag(this, "ssfi"));
          } else {
            return;
          }
        }
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        _super.apply(this, args);
      };
    });
  });
  // @ts-expect-error @internal
  def("withTest", function (test) {
    utils.flag(this, "vitest-test", test);
    return this;
  });
  def("toEqual", function (expected) {
    var actual = utils.flag(this, "object");
    var equal = equals(actual, expected, [].concat(_toConsumableArray(customTesters), [iterableEquality]));
    return this.assert(equal, "expected #{this} to deeply equal #{exp}", "expected #{this} to not deeply equal #{exp}", expected, actual);
  });
  def("toStrictEqual", function (expected) {
    var obj = utils.flag(this, "object");
    var equal = equals(obj, expected, [].concat(_toConsumableArray(customTesters), [iterableEquality, typeEquality, sparseArrayEquality, arrayBufferEquality]), true);
    return this.assert(equal, "expected #{this} to strictly equal #{exp}", "expected #{this} to not strictly equal #{exp}", expected, obj);
  });
  def("toBe", function (expected) {
    var actual = this._obj;
    var pass = Object.is(actual, expected);
    var deepEqualityName = "";
    if (!pass) {
      var toStrictEqualPass = equals(actual, expected, [].concat(_toConsumableArray(customTesters), [iterableEquality, typeEquality, sparseArrayEquality, arrayBufferEquality]), true);
      if (toStrictEqualPass) {
        deepEqualityName = "toStrictEqual";
      } else {
        var toEqualPass = equals(actual, expected, [].concat(_toConsumableArray(customTesters), [iterableEquality]));
        if (toEqualPass) {
          deepEqualityName = "toEqual";
        }
      }
    }
    return this.assert(pass, generateToBeMessage(deepEqualityName), "expected #{this} not to be #{exp} // Object.is equality", expected, actual);
  });
  def("toMatchObject", function (expected) {
    var actual = this._obj;
    var pass = equals(actual, expected, [].concat(_toConsumableArray(customTesters), [iterableEquality, subsetEquality]));
    var isNot = utils.flag(this, "negate");
    var _getObjectSubset = getObjectSubset(actual, expected, customTesters),
      actualSubset = _getObjectSubset.subset,
      stripped = _getObjectSubset.stripped;
    if (pass && isNot || !pass && !isNot) {
      var msg = utils.getMessage(this, [pass, "expected #{this} to match object #{exp}", "expected #{this} to not match object #{exp}", expected, actualSubset, false]);
      var message = stripped === 0 ? msg : "".concat(msg, "\n(").concat(stripped, " matching ").concat(stripped === 1 ? "property" : "properties", " omitted from actual)");
      throw new AssertionError(message, {
        showDiff: true,
        expected: expected,
        actual: actualSubset
      });
    }
  });
  def("toMatch", function (expected) {
    var actual = this._obj;
    if (typeof actual !== "string") {
      throw new TypeError(".toMatch() expects to receive a string, but got ".concat(_typeof(actual)));
    }
    return this.assert(typeof expected === "string" ? actual.includes(expected) : actual.match(expected), "expected #{this} to match #{exp}", "expected #{this} not to match #{exp}", expected, actual);
  });
  def("toContain", function (item) {
    var actual = this._obj;
    if (typeof Node !== "undefined" && actual instanceof Node) {
      if (!(item instanceof Node)) {
        throw new TypeError("toContain() expected a DOM node as the argument, but got ".concat(_typeof(item)));
      }
      return this.assert(actual.contains(item), "expected #{this} to contain element #{exp}", "expected #{this} not to contain element #{exp}", item, actual);
    }
    if (typeof DOMTokenList !== "undefined" && actual instanceof DOMTokenList) {
      assertTypes(item, "class name", ["string"]);
      var isNot = utils.flag(this, "negate");
      var expectedClassList = isNot ? actual.value.replace(item, "").trim() : "".concat(actual.value, " ").concat(item);
      return this.assert(actual.contains(item), "expected \"".concat(actual.value, "\" to contain \"").concat(item, "\""), "expected \"".concat(actual.value, "\" not to contain \"").concat(item, "\""), expectedClassList, actual.value);
    }
    // handle simple case on our own using `this.assert` to include diff in error message
    if (typeof actual === "string" && typeof item === "string") {
      return this.assert(actual.includes(item), "expected #{this} to contain #{exp}", "expected #{this} not to contain #{exp}", item, actual);
    }
    // make "actual" indexable to have compatibility with jest
    if (actual != null && typeof actual !== "string") {
      utils.flag(this, "object", Array.from(actual));
    }
    return this.contain(item);
  });
  def("toContainEqual", function (expected) {
    var obj = utils.flag(this, "object");
    var index = Array.from(obj).findIndex(function (item) {
      return equals(item, expected, customTesters);
    });
    this.assert(index !== -1, "expected #{this} to deep equally contain #{exp}", "expected #{this} to not deep equally contain #{exp}", expected);
  });
  def("toBeTruthy", function () {
    var obj = utils.flag(this, "object");
    this.assert(Boolean(obj), "expected #{this} to be truthy", "expected #{this} to not be truthy", true, obj);
  });
  def("toBeFalsy", function () {
    var obj = utils.flag(this, "object");
    this.assert(!obj, "expected #{this} to be falsy", "expected #{this} to not be falsy", false, obj);
  });
  def("toBeGreaterThan", function (expected) {
    var actual = this._obj;
    assertTypes(actual, "actual", ["number", "bigint"]);
    assertTypes(expected, "expected", ["number", "bigint"]);
    return this.assert(actual > expected, "expected ".concat(actual, " to be greater than ").concat(expected), "expected ".concat(actual, " to be not greater than ").concat(expected), expected, actual, false);
  });
  def("toBeGreaterThanOrEqual", function (expected) {
    var actual = this._obj;
    assertTypes(actual, "actual", ["number", "bigint"]);
    assertTypes(expected, "expected", ["number", "bigint"]);
    return this.assert(actual >= expected, "expected ".concat(actual, " to be greater than or equal to ").concat(expected), "expected ".concat(actual, " to be not greater than or equal to ").concat(expected), expected, actual, false);
  });
  def("toBeLessThan", function (expected) {
    var actual = this._obj;
    assertTypes(actual, "actual", ["number", "bigint"]);
    assertTypes(expected, "expected", ["number", "bigint"]);
    return this.assert(actual < expected, "expected ".concat(actual, " to be less than ").concat(expected), "expected ".concat(actual, " to be not less than ").concat(expected), expected, actual, false);
  });
  def("toBeLessThanOrEqual", function (expected) {
    var actual = this._obj;
    assertTypes(actual, "actual", ["number", "bigint"]);
    assertTypes(expected, "expected", ["number", "bigint"]);
    return this.assert(actual <= expected, "expected ".concat(actual, " to be less than or equal to ").concat(expected), "expected ".concat(actual, " to be not less than or equal to ").concat(expected), expected, actual, false);
  });
  def("toBeNaN", function () {
    var obj = utils.flag(this, "object");
    this.assert(Number.isNaN(obj), "expected #{this} to be NaN", "expected #{this} not to be NaN", Number.NaN, obj);
  });
  def("toBeUndefined", function () {
    var obj = utils.flag(this, "object");
    this.assert(undefined === obj, "expected #{this} to be undefined", "expected #{this} not to be undefined", undefined, obj);
  });
  def("toBeNull", function () {
    var obj = utils.flag(this, "object");
    this.assert(obj === null, "expected #{this} to be null", "expected #{this} not to be null", null, obj);
  });
  def("toBeDefined", function () {
    var obj = utils.flag(this, "object");
    this.assert(typeof obj !== "undefined", "expected #{this} to be defined", "expected #{this} to be undefined", obj);
  });
  def("toBeTypeOf", function (expected) {
    var actual = _typeof(this._obj);
    var equal = expected === actual;
    return this.assert(equal, "expected #{this} to be type of #{exp}", "expected #{this} not to be type of #{exp}", expected, actual);
  });
  def("toBeInstanceOf", function (obj) {
    return this.instanceOf(obj);
  });
  def("toHaveLength", function (length) {
    return this.have.length(length);
  });
  // destructuring, because it checks `arguments` inside, and value is passing as `undefined`
  def("toHaveProperty", function () {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    if (Array.isArray(args[0])) {
      args[0] = args[0].map(function (key) {
        return String(key).replace(/([.[\]])/g, "\\$1");
      }).join(".");
    }
    var actual = this._obj;
    var propertyName = args[0],
      expected = args[1];
    var getValue = function getValue() {
      var hasOwn = Object.prototype.hasOwnProperty.call(actual, propertyName);
      if (hasOwn) {
        return {
          value: actual[propertyName],
          exists: true
        };
      }
      return utils.getPathInfo(actual, propertyName);
    };
    var _getValue = getValue(),
      value = _getValue.value,
      exists = _getValue.exists;
    var pass = exists && (args.length === 1 || equals(expected, value, customTesters));
    var valueString = args.length === 1 ? "" : " with value ".concat(utils.objDisplay(expected));
    return this.assert(pass, "expected #{this} to have property \"".concat(propertyName, "\"").concat(valueString), "expected #{this} to not have property \"".concat(propertyName, "\"").concat(valueString), expected, exists ? value : undefined);
  });
  def("toBeCloseTo", function (received) {
    var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
    var expected = this._obj;
    var pass = false;
    var expectedDiff = 0;
    var receivedDiff = 0;
    if (received === Number.POSITIVE_INFINITY && expected === Number.POSITIVE_INFINITY) {
      pass = true;
    } else if (received === Number.NEGATIVE_INFINITY && expected === Number.NEGATIVE_INFINITY) {
      pass = true;
    } else {
      expectedDiff = Math.pow(10, -precision) / 2;
      receivedDiff = Math.abs(expected - received);
      pass = receivedDiff < expectedDiff;
    }
    return this.assert(pass, "expected #{this} to be close to #{exp}, received difference is ".concat(receivedDiff, ", but expected ").concat(expectedDiff), "expected #{this} to not be close to #{exp}, received difference is ".concat(receivedDiff, ", but expected ").concat(expectedDiff), received, expected, false);
  });
  function assertIsMock(assertion) {
    if (!isMockFunction(assertion._obj)) {
      throw new TypeError("".concat(utils.inspect(assertion._obj), " is not a spy or a call to a spy!"));
    }
  }
  function getSpy(assertion) {
    assertIsMock(assertion);
    return assertion._obj;
  }
  def(["toHaveBeenCalledTimes", "toBeCalledTimes"], function (number) {
    var spy = getSpy(this);
    var spyName = spy.getMockName();
    var callCount = spy.mock.calls.length;
    return this.assert(callCount === number, "expected \"".concat(spyName, "\" to be called #{exp} times, but got ").concat(callCount, " times"), "expected \"".concat(spyName, "\" to not be called #{exp} times"), number, callCount, false);
  });
  def("toHaveBeenCalledOnce", function () {
    var spy = getSpy(this);
    var spyName = spy.getMockName();
    var callCount = spy.mock.calls.length;
    return this.assert(callCount === 1, "expected \"".concat(spyName, "\" to be called once, but got ").concat(callCount, " times"), "expected \"".concat(spyName, "\" to not be called once"), 1, callCount, false);
  });
  def(["toHaveBeenCalled", "toBeCalled"], function () {
    var spy = getSpy(this);
    var spyName = spy.getMockName();
    var callCount = spy.mock.calls.length;
    var called = callCount > 0;
    var isNot = utils.flag(this, "negate");
    var msg = utils.getMessage(this, [called, "expected \"".concat(spyName, "\" to be called at least once"), "expected \"".concat(spyName, "\" to not be called at all, but actually been called ").concat(callCount, " times"), true, called]);
    if (called && isNot) {
      msg = formatCalls(spy, msg);
    }
    if (called && isNot || !called && !isNot) {
      throw new AssertionError(msg);
    }
  });
  // manually compare array elements since `jestEquals` cannot
  // apply asymmetric matcher to `undefined` array element.
  function equalsArgumentArray(a, b) {
    return a.length === b.length && a.every(function (aItem, i) {
      return equals(aItem, b[i], [].concat(_toConsumableArray(customTesters), [iterableEquality]));
    });
  }
  def(["toHaveBeenCalledWith", "toBeCalledWith"], function () {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    var spy = getSpy(this);
    var spyName = spy.getMockName();
    var pass = spy.mock.calls.some(function (callArg) {
      return equalsArgumentArray(callArg, args);
    });
    var isNot = utils.flag(this, "negate");
    var msg = utils.getMessage(this, [pass, "expected \"".concat(spyName, "\" to be called with arguments: #{exp}"), "expected \"".concat(spyName, "\" to not be called with arguments: #{exp}"), args]);
    if (pass && isNot || !pass && !isNot) {
      throw new AssertionError(formatCalls(spy, msg, args));
    }
  });
  def("toHaveBeenCalledExactlyOnceWith", function () {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }
    var spy = getSpy(this);
    var spyName = spy.getMockName();
    var callCount = spy.mock.calls.length;
    var hasCallWithArgs = spy.mock.calls.some(function (callArg) {
      return equalsArgumentArray(callArg, args);
    });
    var pass = hasCallWithArgs && callCount === 1;
    var isNot = utils.flag(this, "negate");
    var msg = utils.getMessage(this, [pass, "expected \"".concat(spyName, "\" to be called once with arguments: #{exp}"), "expected \"".concat(spyName, "\" to not be called once with arguments: #{exp}"), args]);
    if (pass && isNot || !pass && !isNot) {
      throw new AssertionError(formatCalls(spy, msg, args));
    }
  });
  def(["toHaveBeenNthCalledWith", "nthCalledWith"], function (times) {
    var spy = getSpy(this);
    var spyName = spy.getMockName();
    var nthCall = spy.mock.calls[times - 1];
    var callCount = spy.mock.calls.length;
    var isCalled = times <= callCount;
    for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
      args[_key6 - 1] = arguments[_key6];
    }
    this.assert(nthCall && equalsArgumentArray(nthCall, args), "expected ".concat(ordinalOf(times), " \"").concat(spyName, "\" call to have been called with #{exp}").concat(isCalled ? "" : ", but called only ".concat(callCount, " times")), "expected ".concat(ordinalOf(times), " \"").concat(spyName, "\" call to not have been called with #{exp}"), args, nthCall, isCalled);
  });
  def(["toHaveBeenLastCalledWith", "lastCalledWith"], function () {
    var spy = getSpy(this);
    var spyName = spy.getMockName();
    var lastCall = spy.mock.calls[spy.mock.calls.length - 1];
    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      args[_key7] = arguments[_key7];
    }
    this.assert(lastCall && equalsArgumentArray(lastCall, args), "expected last \"".concat(spyName, "\" call to have been called with #{exp}"), "expected last \"".concat(spyName, "\" call to not have been called with #{exp}"), args, lastCall);
  });
  /**
  * Used for `toHaveBeenCalledBefore` and `toHaveBeenCalledAfter` to determine if the expected spy was called before the result spy.
  */
  function isSpyCalledBeforeAnotherSpy(beforeSpy, afterSpy, failIfNoFirstInvocation) {
    var beforeInvocationCallOrder = beforeSpy.mock.invocationCallOrder;
    var afterInvocationCallOrder = afterSpy.mock.invocationCallOrder;
    if (beforeInvocationCallOrder.length === 0) {
      return !failIfNoFirstInvocation;
    }
    if (afterInvocationCallOrder.length === 0) {
      return false;
    }
    return beforeInvocationCallOrder[0] < afterInvocationCallOrder[0];
  }
  def(["toHaveBeenCalledBefore"], function (resultSpy) {
    var failIfNoFirstInvocation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var expectSpy = getSpy(this);
    if (!isMockFunction(resultSpy)) {
      throw new TypeError("".concat(utils.inspect(resultSpy), " is not a spy or a call to a spy"));
    }
    this.assert(isSpyCalledBeforeAnotherSpy(expectSpy, resultSpy, failIfNoFirstInvocation), "expected \"".concat(expectSpy.getMockName(), "\" to have been called before \"").concat(resultSpy.getMockName(), "\""), "expected \"".concat(expectSpy.getMockName(), "\" to not have been called before \"").concat(resultSpy.getMockName(), "\""), resultSpy, expectSpy);
  });
  def(["toHaveBeenCalledAfter"], function (resultSpy) {
    var failIfNoFirstInvocation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var expectSpy = getSpy(this);
    if (!isMockFunction(resultSpy)) {
      throw new TypeError("".concat(utils.inspect(resultSpy), " is not a spy or a call to a spy"));
    }
    this.assert(isSpyCalledBeforeAnotherSpy(resultSpy, expectSpy, failIfNoFirstInvocation), "expected \"".concat(expectSpy.getMockName(), "\" to have been called after \"").concat(resultSpy.getMockName(), "\""), "expected \"".concat(expectSpy.getMockName(), "\" to not have been called after \"").concat(resultSpy.getMockName(), "\""), resultSpy, expectSpy);
  });
  def(["toThrow", "toThrowError"], function (expected) {
    if (typeof expected === "string" || typeof expected === "undefined" || expected instanceof RegExp) {
      // Fixes the issue related to `chai` <https://github.com/vitest-dev/vitest/issues/6618>
      return this.throws(expected === "" ? /^$/ : expected);
    }
    var obj = this._obj;
    var promise = utils.flag(this, "promise");
    var isNot = utils.flag(this, "negate");
    var thrown = null;
    if (promise === "rejects") {
      thrown = obj;
    } else if (promise === "resolves" && typeof obj !== "function") {
      if (!isNot) {
        var message = utils.flag(this, "message") || "expected promise to throw an error, but it didn't";
        var error = {
          showDiff: false
        };
        throw new AssertionError(message, error, utils.flag(this, "ssfi"));
      } else {
        return;
      }
    } else {
      var isThrow = false;
      try {
        obj();
      } catch (err) {
        isThrow = true;
        thrown = err;
      }
      if (!isThrow && !isNot) {
        var _message2 = utils.flag(this, "message") || "expected function to throw an error, but it didn't";
        var _error2 = {
          showDiff: false
        };
        throw new AssertionError(_message2, _error2, utils.flag(this, "ssfi"));
      }
    }
    if (typeof expected === "function") {
      var name = expected.name || expected.prototype.constructor.name;
      return this.assert(thrown && thrown instanceof expected, "expected error to be instance of ".concat(name), "expected error not to be instance of ".concat(name), expected, thrown);
    }
    if (expected instanceof Error) {
      var equal = equals(thrown, expected, [].concat(_toConsumableArray(customTesters), [iterableEquality]));
      return this.assert(equal, "expected a thrown error to be #{exp}", "expected a thrown error not to be #{exp}", expected, thrown);
    }
    if (_typeof(expected) === "object" && "asymmetricMatch" in expected && typeof expected.asymmetricMatch === "function") {
      var matcher = expected;
      return this.assert(thrown && matcher.asymmetricMatch(thrown), "expected error to match asymmetric matcher", "expected error not to match asymmetric matcher", matcher, thrown);
    }
    throw new Error("\"toThrow\" expects string, RegExp, function, Error instance or asymmetric matcher, got \"".concat(_typeof(expected), "\""));
  });
  [{
    name: "toHaveResolved",
    condition: function condition(spy) {
      return spy.mock.settledResults.length > 0 && spy.mock.settledResults.some(function (_ref2) {
        var type = _ref2.type;
        return type === "fulfilled";
      });
    },
    action: "resolved"
  }, {
    name: ["toHaveReturned", "toReturn"],
    condition: function condition(spy) {
      return spy.mock.calls.length > 0 && spy.mock.results.some(function (_ref3) {
        var type = _ref3.type;
        return type !== "throw";
      });
    },
    action: "called"
  }].forEach(function (_ref4) {
    var name = _ref4.name,
      condition = _ref4.condition,
      action = _ref4.action;
    def(name, function () {
      var spy = getSpy(this);
      var spyName = spy.getMockName();
      var pass = condition(spy);
      this.assert(pass, "expected \"".concat(spyName, "\" to be successfully ").concat(action, " at least once"), "expected \"".concat(spyName, "\" to not be successfully ").concat(action), pass, !pass, false);
    });
  });
  [{
    name: "toHaveResolvedTimes",
    condition: function condition(spy, times) {
      return spy.mock.settledResults.reduce(function (s, _ref5) {
        var type = _ref5.type;
        return type === "fulfilled" ? ++s : s;
      }, 0) === times;
    },
    action: "resolved"
  }, {
    name: ["toHaveReturnedTimes", "toReturnTimes"],
    condition: function condition(spy, times) {
      return spy.mock.results.reduce(function (s, _ref6) {
        var type = _ref6.type;
        return type === "throw" ? s : ++s;
      }, 0) === times;
    },
    action: "called"
  }].forEach(function (_ref7) {
    var name = _ref7.name,
      condition = _ref7.condition,
      action = _ref7.action;
    def(name, function (times) {
      var spy = getSpy(this);
      var spyName = spy.getMockName();
      var pass = condition(spy, times);
      this.assert(pass, "expected \"".concat(spyName, "\" to be successfully ").concat(action, " ").concat(times, " times"), "expected \"".concat(spyName, "\" to not be successfully ").concat(action, " ").concat(times, " times"), "expected resolved times: ".concat(times), "received resolved times: ".concat(pass), false);
    });
  });
  [{
    name: "toHaveResolvedWith",
    condition: function condition(spy, value) {
      return spy.mock.settledResults.some(function (_ref8) {
        var type = _ref8.type,
          result = _ref8.value;
        return type === "fulfilled" && equals(value, result);
      });
    },
    action: "resolve"
  }, {
    name: ["toHaveReturnedWith", "toReturnWith"],
    condition: function condition(spy, value) {
      return spy.mock.results.some(function (_ref9) {
        var type = _ref9.type,
          result = _ref9.value;
        return type === "return" && equals(value, result);
      });
    },
    action: "return"
  }].forEach(function (_ref0) {
    var name = _ref0.name,
      condition = _ref0.condition,
      action = _ref0.action;
    def(name, function (value) {
      var spy = getSpy(this);
      var pass = condition(spy, value);
      var isNot = utils.flag(this, "negate");
      if (pass && isNot || !pass && !isNot) {
        var spyName = spy.getMockName();
        var msg = utils.getMessage(this, [pass, "expected \"".concat(spyName, "\" to ").concat(action, " with: #{exp} at least once"), "expected \"".concat(spyName, "\" to not ").concat(action, " with: #{exp}"), value]);
        var results = action === "return" ? spy.mock.results : spy.mock.settledResults;
        throw new AssertionError(formatReturns(spy, results, msg, value));
      }
    });
  });
  [{
    name: "toHaveLastResolvedWith",
    condition: function condition(spy, value) {
      var result = spy.mock.settledResults[spy.mock.settledResults.length - 1];
      return result && result.type === "fulfilled" && equals(result.value, value);
    },
    action: "resolve"
  }, {
    name: ["toHaveLastReturnedWith", "lastReturnedWith"],
    condition: function condition(spy, value) {
      var result = spy.mock.results[spy.mock.results.length - 1];
      return result && result.type === "return" && equals(result.value, value);
    },
    action: "return"
  }].forEach(function (_ref1) {
    var name = _ref1.name,
      condition = _ref1.condition,
      action = _ref1.action;
    def(name, function (value) {
      var spy = getSpy(this);
      var results = action === "return" ? spy.mock.results : spy.mock.settledResults;
      var result = results[results.length - 1];
      var spyName = spy.getMockName();
      this.assert(condition(spy, value), "expected last \"".concat(spyName, "\" call to ").concat(action, " #{exp}"), "expected last \"".concat(spyName, "\" call to not ").concat(action, " #{exp}"), value, result === null || result === void 0 ? void 0 : result.value);
    });
  });
  [{
    name: "toHaveNthResolvedWith",
    condition: function condition(spy, index, value) {
      var result = spy.mock.settledResults[index - 1];
      return result && result.type === "fulfilled" && equals(result.value, value);
    },
    action: "resolve"
  }, {
    name: ["toHaveNthReturnedWith", "nthReturnedWith"],
    condition: function condition(spy, index, value) {
      var result = spy.mock.results[index - 1];
      return result && result.type === "return" && equals(result.value, value);
    },
    action: "return"
  }].forEach(function (_ref10) {
    var name = _ref10.name,
      condition = _ref10.condition,
      action = _ref10.action;
    def(name, function (nthCall, value) {
      var spy = getSpy(this);
      var spyName = spy.getMockName();
      var results = action === "return" ? spy.mock.results : spy.mock.settledResults;
      var result = results[nthCall - 1];
      var ordinalCall = "".concat(ordinalOf(nthCall), " call");
      this.assert(condition(spy, nthCall, value), "expected ".concat(ordinalCall, " \"").concat(spyName, "\" call to ").concat(action, " #{exp}"), "expected ".concat(ordinalCall, " \"").concat(spyName, "\" call to not ").concat(action, " #{exp}"), value, result === null || result === void 0 ? void 0 : result.value);
    });
  });
  // @ts-expect-error @internal
  def("withContext", function (context) {
    for (var key in context) {
      utils.flag(this, key, context[key]);
    }
    return this;
  });
  utils.addProperty(chai.Assertion.prototype, "resolves", function __VITEST_RESOLVES__() {
    var _this2 = this;
    var error = new Error("resolves");
    utils.flag(this, "promise", "resolves");
    utils.flag(this, "error", error);
    var test = utils.flag(this, "vitest-test");
    var obj = utils.flag(this, "object");
    if (utils.flag(this, "poll")) {
      throw new SyntaxError("expect.poll() is not supported in combination with .resolves");
    }
    if (typeof (obj === null || obj === void 0 ? void 0 : obj.then) !== "function") {
      throw new TypeError("You must provide a Promise to expect() when using .resolves, not '".concat(_typeof(obj), "'."));
    }
    var proxy = new Proxy(this, {
      get: function get(target, key, receiver) {
        var result = Reflect.get(target, key, receiver);
        if (typeof result !== "function") {
          return result instanceof chai.Assertion ? proxy : result;
        }
        return function () {
          for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
            args[_key8] = arguments[_key8];
          }
          utils.flag(_this2, "_name", key);
          var promise = obj.then(function (value) {
            utils.flag(_this2, "object", value);
            return result.call.apply(result, [_this2].concat(args));
          }, function (err) {
            var _error = new AssertionError("promise rejected \"".concat(utils.inspect(err), "\" instead of resolving"), {
              showDiff: false
            });
            _error.cause = err;
            _error.stack = error.stack.replace(error.message, _error.message);
            throw _error;
          });
          return recordAsyncExpect$1(test, promise, createAssertionMessage$1(utils, _this2, !!args.length), error);
        };
      }
    });
    return proxy;
  });
  utils.addProperty(chai.Assertion.prototype, "rejects", function __VITEST_REJECTS__() {
    var _this3 = this;
    var error = new Error("rejects");
    utils.flag(this, "promise", "rejects");
    utils.flag(this, "error", error);
    var test = utils.flag(this, "vitest-test");
    var obj = utils.flag(this, "object");
    var wrapper = typeof obj === "function" ? obj() : obj;
    if (utils.flag(this, "poll")) {
      throw new SyntaxError("expect.poll() is not supported in combination with .rejects");
    }
    if (typeof (wrapper === null || wrapper === void 0 ? void 0 : wrapper.then) !== "function") {
      throw new TypeError("You must provide a Promise to expect() when using .rejects, not '".concat(_typeof(wrapper), "'."));
    }
    var proxy = new Proxy(this, {
      get: function get(target, key, receiver) {
        var result = Reflect.get(target, key, receiver);
        if (typeof result !== "function") {
          return result instanceof chai.Assertion ? proxy : result;
        }
        return function () {
          for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
            args[_key9] = arguments[_key9];
          }
          utils.flag(_this3, "_name", key);
          var promise = wrapper.then(function (value) {
            var _error = new AssertionError("promise resolved \"".concat(utils.inspect(value), "\" instead of rejecting"), {
              showDiff: true,
              expected: new Error("rejected promise"),
              actual: value
            });
            _error.stack = error.stack.replace(error.message, _error.message);
            throw _error;
          }, function (err) {
            utils.flag(_this3, "object", err);
            return result.call.apply(result, [_this3].concat(args));
          });
          return recordAsyncExpect$1(test, promise, createAssertionMessage$1(utils, _this3, !!args.length), error);
        };
      }
    });
    return proxy;
  });
};
function ordinalOf(i) {
  var j = i % 10;
  var k = i % 100;
  if (j === 1 && k !== 11) {
    return "".concat(i, "st");
  }
  if (j === 2 && k !== 12) {
    return "".concat(i, "nd");
  }
  if (j === 3 && k !== 13) {
    return "".concat(i, "rd");
  }
  return "".concat(i, "th");
}
function formatCalls(spy, msg, showActualCall) {
  if (spy.mock.calls.length) {
    msg += s.gray("\n\nReceived: \n\n".concat(spy.mock.calls.map(function (callArg, i) {
      var methodCall = s.bold("  ".concat(ordinalOf(i + 1), " ").concat(spy.getMockName(), " call:\n\n"));
      if (showActualCall) {
        methodCall += diff(showActualCall, callArg, {
          omitAnnotationLines: true
        });
      } else {
        methodCall += stringify(callArg).split("\n").map(function (line) {
          return "    ".concat(line);
        }).join("\n");
      }
      methodCall += "\n";
      return methodCall;
    }).join("\n")));
  }
  msg += s.gray("\n\nNumber of calls: ".concat(s.bold(spy.mock.calls.length), "\n"));
  return msg;
}
function formatReturns(spy, results, msg, showActualReturn) {
  if (results.length) {
    msg += s.gray("\n\nReceived: \n\n".concat(results.map(function (callReturn, i) {
      var methodCall = s.bold("  ".concat(ordinalOf(i + 1), " ").concat(spy.getMockName(), " call return:\n\n"));
      if (showActualReturn) {
        methodCall += diff(showActualReturn, callReturn.value, {
          omitAnnotationLines: true
        });
      } else {
        methodCall += stringify(callReturn).split("\n").map(function (line) {
          return "    ".concat(line);
        }).join("\n");
      }
      methodCall += "\n";
      return methodCall;
    }).join("\n")));
  }
  msg += s.gray("\n\nNumber of calls: ".concat(s.bold(spy.mock.calls.length), "\n"));
  return msg;
}
function getMatcherState(assertion, expect) {
  var obj = assertion._obj;
  var isNot = utils_exports.flag(assertion, "negate");
  var promise = utils_exports.flag(assertion, "promise") || "";
  var jestUtils = _objectSpread$3(_objectSpread$3({}, getMatcherUtils()), {}, {
    diff: diff,
    stringify: stringify,
    iterableEquality: iterableEquality,
    subsetEquality: subsetEquality
  });
  var matcherState = _objectSpread$3(_objectSpread$3({}, getState(expect)), {}, {
    customTesters: getCustomEqualityTesters(),
    isNot: isNot,
    utils: jestUtils,
    promise: promise,
    equals: equals,
    suppressedErrors: [],
    soft: utils_exports.flag(assertion, "soft"),
    poll: utils_exports.flag(assertion, "poll")
  });
  return {
    state: matcherState,
    isNot: isNot,
    obj: obj
  };
}
var JestExtendError = /*#__PURE__*/function (_Error) {
  function JestExtendError(message, actual, expected) {
    var _this4;
    _classCallCheck(this, JestExtendError);
    _this4 = _callSuper$4(this, JestExtendError, [message]);
    _this4.actual = actual;
    _this4.expected = expected;
    return _this4;
  }
  _inherits(JestExtendError, _Error);
  return _createClass(JestExtendError);
}(/*#__PURE__*/_wrapNativeSuper(Error));
function JestExtendPlugin(c, expect, matchers) {
  return function (_, utils) {
    Object.entries(matchers).forEach(function (_ref11) {
      var _ref12 = _slicedToArray(_ref11, 2),
        expectAssertionName = _ref12[0],
        expectAssertion = _ref12[1];
      function expectWrapper() {
        var _getMatcherState = getMatcherState(this, expect),
          state = _getMatcherState.state,
          isNot = _getMatcherState.isNot,
          obj = _getMatcherState.obj;
        for (var _len0 = arguments.length, args = new Array(_len0), _key0 = 0; _key0 < _len0; _key0++) {
          args[_key0] = arguments[_key0];
        }
        var result = expectAssertion.call.apply(expectAssertion, [state, obj].concat(args));
        if (result && _typeof(result) === "object" && typeof result.then === "function") {
          var thenable = result;
          return thenable.then(function (_ref13) {
            var pass = _ref13.pass,
              message = _ref13.message,
              actual = _ref13.actual,
              expected = _ref13.expected;
            if (pass && isNot || !pass && !isNot) {
              throw new JestExtendError(message(), actual, expected);
            }
          });
        }
        var pass = result.pass,
          message = result.message,
          actual = result.actual,
          expected = result.expected;
        if (pass && isNot || !pass && !isNot) {
          throw new JestExtendError(message(), actual, expected);
        }
      }
      var softWrapper = wrapAssertion(utils, expectAssertionName, expectWrapper);
      utils.addMethod(globalThis[JEST_MATCHERS_OBJECT].matchers, expectAssertionName, softWrapper);
      utils.addMethod(c.Assertion.prototype, expectAssertionName, softWrapper);
      var CustomMatcher = /*#__PURE__*/function (_AsymmetricMatcher9) {
        function CustomMatcher() {
          var inverse = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          _classCallCheck(this, CustomMatcher);
          for (var _len1 = arguments.length, sample = new Array(_len1 > 1 ? _len1 - 1 : 0), _key1 = 1; _key1 < _len1; _key1++) {
            sample[_key1 - 1] = arguments[_key1];
          }
          return _callSuper$4(this, CustomMatcher, [sample, inverse]);
        }
        _inherits(CustomMatcher, _AsymmetricMatcher9);
        return _createClass(CustomMatcher, [{
          key: "asymmetricMatch",
          value: function asymmetricMatch(other) {
            var _expectAssertion$call = expectAssertion.call.apply(expectAssertion, [this.getMatcherContext(expect), other].concat(_toConsumableArray(this.sample))),
              pass = _expectAssertion$call.pass;
            return this.inverse ? !pass : pass;
          }
        }, {
          key: "toString",
          value: function toString() {
            return "".concat(this.inverse ? "not." : "").concat(expectAssertionName);
          }
        }, {
          key: "getExpectedType",
          value: function getExpectedType() {
            return "any";
          }
        }, {
          key: "toAsymmetricMatcher",
          value: function toAsymmetricMatcher() {
            return "".concat(this.toString(), "<").concat(this.sample.map(function (item) {
              return stringify(item);
            }).join(", "), ">");
          }
        }]);
      }(AsymmetricMatcher$1);
      var customMatcher = function customMatcher() {
        for (var _len10 = arguments.length, sample = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
          sample[_key10] = arguments[_key10];
        }
        return _construct(CustomMatcher, [false].concat(sample));
      };
      Object.defineProperty(expect, expectAssertionName, {
        configurable: true,
        enumerable: true,
        value: customMatcher,
        writable: true
      });
      Object.defineProperty(expect.not, expectAssertionName, {
        configurable: true,
        enumerable: true,
        value: function value() {
          for (var _len11 = arguments.length, sample = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
            sample[_key11] = arguments[_key11];
          }
          return _construct(CustomMatcher, [true].concat(sample));
        },
        writable: true
      });
      // keep track of asymmetric matchers on global so that it can be copied over to local context's `expect`.
      // note that the negated variant is automatically shared since it's assigned on the single `expect.not` object.
      Object.defineProperty(globalThis[ASYMMETRIC_MATCHERS_OBJECT], expectAssertionName, {
        configurable: true,
        enumerable: true,
        value: customMatcher,
        writable: true
      });
    });
  };
}
var JestExtend = function JestExtend(chai, utils) {
  utils.addMethod(chai.expect, "extend", function (expect, expects) {
    use(JestExtendPlugin(chai, expect, expects));
  });
};

var chars$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
var intToChar$1 = new Uint8Array(64); // 64 possible chars.
var charToInt$1 = new Uint8Array(128); // z is 122 in ASCII
for (var i$2 = 0; i$2 < chars$1.length; i$2++) {
  var c$1 = chars$1.charCodeAt(i$2);
  intToChar$1[i$2] = c$1;
  charToInt$1[c$1] = i$2;
}
var UrlType$1;
(function (UrlType) {
  UrlType[UrlType["Empty"] = 1] = "Empty";
  UrlType[UrlType["Hash"] = 2] = "Hash";
  UrlType[UrlType["Query"] = 3] = "Query";
  UrlType[UrlType["RelativePath"] = 4] = "RelativePath";
  UrlType[UrlType["AbsolutePath"] = 5] = "AbsolutePath";
  UrlType[UrlType["SchemeRelative"] = 6] = "SchemeRelative";
  UrlType[UrlType["Absolute"] = 7] = "Absolute";
})(UrlType$1 || (UrlType$1 = {}));
var _DRIVE_LETTER_START_RE$1 = /^[A-Za-z]:\//;
function normalizeWindowsPath$1() {
  var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
  if (!input) {
    return input;
  }
  return input.replace(/\\/g, "/").replace(_DRIVE_LETTER_START_RE$1, function (r) {
    return r.toUpperCase();
  });
}
var _IS_ABSOLUTE_RE$1 = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
function cwd$1() {
  if (typeof process !== "undefined" && typeof process.cwd === "function") {
    return process.cwd().replace(/\\/g, "/");
  }
  return "/";
}
var resolve$3 = function resolve() {
  for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
    arguments_[_key] = arguments[_key];
  }
  arguments_ = arguments_.map(function (argument) {
    return normalizeWindowsPath$1(argument);
  });
  var resolvedPath = "";
  var resolvedAbsolute = false;
  for (var index = arguments_.length - 1; index >= -1 && !resolvedAbsolute; index--) {
    var path = index >= 0 ? arguments_[index] : cwd$1();
    if (!path || path.length === 0) {
      continue;
    }
    resolvedPath = "".concat(path, "/").concat(resolvedPath);
    resolvedAbsolute = isAbsolute$1(path);
  }
  resolvedPath = normalizeString$1(resolvedPath, !resolvedAbsolute);
  if (resolvedAbsolute && !isAbsolute$1(resolvedPath)) {
    return "/".concat(resolvedPath);
  }
  return resolvedPath.length > 0 ? resolvedPath : ".";
};
function normalizeString$1(path, allowAboveRoot) {
  var res = "";
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var char = null;
  for (var index = 0; index <= path.length; ++index) {
    if (index < path.length) {
      char = path[index];
    } else if (char === "/") {
      break;
    } else {
      char = "/";
    }
    if (char === "/") {
      if (lastSlash === index - 1 || dots === 1) ;else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== "." || res[res.length - 2] !== ".") {
          if (res.length > 2) {
            var lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
            }
            lastSlash = index;
            dots = 0;
            continue;
          } else if (res.length > 0) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = index;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += "/".concat(path.slice(lastSlash + 1, index));
        } else {
          res = path.slice(lastSlash + 1, index);
        }
        lastSegmentLength = index - lastSlash - 1;
      }
      lastSlash = index;
      dots = 0;
    } else if (char === "." && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
var isAbsolute$1 = function isAbsolute(p) {
  return _IS_ABSOLUTE_RE$1.test(p);
};
var CHROME_IE_STACK_REGEXP$1 = /^\s*at .*(?:\S:\d+|\(native\))/m;
var SAFARI_NATIVE_CODE_REGEXP$1 = /^(?:eval@)?(?:\[native code\])?$/;
function extractLocation$1(urlLike) {
  // Fail-fast but return locations like "(native)"
  if (!urlLike.includes(":")) {
    return [urlLike];
  }
  var regExp = /(.+?)(?::(\d+))?(?::(\d+))?$/;
  var parts = regExp.exec(urlLike.replace(/^\(|\)$/g, ""));
  if (!parts) {
    return [urlLike];
  }
  var url = parts[1];
  if (url.startsWith("async ")) {
    url = url.slice(6);
  }
  if (url.startsWith("http:") || url.startsWith("https:")) {
    var urlObj = new URL(url);
    urlObj.searchParams.delete("import");
    urlObj.searchParams.delete("browserv");
    url = urlObj.pathname + urlObj.hash + urlObj.search;
  }
  if (url.startsWith("/@fs/")) {
    var isWindows = /^\/@fs\/[a-zA-Z]:\//.test(url);
    url = url.slice(isWindows ? 5 : 4);
  }
  return [url, parts[2] || undefined, parts[3] || undefined];
}
function parseSingleFFOrSafariStack$1(raw) {
  var line = raw.trim();
  if (SAFARI_NATIVE_CODE_REGEXP$1.test(line)) {
    return null;
  }
  if (line.includes(" > eval")) {
    line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ":$1");
  }
  if (!line.includes("@") && !line.includes(":")) {
    return null;
  }
  // eslint-disable-next-line regexp/no-super-linear-backtracking, regexp/optimal-quantifier-concatenation
  var functionNameRegex = /((.*".+"[^@]*)?[^@]*)(@)/;
  var matches = line.match(functionNameRegex);
  var functionName = matches && matches[1] ? matches[1] : undefined;
  var _extractLocation = extractLocation$1(line.replace(functionNameRegex, "")),
    _extractLocation2 = _slicedToArray(_extractLocation, 3),
    url = _extractLocation2[0],
    lineNumber = _extractLocation2[1],
    columnNumber = _extractLocation2[2];
  if (!url || !lineNumber || !columnNumber) {
    return null;
  }
  return {
    file: url,
    method: functionName || "",
    line: Number.parseInt(lineNumber),
    column: Number.parseInt(columnNumber)
  };
}
function parseSingleStack(raw) {
  var line = raw.trim();
  if (!CHROME_IE_STACK_REGEXP$1.test(line)) {
    return parseSingleFFOrSafariStack$1(line);
  }
  return parseSingleV8Stack$1(line);
}
// Based on https://github.com/stacktracejs/error-stack-parser
// Credit to stacktracejs
function parseSingleV8Stack$1(raw) {
  var line = raw.trim();
  if (!CHROME_IE_STACK_REGEXP$1.test(line)) {
    return null;
  }
  if (line.includes("(eval ")) {
    line = line.replace(/eval code/g, "eval").replace(/(\(eval at [^()]*)|(,.*$)/g, "");
  }
  var sanitizedLine = line.replace(/^\s+/, "").replace(/\(eval code/g, "(").replace(/^.*?\s+/, "");
  // capture and preserve the parenthesized location "(/foo/my bar.js:12:87)" in
  // case it has spaces in it, as the string is split on \s+ later on
  var location = sanitizedLine.match(/ (\(.+\)$)/);
  // remove the parenthesized location from the line, if it was matched
  sanitizedLine = location ? sanitizedLine.replace(location[0], "") : sanitizedLine;
  // if a location was matched, pass it to extractLocation() otherwise pass all sanitizedLine
  // because this line doesn't have function name
  var _extractLocation3 = extractLocation$1(location ? location[1] : sanitizedLine),
    _extractLocation4 = _slicedToArray(_extractLocation3, 3),
    url = _extractLocation4[0],
    lineNumber = _extractLocation4[1],
    columnNumber = _extractLocation4[2];
  var method = location && sanitizedLine || "";
  var file = url && ["eval", "<anonymous>"].includes(url) ? undefined : url;
  if (!file || !lineNumber || !columnNumber) {
    return null;
  }
  if (method.startsWith("async ")) {
    method = method.slice(6);
  }
  if (file.startsWith("file://")) {
    file = file.slice(7);
  }
  // normalize Windows path (\ -> /)
  file = file.startsWith("node:") || file.startsWith("internal:") ? file : resolve$3(file);
  if (method) {
    method = method.replace(/__vite_ssr_import_\d+__\./g, "");
  }
  return {
    method: method,
    file: file,
    line: Number.parseInt(lineNumber),
    column: Number.parseInt(columnNumber)
  };
}

// Copyright 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023 Simon Lydell
// License: MIT.
var HashbangComment, Identifier, JSXIdentifier, JSXPunctuator, JSXString, JSXText, KeywordsWithExpressionAfter, KeywordsWithNoLineTerminatorAfter, LineTerminatorSequence, MultiLineComment, Newline, NumericLiteral, Punctuator, RegularExpressionLiteral, SingleLineComment, StringLiteral, Template, TokensNotPrecedingObjectLiteral, TokensPrecedingExpression, WhiteSpace;
RegularExpressionLiteral = new RegExp("\\/(?![\\*\\/])(?:\\[(?:(?:[\\0-\\t\\x0B\\f\\x0E-\\[\\^-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+|\\\\(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]))*\\]?|(?:[\\0-\\t\\x0B\\f\\x0E-\\.0-Z\\]-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+|\\\\(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]))*(\\/(?:[\\$0-9A-Z_a-z\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u07FD\\u0800-\\u082D\\u0840-\\u085B\\u0860-\\u086A\\u0870-\\u0887\\u0889-\\u088F\\u0897-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u09FC\\u09FE\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9-\\u0AFF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B55-\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3C-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C5C\\u0C5D\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDC-\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1-\\u0CF3\\u0D00-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D81-\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECE\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u1715\\u171F-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u180F-\\u1819\\u1820-\\u1878\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1ABF-\\u1ADD\\u1AE0-\\u1AEB\\u1B00-\\u1B4C\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C8A\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CD0-\\u1CD2\\u1CD4-\\u1CFA\\u1D00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7DC\\uA7F1-\\uA827\\uA82C\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF65-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDD70-\\uDD7A\\uDD7C-\\uDD8A\\uDD8C-\\uDD92\\uDD94\\uDD95\\uDD97-\\uDDA1\\uDDA3-\\uDDB1\\uDDB3-\\uDDB9\\uDDBB\\uDDBC\\uDDC0-\\uDDF3\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67\\uDF80-\\uDF85\\uDF87-\\uDFB0\\uDFB2-\\uDFBA]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD40-\\uDD59\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD27\\uDD30-\\uDD39\\uDD40-\\uDD65\\uDD69-\\uDD6D\\uDD6F-\\uDD85\\uDE80-\\uDEA9\\uDEAB\\uDEAC\\uDEB0\\uDEB1\\uDEC2-\\uDEC7\\uDEFA-\\uDF1C\\uDF27\\uDF30-\\uDF50\\uDF70-\\uDF85\\uDFB0-\\uDFC4\\uDFE0-\\uDFF6]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC75\\uDC7F-\\uDCBA\\uDCC2\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD44-\\uDD47\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDC9-\\uDDCC\\uDDCE-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E-\\uDE41\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3B-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74\\uDF80-\\uDF89\\uDF8B\\uDF8E\\uDF90-\\uDFB5\\uDFB7-\\uDFC0\\uDFC2\\uDFC5\\uDFC7-\\uDFCA\\uDFCC-\\uDFD3\\uDFE1\\uDFE2]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC5E-\\uDC61\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB8\\uDEC0-\\uDEC9\\uDED0-\\uDEE3\\uDF00-\\uDF1A\\uDF1D-\\uDF2B\\uDF30-\\uDF39\\uDF40-\\uDF46]|\\uD806[\\uDC00-\\uDC3A\\uDCA0-\\uDCE9\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD35\\uDD37\\uDD38\\uDD3B-\\uDD43\\uDD50-\\uDD59\\uDDA0-\\uDDA7\\uDDAA-\\uDDD7\\uDDDA-\\uDDE1\\uDDE3\\uDDE4\\uDE00-\\uDE3E\\uDE47\\uDE50-\\uDE99\\uDE9D\\uDEB0-\\uDEF8\\uDF60-\\uDF67\\uDFC0-\\uDFE0\\uDFF0-\\uDFF9]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD47\\uDD50-\\uDD59\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD8E\\uDD90\\uDD91\\uDD93-\\uDD98\\uDDA0-\\uDDA9\\uDDB0-\\uDDDB\\uDDE0-\\uDDE9\\uDEE0-\\uDEF6\\uDF00-\\uDF10\\uDF12-\\uDF3A\\uDF3E-\\uDF42\\uDF50-\\uDF5A\\uDFB0]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|\\uD80B[\\uDF90-\\uDFF0]|[\\uD80C\\uD80E\\uD80F\\uD81C-\\uD822\\uD840-\\uD868\\uD86A-\\uD86D\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883\\uD885-\\uD88C][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2F\\uDC40-\\uDC55\\uDC60-\\uDFFF]|\\uD810[\\uDC00-\\uDFFA]|\\uD811[\\uDC00-\\uDE46]|\\uD818[\\uDD00-\\uDD39]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDE70-\\uDEBE\\uDEC0-\\uDEC9\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDD40-\\uDD6C\\uDD70-\\uDD79\\uDE40-\\uDE7F\\uDEA0-\\uDEB8\\uDEBB-\\uDED3\\uDF00-\\uDF4A\\uDF4F-\\uDF87\\uDF8F-\\uDF9F\\uDFE0\\uDFE1\\uDFE3\\uDFE4\\uDFF0-\\uDFF6]|\\uD823[\\uDC00-\\uDCD5\\uDCFF-\\uDD1E\\uDD80-\\uDDF2]|\\uD82B[\\uDFF0-\\uDFF3\\uDFF5-\\uDFFB\\uDFFD\\uDFFE]|\\uD82C[\\uDC00-\\uDD22\\uDD32\\uDD50-\\uDD52\\uDD55\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD833[\\uDCF0-\\uDCF9\\uDF00-\\uDF2D\\uDF30-\\uDF46]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD837[\\uDF00-\\uDF1E\\uDF25-\\uDF2A]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDC30-\\uDC6D\\uDC8F\\uDD00-\\uDD2C\\uDD30-\\uDD3D\\uDD40-\\uDD49\\uDD4E\\uDE90-\\uDEAE\\uDEC0-\\uDEF9]|\\uD839[\\uDCD0-\\uDCF9\\uDDD0-\\uDDFA\\uDEC0-\\uDEDE\\uDEE0-\\uDEF5\\uDEFE\\uDEFF\\uDFE0-\\uDFE6\\uDFE8-\\uDFEB\\uDFED\\uDFEE\\uDFF0-\\uDFFE]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4B\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD83E[\\uDFF0-\\uDFF9]|\\uD869[\\uDC00-\\uDEDF\\uDF00-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEAD\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0\\uDFF0-\\uDFFF]|\\uD87B[\\uDC00-\\uDE5D]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A\\uDF50-\\uDFFF]|\\uD88D[\\uDC00-\\uDC79]|\\uDB40[\\uDD00-\\uDDEF])*|\\\\)?", "y");
Punctuator = new RegExp("--|\\+\\+|=>|\\.{3}|\\??\\.(?!\\d)|(?:&&|\\|\\||\\?\\?|[+\\-%&|^]|\\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\\/(?![\\/*]))=?|[?~,:;[\\](){}]", "y");
Identifier = new RegExp("(#?)(?=(?:[\\$A-Z\\\\_a-z\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u0870-\\u0887\\u0889-\\u088F\\u08A0-\\u08C9\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C5C\\u0C5D\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDC-\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D04-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u1711\\u171F-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1878\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4C\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C8A\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7DC\\uA7F1-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDD70-\\uDD7A\\uDD7C-\\uDD8A\\uDD8C-\\uDD92\\uDD94\\uDD95\\uDD97-\\uDDA1\\uDDA3-\\uDDB1\\uDDB3-\\uDDB9\\uDDBB\\uDDBC\\uDDC0-\\uDDF3\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67\\uDF80-\\uDF85\\uDF87-\\uDFB0\\uDFB2-\\uDFBA]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD40-\\uDD59\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD23\\uDD4A-\\uDD65\\uDD6F-\\uDD85\\uDE80-\\uDEA9\\uDEB0\\uDEB1\\uDEC2-\\uDEC7\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF45\\uDF70-\\uDF81\\uDFB0-\\uDFC4\\uDFE0-\\uDFF6]|\\uD804[\\uDC03-\\uDC37\\uDC71\\uDC72\\uDC75\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD44\\uDD47\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE3F\\uDE40\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61\\uDF80-\\uDF89\\uDF8B\\uDF8E\\uDF90-\\uDFB5\\uDFB7\\uDFD1\\uDFD3]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC5F-\\uDC61\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDEB8\\uDF00-\\uDF1A\\uDF40-\\uDF46]|\\uD806[\\uDC00-\\uDC2B\\uDCA0-\\uDCDF\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD2F\\uDD3F\\uDD41\\uDDA0-\\uDDA7\\uDDAA-\\uDDD0\\uDDE1\\uDDE3\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE89\\uDE9D\\uDEB0-\\uDEF8\\uDFC0-\\uDFE0]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD89\\uDD98\\uDDB0-\\uDDDB\\uDEE0-\\uDEF2\\uDF02\\uDF04-\\uDF10\\uDF12-\\uDF33\\uDFB0]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|\\uD80B[\\uDF90-\\uDFF0]|[\\uD80C\\uD80E\\uD80F\\uD81C-\\uD822\\uD840-\\uD868\\uD86A-\\uD86D\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883\\uD885-\\uD88C][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2F\\uDC41-\\uDC46\\uDC60-\\uDFFF]|\\uD810[\\uDC00-\\uDFFA]|\\uD811[\\uDC00-\\uDE46]|\\uD818[\\uDD00-\\uDD1D]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE70-\\uDEBE\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDD40-\\uDD6C\\uDE40-\\uDE7F\\uDEA0-\\uDEB8\\uDEBB-\\uDED3\\uDF00-\\uDF4A\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1\\uDFE3\\uDFF2-\\uDFF6]|\\uD823[\\uDC00-\\uDCD5\\uDCFF-\\uDD1E\\uDD80-\\uDDF2]|\\uD82B[\\uDFF0-\\uDFF3\\uDFF5-\\uDFFB\\uDFFD\\uDFFE]|\\uD82C[\\uDC00-\\uDD22\\uDD32\\uDD50-\\uDD52\\uDD55\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD837[\\uDF00-\\uDF1E\\uDF25-\\uDF2A]|\\uD838[\\uDC30-\\uDC6D\\uDD00-\\uDD2C\\uDD37-\\uDD3D\\uDD4E\\uDE90-\\uDEAD\\uDEC0-\\uDEEB]|\\uD839[\\uDCD0-\\uDCEB\\uDDD0-\\uDDED\\uDDF0\\uDEC0-\\uDEDE\\uDEE0-\\uDEE2\\uDEE4\\uDEE5\\uDEE7-\\uDEED\\uDEF0-\\uDEF4\\uDEFE\\uDEFF\\uDFE0-\\uDFE6\\uDFE8-\\uDFEB\\uDFED\\uDFEE\\uDFF0-\\uDFFE]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43\\uDD4B]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDEDF\\uDF00-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEAD\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0\\uDFF0-\\uDFFF]|\\uD87B[\\uDC00-\\uDE5D]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A\\uDF50-\\uDFFF]|\\uD88D[\\uDC00-\\uDC79]))(?:(?:[\\$0-9A-Z_a-z\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u07FD\\u0800-\\u082D\\u0840-\\u085B\\u0860-\\u086A\\u0870-\\u0887\\u0889-\\u088F\\u0897-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u09FC\\u09FE\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9-\\u0AFF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B55-\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3C-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C5C\\u0C5D\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDC-\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1-\\u0CF3\\u0D00-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D81-\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECE\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u1715\\u171F-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u180F-\\u1819\\u1820-\\u1878\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1ABF-\\u1ADD\\u1AE0-\\u1AEB\\u1B00-\\u1B4C\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C8A\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CD0-\\u1CD2\\u1CD4-\\u1CFA\\u1D00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7DC\\uA7F1-\\uA827\\uA82C\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF65-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDD70-\\uDD7A\\uDD7C-\\uDD8A\\uDD8C-\\uDD92\\uDD94\\uDD95\\uDD97-\\uDDA1\\uDDA3-\\uDDB1\\uDDB3-\\uDDB9\\uDDBB\\uDDBC\\uDDC0-\\uDDF3\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67\\uDF80-\\uDF85\\uDF87-\\uDFB0\\uDFB2-\\uDFBA]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD40-\\uDD59\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD27\\uDD30-\\uDD39\\uDD40-\\uDD65\\uDD69-\\uDD6D\\uDD6F-\\uDD85\\uDE80-\\uDEA9\\uDEAB\\uDEAC\\uDEB0\\uDEB1\\uDEC2-\\uDEC7\\uDEFA-\\uDF1C\\uDF27\\uDF30-\\uDF50\\uDF70-\\uDF85\\uDFB0-\\uDFC4\\uDFE0-\\uDFF6]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC75\\uDC7F-\\uDCBA\\uDCC2\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD44-\\uDD47\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDC9-\\uDDCC\\uDDCE-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E-\\uDE41\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3B-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74\\uDF80-\\uDF89\\uDF8B\\uDF8E\\uDF90-\\uDFB5\\uDFB7-\\uDFC0\\uDFC2\\uDFC5\\uDFC7-\\uDFCA\\uDFCC-\\uDFD3\\uDFE1\\uDFE2]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC5E-\\uDC61\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB8\\uDEC0-\\uDEC9\\uDED0-\\uDEE3\\uDF00-\\uDF1A\\uDF1D-\\uDF2B\\uDF30-\\uDF39\\uDF40-\\uDF46]|\\uD806[\\uDC00-\\uDC3A\\uDCA0-\\uDCE9\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD35\\uDD37\\uDD38\\uDD3B-\\uDD43\\uDD50-\\uDD59\\uDDA0-\\uDDA7\\uDDAA-\\uDDD7\\uDDDA-\\uDDE1\\uDDE3\\uDDE4\\uDE00-\\uDE3E\\uDE47\\uDE50-\\uDE99\\uDE9D\\uDEB0-\\uDEF8\\uDF60-\\uDF67\\uDFC0-\\uDFE0\\uDFF0-\\uDFF9]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD47\\uDD50-\\uDD59\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD8E\\uDD90\\uDD91\\uDD93-\\uDD98\\uDDA0-\\uDDA9\\uDDB0-\\uDDDB\\uDDE0-\\uDDE9\\uDEE0-\\uDEF6\\uDF00-\\uDF10\\uDF12-\\uDF3A\\uDF3E-\\uDF42\\uDF50-\\uDF5A\\uDFB0]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|\\uD80B[\\uDF90-\\uDFF0]|[\\uD80C\\uD80E\\uD80F\\uD81C-\\uD822\\uD840-\\uD868\\uD86A-\\uD86D\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883\\uD885-\\uD88C][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2F\\uDC40-\\uDC55\\uDC60-\\uDFFF]|\\uD810[\\uDC00-\\uDFFA]|\\uD811[\\uDC00-\\uDE46]|\\uD818[\\uDD00-\\uDD39]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDE70-\\uDEBE\\uDEC0-\\uDEC9\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDD40-\\uDD6C\\uDD70-\\uDD79\\uDE40-\\uDE7F\\uDEA0-\\uDEB8\\uDEBB-\\uDED3\\uDF00-\\uDF4A\\uDF4F-\\uDF87\\uDF8F-\\uDF9F\\uDFE0\\uDFE1\\uDFE3\\uDFE4\\uDFF0-\\uDFF6]|\\uD823[\\uDC00-\\uDCD5\\uDCFF-\\uDD1E\\uDD80-\\uDDF2]|\\uD82B[\\uDFF0-\\uDFF3\\uDFF5-\\uDFFB\\uDFFD\\uDFFE]|\\uD82C[\\uDC00-\\uDD22\\uDD32\\uDD50-\\uDD52\\uDD55\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD833[\\uDCF0-\\uDCF9\\uDF00-\\uDF2D\\uDF30-\\uDF46]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD837[\\uDF00-\\uDF1E\\uDF25-\\uDF2A]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDC30-\\uDC6D\\uDC8F\\uDD00-\\uDD2C\\uDD30-\\uDD3D\\uDD40-\\uDD49\\uDD4E\\uDE90-\\uDEAE\\uDEC0-\\uDEF9]|\\uD839[\\uDCD0-\\uDCF9\\uDDD0-\\uDDFA\\uDEC0-\\uDEDE\\uDEE0-\\uDEF5\\uDEFE\\uDEFF\\uDFE0-\\uDFE6\\uDFE8-\\uDFEB\\uDFED\\uDFEE\\uDFF0-\\uDFFE]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4B\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD83E[\\uDFF0-\\uDFF9]|\\uD869[\\uDC00-\\uDEDF\\uDF00-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEAD\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0\\uDFF0-\\uDFFF]|\\uD87B[\\uDC00-\\uDE5D]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A\\uDF50-\\uDFFF]|\\uD88D[\\uDC00-\\uDC79]|\\uDB40[\\uDD00-\\uDDEF])+|\\\\u[0-9A-Fa-f]{4}|\\\\u\\{[0-9A-Fa-f]+\\})+", "y");
StringLiteral = new RegExp("(['\"])(?:[^'\"\\\\\\n\\r]+|(?!\\1)['\"]|\\\\(?:\\r\\n|[^]))*(\\1)?", "y");
NumericLiteral = new RegExp("(?:0[xX][\\da-fA-F](?:_?[\\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\\d)*n|(?:(?:0(?!\\d)|0\\d*[89]\\d*|[1-9](?:_?\\d)*)(?:\\.(?:\\d(?:_?\\d)*)?)?|\\.\\d(?:_?\\d)*)(?:[eE][+-]?\\d(?:_?\\d)*)?|0[0-7]+", "y");
Template = new RegExp("[`}](?:[^`\\\\$]+|\\\\[^]|\\$(?!\\{))*(`|\\$\\{)?", "y");
WhiteSpace = new RegExp("[\\t\\x0B\\f \\xA0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000\\uFEFF]+", "y");
LineTerminatorSequence = new RegExp("\\r?\\n|[\\r\\u2028\\u2029]", "y");
MultiLineComment = new RegExp("\\/\\*(?:[^*]+|\\*(?!\\/))*(\\*\\/)?", "y");
SingleLineComment = new RegExp("\\/\\/.*", "y");
HashbangComment = /^#!.*/;
JSXPunctuator = new RegExp("[<>.:={}]|\\/(?![\\/*])", "y");
JSXIdentifier = new RegExp("(?:[\\$A-Z_a-z\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u0870-\\u0887\\u0889-\\u088F\\u08A0-\\u08C9\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C5C\\u0C5D\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDC-\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D04-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u1711\\u171F-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1878\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4C\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C8A\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7DC\\uA7F1-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDD70-\\uDD7A\\uDD7C-\\uDD8A\\uDD8C-\\uDD92\\uDD94\\uDD95\\uDD97-\\uDDA1\\uDDA3-\\uDDB1\\uDDB3-\\uDDB9\\uDDBB\\uDDBC\\uDDC0-\\uDDF3\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67\\uDF80-\\uDF85\\uDF87-\\uDFB0\\uDFB2-\\uDFBA]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD40-\\uDD59\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD23\\uDD4A-\\uDD65\\uDD6F-\\uDD85\\uDE80-\\uDEA9\\uDEB0\\uDEB1\\uDEC2-\\uDEC7\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF45\\uDF70-\\uDF81\\uDFB0-\\uDFC4\\uDFE0-\\uDFF6]|\\uD804[\\uDC03-\\uDC37\\uDC71\\uDC72\\uDC75\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD44\\uDD47\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE3F\\uDE40\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61\\uDF80-\\uDF89\\uDF8B\\uDF8E\\uDF90-\\uDFB5\\uDFB7\\uDFD1\\uDFD3]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC5F-\\uDC61\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDEB8\\uDF00-\\uDF1A\\uDF40-\\uDF46]|\\uD806[\\uDC00-\\uDC2B\\uDCA0-\\uDCDF\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD2F\\uDD3F\\uDD41\\uDDA0-\\uDDA7\\uDDAA-\\uDDD0\\uDDE1\\uDDE3\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE89\\uDE9D\\uDEB0-\\uDEF8\\uDFC0-\\uDFE0]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD89\\uDD98\\uDDB0-\\uDDDB\\uDEE0-\\uDEF2\\uDF02\\uDF04-\\uDF10\\uDF12-\\uDF33\\uDFB0]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|\\uD80B[\\uDF90-\\uDFF0]|[\\uD80C\\uD80E\\uD80F\\uD81C-\\uD822\\uD840-\\uD868\\uD86A-\\uD86D\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883\\uD885-\\uD88C][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2F\\uDC41-\\uDC46\\uDC60-\\uDFFF]|\\uD810[\\uDC00-\\uDFFA]|\\uD811[\\uDC00-\\uDE46]|\\uD818[\\uDD00-\\uDD1D]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE70-\\uDEBE\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDD40-\\uDD6C\\uDE40-\\uDE7F\\uDEA0-\\uDEB8\\uDEBB-\\uDED3\\uDF00-\\uDF4A\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1\\uDFE3\\uDFF2-\\uDFF6]|\\uD823[\\uDC00-\\uDCD5\\uDCFF-\\uDD1E\\uDD80-\\uDDF2]|\\uD82B[\\uDFF0-\\uDFF3\\uDFF5-\\uDFFB\\uDFFD\\uDFFE]|\\uD82C[\\uDC00-\\uDD22\\uDD32\\uDD50-\\uDD52\\uDD55\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD837[\\uDF00-\\uDF1E\\uDF25-\\uDF2A]|\\uD838[\\uDC30-\\uDC6D\\uDD00-\\uDD2C\\uDD37-\\uDD3D\\uDD4E\\uDE90-\\uDEAD\\uDEC0-\\uDEEB]|\\uD839[\\uDCD0-\\uDCEB\\uDDD0-\\uDDED\\uDDF0\\uDEC0-\\uDEDE\\uDEE0-\\uDEE2\\uDEE4\\uDEE5\\uDEE7-\\uDEED\\uDEF0-\\uDEF4\\uDEFE\\uDEFF\\uDFE0-\\uDFE6\\uDFE8-\\uDFEB\\uDFED\\uDFEE\\uDFF0-\\uDFFE]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43\\uDD4B]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDEDF\\uDF00-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEAD\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0\\uDFF0-\\uDFFF]|\\uD87B[\\uDC00-\\uDE5D]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A\\uDF50-\\uDFFF]|\\uD88D[\\uDC00-\\uDC79])(?:[\\$\\x2D0-9A-Z_a-z\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u07FD\\u0800-\\u082D\\u0840-\\u085B\\u0860-\\u086A\\u0870-\\u0887\\u0889-\\u088F\\u0897-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u09FC\\u09FE\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9-\\u0AFF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B55-\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3C-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C5C\\u0C5D\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDC-\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1-\\u0CF3\\u0D00-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D81-\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECE\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u1715\\u171F-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u180F-\\u1819\\u1820-\\u1878\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1ABF-\\u1ADD\\u1AE0-\\u1AEB\\u1B00-\\u1B4C\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C8A\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CD0-\\u1CD2\\u1CD4-\\u1CFA\\u1D00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7DC\\uA7F1-\\uA827\\uA82C\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF65-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDD70-\\uDD7A\\uDD7C-\\uDD8A\\uDD8C-\\uDD92\\uDD94\\uDD95\\uDD97-\\uDDA1\\uDDA3-\\uDDB1\\uDDB3-\\uDDB9\\uDDBB\\uDDBC\\uDDC0-\\uDDF3\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67\\uDF80-\\uDF85\\uDF87-\\uDFB0\\uDFB2-\\uDFBA]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD40-\\uDD59\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD27\\uDD30-\\uDD39\\uDD40-\\uDD65\\uDD69-\\uDD6D\\uDD6F-\\uDD85\\uDE80-\\uDEA9\\uDEAB\\uDEAC\\uDEB0\\uDEB1\\uDEC2-\\uDEC7\\uDEFA-\\uDF1C\\uDF27\\uDF30-\\uDF50\\uDF70-\\uDF85\\uDFB0-\\uDFC4\\uDFE0-\\uDFF6]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC75\\uDC7F-\\uDCBA\\uDCC2\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD44-\\uDD47\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDC9-\\uDDCC\\uDDCE-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E-\\uDE41\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3B-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74\\uDF80-\\uDF89\\uDF8B\\uDF8E\\uDF90-\\uDFB5\\uDFB7-\\uDFC0\\uDFC2\\uDFC5\\uDFC7-\\uDFCA\\uDFCC-\\uDFD3\\uDFE1\\uDFE2]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC5E-\\uDC61\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB8\\uDEC0-\\uDEC9\\uDED0-\\uDEE3\\uDF00-\\uDF1A\\uDF1D-\\uDF2B\\uDF30-\\uDF39\\uDF40-\\uDF46]|\\uD806[\\uDC00-\\uDC3A\\uDCA0-\\uDCE9\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD35\\uDD37\\uDD38\\uDD3B-\\uDD43\\uDD50-\\uDD59\\uDDA0-\\uDDA7\\uDDAA-\\uDDD7\\uDDDA-\\uDDE1\\uDDE3\\uDDE4\\uDE00-\\uDE3E\\uDE47\\uDE50-\\uDE99\\uDE9D\\uDEB0-\\uDEF8\\uDF60-\\uDF67\\uDFC0-\\uDFE0\\uDFF0-\\uDFF9]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD47\\uDD50-\\uDD59\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD8E\\uDD90\\uDD91\\uDD93-\\uDD98\\uDDA0-\\uDDA9\\uDDB0-\\uDDDB\\uDDE0-\\uDDE9\\uDEE0-\\uDEF6\\uDF00-\\uDF10\\uDF12-\\uDF3A\\uDF3E-\\uDF42\\uDF50-\\uDF5A\\uDFB0]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|\\uD80B[\\uDF90-\\uDFF0]|[\\uD80C\\uD80E\\uD80F\\uD81C-\\uD822\\uD840-\\uD868\\uD86A-\\uD86D\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883\\uD885-\\uD88C][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2F\\uDC40-\\uDC55\\uDC60-\\uDFFF]|\\uD810[\\uDC00-\\uDFFA]|\\uD811[\\uDC00-\\uDE46]|\\uD818[\\uDD00-\\uDD39]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDE70-\\uDEBE\\uDEC0-\\uDEC9\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDD40-\\uDD6C\\uDD70-\\uDD79\\uDE40-\\uDE7F\\uDEA0-\\uDEB8\\uDEBB-\\uDED3\\uDF00-\\uDF4A\\uDF4F-\\uDF87\\uDF8F-\\uDF9F\\uDFE0\\uDFE1\\uDFE3\\uDFE4\\uDFF0-\\uDFF6]|\\uD823[\\uDC00-\\uDCD5\\uDCFF-\\uDD1E\\uDD80-\\uDDF2]|\\uD82B[\\uDFF0-\\uDFF3\\uDFF5-\\uDFFB\\uDFFD\\uDFFE]|\\uD82C[\\uDC00-\\uDD22\\uDD32\\uDD50-\\uDD52\\uDD55\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD833[\\uDCF0-\\uDCF9\\uDF00-\\uDF2D\\uDF30-\\uDF46]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD837[\\uDF00-\\uDF1E\\uDF25-\\uDF2A]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDC30-\\uDC6D\\uDC8F\\uDD00-\\uDD2C\\uDD30-\\uDD3D\\uDD40-\\uDD49\\uDD4E\\uDE90-\\uDEAE\\uDEC0-\\uDEF9]|\\uD839[\\uDCD0-\\uDCF9\\uDDD0-\\uDDFA\\uDEC0-\\uDEDE\\uDEE0-\\uDEF5\\uDEFE\\uDEFF\\uDFE0-\\uDFE6\\uDFE8-\\uDFEB\\uDFED\\uDFEE\\uDFF0-\\uDFFE]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4B\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD83E[\\uDFF0-\\uDFF9]|\\uD869[\\uDC00-\\uDEDF\\uDF00-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEAD\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0\\uDFF0-\\uDFFF]|\\uD87B[\\uDC00-\\uDE5D]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A\\uDF50-\\uDFFF]|\\uD88D[\\uDC00-\\uDC79]|\\uDB40[\\uDD00-\\uDDEF])*", "y");
JSXString = new RegExp("(['\"])(?:[^'\"]+|(?!\\1)['\"])*(\\1)?", "y");
JSXText = new RegExp("[^<>{}]+", "y");
TokensPrecedingExpression = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/;
TokensNotPrecedingObjectLiteral = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/;
KeywordsWithExpressionAfter = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/;
KeywordsWithNoLineTerminatorAfter = /^(?:return|throw|yield)$/;
Newline = RegExp(LineTerminatorSequence.source);
var jsTokens_1$1 = function jsTokens(input) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    _ref$jsx = _ref.jsx,
    jsx = _ref$jsx === void 0 ? false : _ref$jsx;
  return /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
    var braces, firstCodePoint, isExpression, lastIndex, lastSignificantToken, length, match, mode, nextLastIndex, nextLastSignificantToken, parenNesting, postfixIncDec, punctuator, stack, _t, _t2, _t3, _t4, _t5;
    return _regeneratorRuntime.wrap(function (_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          length = input.length;
          lastIndex = 0;
          lastSignificantToken = "";
          stack = [{
            tag: "JS"
          }];
          braces = [];
          parenNesting = 0;
          postfixIncDec = false;
          if (!(match = HashbangComment.exec(input))) {
            _context.next = 2;
            break;
          }
          _context.next = 1;
          return {
            type: "HashbangComment",
            value: match[0]
          };
        case 1:
          lastIndex = match[0].length;
        case 2:
          if (!(lastIndex < length)) {
            _context.next = 66;
            break;
          }
          mode = stack[stack.length - 1];
          _t = mode.tag;
          _context.next = _t === "JS" ? 3 : _t === "JSNonExpressionParen" ? 3 : _t === "InterpolationInTemplate" ? 3 : _t === "InterpolationInJSX" ? 3 : _t === "JSXTag" ? 37 : _t === "JSXTagEnd" ? 37 : _t === "JSXChildren" ? 49 : 56;
          break;
        case 3:
          if (!(input[lastIndex] === "/" && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken)))) {
            _context.next = 5;
            break;
          }
          RegularExpressionLiteral.lastIndex = lastIndex;
          if (!(match = RegularExpressionLiteral.exec(input))) {
            _context.next = 5;
            break;
          }
          lastIndex = RegularExpressionLiteral.lastIndex;
          lastSignificantToken = match[0];
          postfixIncDec = true;
          _context.next = 4;
          return {
            type: "RegularExpressionLiteral",
            value: match[0],
            closed: match[1] !== void 0 && match[1] !== "\\"
          };
        case 4:
          return _context.abrupt("continue", 2);
        case 5:
          Punctuator.lastIndex = lastIndex;
          if (!(match = Punctuator.exec(input))) {
            _context.next = 26;
            break;
          }
          punctuator = match[0];
          nextLastIndex = Punctuator.lastIndex;
          nextLastSignificantToken = punctuator;
          _t2 = punctuator;
          _context.next = _t2 === "(" ? 6 : _t2 === ")" ? 7 : _t2 === "{" ? 8 : _t2 === "}" ? 9 : _t2 === "]" ? 18 : _t2 === "++" ? 19 : _t2 === "--" ? 19 : _t2 === "<" ? 20 : 23;
          break;
        case 6:
          if (lastSignificantToken === "?NonExpressionParenKeyword") {
            stack.push({
              tag: "JSNonExpressionParen",
              nesting: parenNesting
            });
          }
          parenNesting++;
          postfixIncDec = false;
          return _context.abrupt("continue", 24);
        case 7:
          parenNesting--;
          postfixIncDec = true;
          if (mode.tag === "JSNonExpressionParen" && parenNesting === mode.nesting) {
            stack.pop();
            nextLastSignificantToken = "?NonExpressionParenEnd";
            postfixIncDec = false;
          }
          return _context.abrupt("continue", 24);
        case 8:
          Punctuator.lastIndex = 0;
          isExpression = !TokensNotPrecedingObjectLiteral.test(lastSignificantToken) && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken));
          braces.push(isExpression);
          postfixIncDec = false;
          return _context.abrupt("continue", 24);
        case 9:
          _t3 = mode.tag;
          _context.next = _t3 === "InterpolationInTemplate" ? 10 : _t3 === "InterpolationInJSX" ? 15 : 17;
          break;
        case 10:
          if (!(braces.length === mode.nesting)) {
            _context.next = 14;
            break;
          }
          Template.lastIndex = lastIndex;
          match = Template.exec(input);
          lastIndex = Template.lastIndex;
          lastSignificantToken = match[0];
          if (!(match[1] === "${")) {
            _context.next = 12;
            break;
          }
          lastSignificantToken = "?InterpolationInTemplate";
          postfixIncDec = false;
          _context.next = 11;
          return {
            type: "TemplateMiddle",
            value: match[0]
          };
        case 11:
          _context.next = 13;
          break;
        case 12:
          stack.pop();
          postfixIncDec = true;
          _context.next = 13;
          return {
            type: "TemplateTail",
            value: match[0],
            closed: match[1] === "`"
          };
        case 13:
          return _context.abrupt("continue", 2);
        case 14:
          return _context.abrupt("continue", 17);
        case 15:
          if (!(braces.length === mode.nesting)) {
            _context.next = 17;
            break;
          }
          stack.pop();
          lastIndex += 1;
          lastSignificantToken = "}";
          _context.next = 16;
          return {
            type: "JSXPunctuator",
            value: "}"
          };
        case 16:
          return _context.abrupt("continue", 2);
        case 17:
          postfixIncDec = braces.pop();
          nextLastSignificantToken = postfixIncDec ? "?ExpressionBraceEnd" : "}";
          return _context.abrupt("continue", 24);
        case 18:
          postfixIncDec = true;
          return _context.abrupt("continue", 24);
        case 19:
          nextLastSignificantToken = postfixIncDec ? "?PostfixIncDec" : "?UnaryIncDec";
          return _context.abrupt("continue", 24);
        case 20:
          if (!(jsx && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken)))) {
            _context.next = 22;
            break;
          }
          stack.push({
            tag: "JSXTag"
          });
          lastIndex += 1;
          lastSignificantToken = "<";
          _context.next = 21;
          return {
            type: "JSXPunctuator",
            value: punctuator
          };
        case 21:
          return _context.abrupt("continue", 2);
        case 22:
          postfixIncDec = false;
          return _context.abrupt("continue", 24);
        case 23:
          postfixIncDec = false;
        case 24:
          lastIndex = nextLastIndex;
          lastSignificantToken = nextLastSignificantToken;
          _context.next = 25;
          return {
            type: "Punctuator",
            value: punctuator
          };
        case 25:
          return _context.abrupt("continue", 2);
        case 26:
          Identifier.lastIndex = lastIndex;
          if (!(match = Identifier.exec(input))) {
            _context.next = 28;
            break;
          }
          lastIndex = Identifier.lastIndex;
          nextLastSignificantToken = match[0];
          switch (match[0]) {
            case "for":
            case "if":
            case "while":
            case "with":
              if (lastSignificantToken !== "." && lastSignificantToken !== "?.") {
                nextLastSignificantToken = "?NonExpressionParenKeyword";
              }
          }
          lastSignificantToken = nextLastSignificantToken;
          postfixIncDec = !KeywordsWithExpressionAfter.test(match[0]);
          _context.next = 27;
          return {
            type: match[1] === "#" ? "PrivateIdentifier" : "IdentifierName",
            value: match[0]
          };
        case 27:
          return _context.abrupt("continue", 2);
        case 28:
          StringLiteral.lastIndex = lastIndex;
          if (!(match = StringLiteral.exec(input))) {
            _context.next = 30;
            break;
          }
          lastIndex = StringLiteral.lastIndex;
          lastSignificantToken = match[0];
          postfixIncDec = true;
          _context.next = 29;
          return {
            type: "StringLiteral",
            value: match[0],
            closed: match[2] !== void 0
          };
        case 29:
          return _context.abrupt("continue", 2);
        case 30:
          NumericLiteral.lastIndex = lastIndex;
          if (!(match = NumericLiteral.exec(input))) {
            _context.next = 32;
            break;
          }
          lastIndex = NumericLiteral.lastIndex;
          lastSignificantToken = match[0];
          postfixIncDec = true;
          _context.next = 31;
          return {
            type: "NumericLiteral",
            value: match[0]
          };
        case 31:
          return _context.abrupt("continue", 2);
        case 32:
          Template.lastIndex = lastIndex;
          if (!(match = Template.exec(input))) {
            _context.next = 36;
            break;
          }
          lastIndex = Template.lastIndex;
          lastSignificantToken = match[0];
          if (!(match[1] === "${")) {
            _context.next = 34;
            break;
          }
          lastSignificantToken = "?InterpolationInTemplate";
          stack.push({
            tag: "InterpolationInTemplate",
            nesting: braces.length
          });
          postfixIncDec = false;
          _context.next = 33;
          return {
            type: "TemplateHead",
            value: match[0]
          };
        case 33:
          _context.next = 35;
          break;
        case 34:
          postfixIncDec = true;
          _context.next = 35;
          return {
            type: "NoSubstitutionTemplate",
            value: match[0],
            closed: match[1] === "`"
          };
        case 35:
          return _context.abrupt("continue", 2);
        case 36:
          return _context.abrupt("continue", 56);
        case 37:
          JSXPunctuator.lastIndex = lastIndex;
          if (!(match = JSXPunctuator.exec(input))) {
            _context.next = 44;
            break;
          }
          lastIndex = JSXPunctuator.lastIndex;
          nextLastSignificantToken = match[0];
          _t4 = match[0];
          _context.next = _t4 === "<" ? 38 : _t4 === ">" ? 39 : _t4 === "{" ? 40 : _t4 === "/" ? 41 : 42;
          break;
        case 38:
          stack.push({
            tag: "JSXTag"
          });
          return _context.abrupt("continue", 42);
        case 39:
          stack.pop();
          if (lastSignificantToken === "/" || mode.tag === "JSXTagEnd") {
            nextLastSignificantToken = "?JSX";
            postfixIncDec = true;
          } else {
            stack.push({
              tag: "JSXChildren"
            });
          }
          return _context.abrupt("continue", 42);
        case 40:
          stack.push({
            tag: "InterpolationInJSX",
            nesting: braces.length
          });
          nextLastSignificantToken = "?InterpolationInJSX";
          postfixIncDec = false;
          return _context.abrupt("continue", 42);
        case 41:
          if (lastSignificantToken === "<") {
            stack.pop();
            if (stack[stack.length - 1].tag === "JSXChildren") {
              stack.pop();
            }
            stack.push({
              tag: "JSXTagEnd"
            });
          }
        case 42:
          lastSignificantToken = nextLastSignificantToken;
          _context.next = 43;
          return {
            type: "JSXPunctuator",
            value: match[0]
          };
        case 43:
          return _context.abrupt("continue", 2);
        case 44:
          JSXIdentifier.lastIndex = lastIndex;
          if (!(match = JSXIdentifier.exec(input))) {
            _context.next = 46;
            break;
          }
          lastIndex = JSXIdentifier.lastIndex;
          lastSignificantToken = match[0];
          _context.next = 45;
          return {
            type: "JSXIdentifier",
            value: match[0]
          };
        case 45:
          return _context.abrupt("continue", 2);
        case 46:
          JSXString.lastIndex = lastIndex;
          if (!(match = JSXString.exec(input))) {
            _context.next = 48;
            break;
          }
          lastIndex = JSXString.lastIndex;
          lastSignificantToken = match[0];
          _context.next = 47;
          return {
            type: "JSXString",
            value: match[0],
            closed: match[2] !== void 0
          };
        case 47:
          return _context.abrupt("continue", 2);
        case 48:
          return _context.abrupt("continue", 56);
        case 49:
          JSXText.lastIndex = lastIndex;
          if (!(match = JSXText.exec(input))) {
            _context.next = 51;
            break;
          }
          lastIndex = JSXText.lastIndex;
          lastSignificantToken = match[0];
          _context.next = 50;
          return {
            type: "JSXText",
            value: match[0]
          };
        case 50:
          return _context.abrupt("continue", 2);
        case 51:
          _t5 = input[lastIndex];
          _context.next = _t5 === "<" ? 52 : _t5 === "{" ? 54 : 56;
          break;
        case 52:
          stack.push({
            tag: "JSXTag"
          });
          lastIndex++;
          lastSignificantToken = "<";
          _context.next = 53;
          return {
            type: "JSXPunctuator",
            value: "<"
          };
        case 53:
          return _context.abrupt("continue", 2);
        case 54:
          stack.push({
            tag: "InterpolationInJSX",
            nesting: braces.length
          });
          lastIndex++;
          lastSignificantToken = "?InterpolationInJSX";
          postfixIncDec = false;
          _context.next = 55;
          return {
            type: "JSXPunctuator",
            value: "{"
          };
        case 55:
          return _context.abrupt("continue", 2);
        case 56:
          WhiteSpace.lastIndex = lastIndex;
          if (!(match = WhiteSpace.exec(input))) {
            _context.next = 58;
            break;
          }
          lastIndex = WhiteSpace.lastIndex;
          _context.next = 57;
          return {
            type: "WhiteSpace",
            value: match[0]
          };
        case 57:
          return _context.abrupt("continue", 2);
        case 58:
          LineTerminatorSequence.lastIndex = lastIndex;
          if (!(match = LineTerminatorSequence.exec(input))) {
            _context.next = 60;
            break;
          }
          lastIndex = LineTerminatorSequence.lastIndex;
          postfixIncDec = false;
          if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {
            lastSignificantToken = "?NoLineTerminatorHere";
          }
          _context.next = 59;
          return {
            type: "LineTerminatorSequence",
            value: match[0]
          };
        case 59:
          return _context.abrupt("continue", 2);
        case 60:
          MultiLineComment.lastIndex = lastIndex;
          if (!(match = MultiLineComment.exec(input))) {
            _context.next = 62;
            break;
          }
          lastIndex = MultiLineComment.lastIndex;
          if (Newline.test(match[0])) {
            postfixIncDec = false;
            if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {
              lastSignificantToken = "?NoLineTerminatorHere";
            }
          }
          _context.next = 61;
          return {
            type: "MultiLineComment",
            value: match[0],
            closed: match[1] !== void 0
          };
        case 61:
          return _context.abrupt("continue", 2);
        case 62:
          SingleLineComment.lastIndex = lastIndex;
          if (!(match = SingleLineComment.exec(input))) {
            _context.next = 64;
            break;
          }
          lastIndex = SingleLineComment.lastIndex;
          postfixIncDec = false;
          _context.next = 63;
          return {
            type: "SingleLineComment",
            value: match[0]
          };
        case 63:
          return _context.abrupt("continue", 2);
        case 64:
          firstCodePoint = String.fromCodePoint(input.codePointAt(lastIndex));
          lastIndex += firstCodePoint.length;
          lastSignificantToken = firstCodePoint;
          postfixIncDec = false;
          _context.next = 65;
          return {
            type: mode.tag.startsWith("JSX") ? "JSXInvalid" : "Invalid",
            value: firstCodePoint
          };
        case 65:
          _context.next = 2;
          break;
        case 66:
          return _context.abrupt("return", void 0);
        case 67:
        case "end":
          return _context.stop();
      }
    }, _callee);
  })();
};

function _createForOfIteratorHelper$4(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$4(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray$4(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray$4(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$4(r, a) : void 0; } }
function _arrayLikeToArray$4(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var FILL_COMMENT = " ";
function stripLiteralFromToken(token, fillChar, filter) {
  if (token.type === "SingleLineComment") {
    return FILL_COMMENT.repeat(token.value.length);
  }
  if (token.type === "MultiLineComment") {
    return token.value.replace(/[^\n]/g, FILL_COMMENT);
  }
  if (token.type === "StringLiteral") {
    if (!token.closed) {
      return token.value;
    }
    var body = token.value.slice(1, -1);
    if (filter(body)) {
      return token.value[0] + fillChar.repeat(body.length) + token.value[token.value.length - 1];
    }
  }
  if (token.type === "NoSubstitutionTemplate") {
    var _body = token.value.slice(1, -1);
    if (filter(_body)) {
      return "`".concat(_body.replace(/[^\n]/g, fillChar), "`");
    }
  }
  if (token.type === "RegularExpressionLiteral") {
    var _body2 = token.value;
    if (filter(_body2)) {
      return _body2.replace(/\/(.*)\/(\w?)$/g, function (_, $1, $2) {
        return "/".concat(fillChar.repeat($1.length), "/").concat($2);
      });
    }
  }
  if (token.type === "TemplateHead") {
    var _body3 = token.value.slice(1, -2);
    if (filter(_body3)) {
      return "`".concat(_body3.replace(/[^\n]/g, fillChar), "${");
    }
  }
  if (token.type === "TemplateTail") {
    var _body4 = token.value.slice(0, -2);
    if (filter(_body4)) {
      return "}".concat(_body4.replace(/[^\n]/g, fillChar), "`");
    }
  }
  if (token.type === "TemplateMiddle") {
    var _body5 = token.value.slice(1, -2);
    if (filter(_body5)) {
      return "}".concat(_body5.replace(/[^\n]/g, fillChar), "${");
    }
  }
  return token.value;
}
function optionsWithDefaults(options) {
  var _options$fillChar, _options$filter;
  return {
    fillChar: (_options$fillChar = options === null || options === void 0 ? void 0 : options.fillChar) !== null && _options$fillChar !== void 0 ? _options$fillChar : " ",
    filter: (_options$filter = options === null || options === void 0 ? void 0 : options.filter) !== null && _options$filter !== void 0 ? _options$filter : function () {
      return true;
    }
  };
}
function stripLiteral(code, options) {
  var result = "";
  var _options = optionsWithDefaults(options);
  var _iterator = _createForOfIteratorHelper$4(jsTokens_1$1(code, {
      jsx: false
    })),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var token = _step.value;
      result += stripLiteralFromToken(token, _options.fillChar, _options.filter);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return result;
}

var _DRIVE_LETTER_START_RE = /^[A-Za-z]:\//;
function normalizeWindowsPath() {
  var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
  if (!input) {
    return input;
  }
  return input.replace(/\\/g, "/").replace(_DRIVE_LETTER_START_RE, function (r) {
    return r.toUpperCase();
  });
}
var _IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
function cwd() {
  if (typeof process !== "undefined" && typeof process.cwd === "function") {
    return process.cwd().replace(/\\/g, "/");
  }
  return "/";
}
var resolve$2 = function resolve() {
  for (var _len2 = arguments.length, arguments_ = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    arguments_[_key2] = arguments[_key2];
  }
  arguments_ = arguments_.map(function (argument) {
    return normalizeWindowsPath(argument);
  });
  var resolvedPath = "";
  var resolvedAbsolute = false;
  for (var index = arguments_.length - 1; index >= -1 && !resolvedAbsolute; index--) {
    var path = index >= 0 ? arguments_[index] : cwd();
    if (!path || path.length === 0) {
      continue;
    }
    resolvedPath = "".concat(path, "/").concat(resolvedPath);
    resolvedAbsolute = isAbsolute(path);
  }
  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute);
  if (resolvedAbsolute && !isAbsolute(resolvedPath)) {
    return "/".concat(resolvedPath);
  }
  return resolvedPath.length > 0 ? resolvedPath : ".";
};
function normalizeString(path, allowAboveRoot) {
  var res = "";
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var char = null;
  for (var index = 0; index <= path.length; ++index) {
    if (index < path.length) {
      char = path[index];
    } else if (char === "/") {
      break;
    } else {
      char = "/";
    }
    if (char === "/") {
      if (lastSlash === index - 1 || dots === 1) ;else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== "." || res[res.length - 2] !== ".") {
          if (res.length > 2) {
            var lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
            }
            lastSlash = index;
            dots = 0;
            continue;
          } else if (res.length > 0) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = index;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += "/".concat(path.slice(lastSlash + 1, index));
        } else {
          res = path.slice(lastSlash + 1, index);
        }
        lastSegmentLength = index - lastSlash - 1;
      }
      lastSlash = index;
      dots = 0;
    } else if (char === "." && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
var isAbsolute = function isAbsolute(p) {
  return _IS_ABSOLUTE_RE.test(p);
};

function _createForOfIteratorHelper$3(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$3(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray$3(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray$3(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$3(r, a) : void 0; } }
function _arrayLikeToArray$3(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys$2(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$2(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$2(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _callSuper$3(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$3() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$3() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$3 = function _isNativeReflectConstruct() { return !!t; })(); }
var PendingError = /*#__PURE__*/function (_Error) {
  function PendingError(message, task, note) {
    var _this;
    _classCallCheck(this, PendingError);
    _this = _callSuper$3(this, PendingError, [message]);
    _defineProperty(_this, "code", "VITEST_PENDING");
    _defineProperty(_this, "taskId", void 0);
    _this.message = message;
    _this.note = note;
    _this.taskId = task.id;
    return _this;
  }
  _inherits(PendingError, _Error);
  return _createClass(PendingError);
}(/*#__PURE__*/_wrapNativeSuper(Error));
var fnMap = new WeakMap();
var testFixtureMap = new WeakMap();
var hooksMap = new WeakMap();
function setFn(key, fn) {
  fnMap.set(key, fn);
}
function setTestFixture(key, fixture) {
  testFixtureMap.set(key, fixture);
}
function getTestFixture(key) {
  return testFixtureMap.get(key);
}
function setHooks(key, hooks) {
  hooksMap.set(key, hooks);
}
function getHooks(key) {
  return hooksMap.get(key);
}
function mergeScopedFixtures(testFixtures, scopedFixtures) {
  var scopedFixturesMap = scopedFixtures.reduce(function (map, fixture) {
    map[fixture.prop] = fixture;
    return map;
  }, {});
  var newFixtures = {};
  testFixtures.forEach(function (fixture) {
    var useFixture = scopedFixturesMap[fixture.prop] || _objectSpread$2({}, fixture);
    newFixtures[useFixture.prop] = useFixture;
  });
  for (var fixtureKep in newFixtures) {
    var _fixture$deps;
    var fixture = newFixtures[fixtureKep];
    // if the fixture was define before the scope, then its dep
    // will reference the original fixture instead of the scope
    fixture.deps = (_fixture$deps = fixture.deps) === null || _fixture$deps === void 0 ? void 0 : _fixture$deps.map(function (dep) {
      return newFixtures[dep.prop];
    });
  }
  return Object.values(newFixtures);
}
function mergeContextFixtures(fixtures, context, runner) {
  var fixtureOptionKeys = ["auto", "injected", "scope"];
  var fixtureArray = Object.entries(fixtures).map(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
      prop = _ref2[0],
      value = _ref2[1];
    var fixtureItem = {
      value: value
    };
    if (Array.isArray(value) && value.length >= 2 && isObject$1(value[1]) && Object.keys(value[1]).some(function (key) {
      return fixtureOptionKeys.includes(key);
    })) {
      var _ref3;
      var _runner$injectValue;
      // fixture with options
      Object.assign(fixtureItem, value[1]);
      var userValue = value[0];
      fixtureItem.value = fixtureItem.injected ? (_ref3 = (_runner$injectValue = runner.injectValue) === null || _runner$injectValue === void 0 ? void 0 : _runner$injectValue.call(runner, prop)) !== null && _ref3 !== void 0 ? _ref3 : userValue : userValue;
    }
    fixtureItem.scope = fixtureItem.scope || "test";
    if (fixtureItem.scope === "worker" && !runner.getWorkerContext) {
      fixtureItem.scope = "file";
    }
    fixtureItem.prop = prop;
    fixtureItem.isFn = typeof fixtureItem.value === "function";
    return fixtureItem;
  });
  if (Array.isArray(context.fixtures)) {
    context.fixtures = context.fixtures.concat(fixtureArray);
  } else {
    context.fixtures = fixtureArray;
  }
  // Update dependencies of fixture functions
  fixtureArray.forEach(function (fixture) {
    if (fixture.isFn) {
      var usedProps = getUsedProps(fixture.value);
      if (usedProps.length) {
        fixture.deps = context.fixtures.filter(function (_ref4) {
          var prop = _ref4.prop;
          return prop !== fixture.prop && usedProps.includes(prop);
        });
      }
      // test can access anything, so we ignore it
      if (fixture.scope !== "test") {
        var _fixture$deps2;
        (_fixture$deps2 = fixture.deps) === null || _fixture$deps2 === void 0 ? void 0 : _fixture$deps2.forEach(function (dep) {
          if (!dep.isFn) {
            // non fn fixtures are always resolved and available to anyone
            return;
          }
          // worker scope can only import from worker scope
          if (fixture.scope === "worker" && dep.scope === "worker") {
            return;
          }
          // file scope an import from file and worker scopes
          if (fixture.scope === "file" && dep.scope !== "test") {
            return;
          }
          throw new SyntaxError("cannot use the ".concat(dep.scope, " fixture \"").concat(dep.prop, "\" inside the ").concat(fixture.scope, " fixture \"").concat(fixture.prop, "\""));
        });
      }
    }
  });
  return context;
}
var fixtureValueMaps = new Map();
var cleanupFnArrayMap = new Map();
function withFixtures(runner, fn, testContext) {
  return function (hookContext) {
    var context = hookContext || testContext;
    if (!context) {
      return fn({});
    }
    var fixtures = getTestFixture(context);
    if (!(fixtures === null || fixtures === void 0 ? void 0 : fixtures.length)) {
      return fn(context);
    }
    var usedProps = getUsedProps(fn);
    var hasAutoFixture = fixtures.some(function (_ref5) {
      var auto = _ref5.auto;
      return auto;
    });
    if (!usedProps.length && !hasAutoFixture) {
      return fn(context);
    }
    if (!fixtureValueMaps.get(context)) {
      fixtureValueMaps.set(context, new Map());
    }
    var fixtureValueMap = fixtureValueMaps.get(context);
    if (!cleanupFnArrayMap.has(context)) {
      cleanupFnArrayMap.set(context, []);
    }
    var cleanupFnArray = cleanupFnArrayMap.get(context);
    var usedFixtures = fixtures.filter(function (_ref6) {
      var prop = _ref6.prop,
        auto = _ref6.auto;
      return auto || usedProps.includes(prop);
    });
    var pendingFixtures = resolveDeps(usedFixtures);
    if (!pendingFixtures.length) {
      return fn(context);
    }
    function resolveFixtures() {
      return _resolveFixtures.apply(this, arguments);
    }
    function _resolveFixtures() {
      _resolveFixtures = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var _iterator, _step, _loop, _t;
        return _regeneratorRuntime.wrap(function (_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _iterator = _createForOfIteratorHelper$3(pendingFixtures);
              _context3.prev = 1;
              _loop = /*#__PURE__*/_regeneratorRuntime.mark(function _loop() {
                var fixture, resolvedValue;
                return _regeneratorRuntime.wrap(function (_context2) {
                  while (1) switch (_context2.prev = _context2.next) {
                    case 0:
                      fixture = _step.value;
                      if (!fixtureValueMap.has(fixture)) {
                        _context2.next = 1;
                        break;
                      }
                      return _context2.abrupt("return", 1);
                    case 1:
                      _context2.next = 2;
                      return resolveFixtureValue(runner, fixture, context, cleanupFnArray);
                    case 2:
                      resolvedValue = _context2.sent;
                      context[fixture.prop] = resolvedValue;
                      fixtureValueMap.set(fixture, resolvedValue);
                      if (fixture.scope === "test") {
                        cleanupFnArray.unshift(function () {
                          fixtureValueMap.delete(fixture);
                        });
                      }
                    case 3:
                    case "end":
                      return _context2.stop();
                  }
                }, _loop);
              });
              _iterator.s();
            case 2:
              if ((_step = _iterator.n()).done) {
                _context3.next = 5;
                break;
              }
              return _context3.delegateYield(_loop(), "t0", 3);
            case 3:
              if (!_context3.t0) {
                _context3.next = 4;
                break;
              }
              return _context3.abrupt("continue", 4);
            case 4:
              _context3.next = 2;
              break;
            case 5:
              _context3.next = 7;
              break;
            case 6:
              _context3.prev = 6;
              _t = _context3["catch"](1);
              _iterator.e(_t);
            case 7:
              _context3.prev = 7;
              _iterator.f();
              return _context3.finish(7);
            case 8:
            case "end":
              return _context3.stop();
          }
        }, _callee, null, [[1, 6, 7, 8]]);
      }));
      return _resolveFixtures.apply(this, arguments);
    }
    return resolveFixtures().then(function () {
      return fn(context);
    });
  };
}
var globalFixturePromise = new WeakMap();
function resolveFixtureValue(runner, fixture, context, cleanupFnArray) {
  var _runner$getWorkerCont;
  var fileContext = getFileContext(context.task.file);
  var workerContext = (_runner$getWorkerCont = runner.getWorkerContext) === null || _runner$getWorkerCont === void 0 ? void 0 : _runner$getWorkerCont.call(runner);
  if (!fixture.isFn) {
    var _fileContext$_fixture;
    var _fixture$prop;
    (_fileContext$_fixture = fileContext[_fixture$prop = fixture.prop]) !== null && _fileContext$_fixture !== void 0 ? _fileContext$_fixture : fileContext[_fixture$prop] = fixture.value;
    if (workerContext) {
      var _workerContext$_fixtu;
      var _fixture$prop2;
      (_workerContext$_fixtu = workerContext[_fixture$prop2 = fixture.prop]) !== null && _workerContext$_fixtu !== void 0 ? _workerContext$_fixtu : workerContext[_fixture$prop2] = fixture.value;
    }
    return fixture.value;
  }
  if (fixture.scope === "test") {
    return resolveFixtureFunction(fixture.value, context, cleanupFnArray);
  }
  // in case the test runs in parallel
  if (globalFixturePromise.has(fixture)) {
    return globalFixturePromise.get(fixture);
  }
  var fixtureContext;
  if (fixture.scope === "worker") {
    if (!workerContext) {
      throw new TypeError("[@vitest/runner] The worker context is not available in the current test runner. Please, provide the `getWorkerContext` method when initiating the runner.");
    }
    fixtureContext = workerContext;
  } else {
    fixtureContext = fileContext;
  }
  if (fixture.prop in fixtureContext) {
    return fixtureContext[fixture.prop];
  }
  if (!cleanupFnArrayMap.has(fixtureContext)) {
    cleanupFnArrayMap.set(fixtureContext, []);
  }
  var cleanupFnFileArray = cleanupFnArrayMap.get(fixtureContext);
  var promise = resolveFixtureFunction(fixture.value, fixtureContext, cleanupFnFileArray).then(function (value) {
    fixtureContext[fixture.prop] = value;
    globalFixturePromise.delete(fixture);
    return value;
  });
  globalFixturePromise.set(fixture, promise);
  return promise;
}
function resolveFixtureFunction(_x5, _x6, _x7) {
  return _resolveFixtureFunction.apply(this, arguments);
}
function _resolveFixtureFunction() {
  _resolveFixtureFunction = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee0(fixtureFn, context, cleanupFnArray) {
    var useFnArgPromise, isUseFnArgResolved, fixtureReturn;
    return _regeneratorRuntime.wrap(function (_context10) {
      while (1) switch (_context10.prev = _context10.next) {
        case 0:
          // wait for `use` call to extract fixture value
          useFnArgPromise = createDefer();
          isUseFnArgResolved = false;
          fixtureReturn = fixtureFn(context, /*#__PURE__*/function () {
            var _ref13 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee9(useFnArg) {
              var useReturnPromise;
              return _regeneratorRuntime.wrap(function (_context1) {
                while (1) switch (_context1.prev = _context1.next) {
                  case 0:
                    // extract `use` argument
                    isUseFnArgResolved = true;
                    useFnArgPromise.resolve(useFnArg);
                    // suspend fixture teardown by holding off `useReturnPromise` resolution until cleanup
                    useReturnPromise = createDefer();
                    cleanupFnArray.push(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {
                      return _regeneratorRuntime.wrap(function (_context0) {
                        while (1) switch (_context0.prev = _context0.next) {
                          case 0:
                            // start teardown by resolving `use` Promise
                            useReturnPromise.resolve();
                            // wait for finishing teardown
                            _context0.next = 1;
                            return fixtureReturn;
                          case 1:
                          case "end":
                            return _context0.stop();
                        }
                      }, _callee8);
                    })));
                    _context1.next = 1;
                    return useReturnPromise;
                  case 1:
                  case "end":
                    return _context1.stop();
                }
              }, _callee9);
            }));
            return function (_x40) {
              return _ref13.apply(this, arguments);
            };
          }()).catch(function (e) {
            // treat fixture setup error as test failure
            if (!isUseFnArgResolved) {
              useFnArgPromise.reject(e);
              return;
            }
            // otherwise re-throw to avoid silencing error during cleanup
            throw e;
          });
          return _context10.abrupt("return", useFnArgPromise);
        case 1:
        case "end":
          return _context10.stop();
      }
    }, _callee0);
  }));
  return _resolveFixtureFunction.apply(this, arguments);
}
function resolveDeps(fixtures) {
  var depSet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();
  var pendingFixtures = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  fixtures.forEach(function (fixture) {
    if (pendingFixtures.includes(fixture)) {
      return;
    }
    if (!fixture.isFn || !fixture.deps) {
      pendingFixtures.push(fixture);
      return;
    }
    if (depSet.has(fixture)) {
      throw new Error("Circular fixture dependency detected: ".concat(fixture.prop, " <- ").concat(_toConsumableArray(depSet).reverse().map(function (d) {
        return d.prop;
      }).join(" <- ")));
    }
    depSet.add(fixture);
    resolveDeps(fixture.deps, depSet, pendingFixtures);
    pendingFixtures.push(fixture);
    depSet.clear();
  });
  return pendingFixtures;
}
function getUsedProps(fn) {
  var fnString = stripLiteral(fn.toString());
  // match lowered async function and strip it off
  // example code on esbuild-try https://esbuild.github.io/try/#YgAwLjI0LjAALS1zdXBwb3J0ZWQ6YXN5bmMtYXdhaXQ9ZmFsc2UAZQBlbnRyeS50cwBjb25zdCBvID0gewogIGYxOiBhc3luYyAoKSA9PiB7fSwKICBmMjogYXN5bmMgKGEpID0+IHt9LAogIGYzOiBhc3luYyAoYSwgYikgPT4ge30sCiAgZjQ6IGFzeW5jIGZ1bmN0aW9uKGEpIHt9LAogIGY1OiBhc3luYyBmdW5jdGlvbiBmZihhKSB7fSwKICBhc3luYyBmNihhKSB7fSwKCiAgZzE6IGFzeW5jICgpID0+IHt9LAogIGcyOiBhc3luYyAoeyBhIH0pID0+IHt9LAogIGczOiBhc3luYyAoeyBhIH0sIGIpID0+IHt9LAogIGc0OiBhc3luYyBmdW5jdGlvbiAoeyBhIH0pIHt9LAogIGc1OiBhc3luYyBmdW5jdGlvbiBnZyh7IGEgfSkge30sCiAgYXN5bmMgZzYoeyBhIH0pIHt9LAoKICBoMTogYXN5bmMgKCkgPT4ge30sCiAgLy8gY29tbWVudCBiZXR3ZWVuCiAgaDI6IGFzeW5jIChhKSA9PiB7fSwKfQ
  //   __async(this, null, function*
  //   __async(this, arguments, function*
  //   __async(this, [_0, _1], function*
  if (/__async\((?:this|null), (?:null|arguments|\[[_0-9, ]*\]), function\*/.test(fnString)) {
    fnString = fnString.split(/__async\((?:this|null),/)[1];
  }
  var match = fnString.match(/[^(]*\(([^)]*)/);
  if (!match) {
    return [];
  }
  var args = splitByComma(match[1]);
  if (!args.length) {
    return [];
  }
  var first = args[0];
  if ("__VITEST_FIXTURE_INDEX__" in fn) {
    first = args[fn.__VITEST_FIXTURE_INDEX__];
    if (!first) {
      return [];
    }
  }
  if (!(first.startsWith("{") && first.endsWith("}"))) {
    throw new Error("The first argument inside a fixture must use object destructuring pattern, e.g. ({ test } => {}). Instead, received \"".concat(first, "\"."));
  }
  var _first = first.slice(1, -1).replace(/\s/g, "");
  var props = splitByComma(_first).map(function (prop) {
    return prop.replace(/:.*|=.*/g, "");
  });
  var last = props.at(-1);
  if (last && last.startsWith("...")) {
    throw new Error("Rest parameters are not supported in fixtures, received \"".concat(last, "\"."));
  }
  return props;
}
function splitByComma(s) {
  var result = [];
  var stack = [];
  var start = 0;
  for (var i = 0; i < s.length; i++) {
    if (s[i] === "{" || s[i] === "[") {
      stack.push(s[i] === "{" ? "}" : "]");
    } else if (s[i] === stack[stack.length - 1]) {
      stack.pop();
    } else if (!stack.length && s[i] === ",") {
      var token = s.substring(start, i).trim();
      if (token) {
        result.push(token);
      }
      start = i + 1;
    }
  }
  var lastToken = s.substring(start).trim();
  if (lastToken) {
    result.push(lastToken);
  }
  return result;
}
var _test;
function getCurrentTest() {
  return _test;
}
function createChainable(keys, fn) {
  function create(context) {
    var chain = function chain() {
      for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return fn.apply(context, args);
    };
    Object.assign(chain, fn);
    chain.withContext = function () {
      return chain.bind(context);
    };
    chain.setContext = function (key, value) {
      context[key] = value;
    };
    chain.mergeContext = function (ctx) {
      Object.assign(context, ctx);
    };
    var _iterator2 = _createForOfIteratorHelper$3(keys),
      _step2;
    try {
      var _loop2 = function _loop2() {
        var key = _step2.value;
        Object.defineProperty(chain, key, {
          get: function get() {
            return create(_objectSpread$2(_objectSpread$2({}, context), {}, _defineProperty({}, key, true)));
          }
        });
      };
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        _loop2();
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    return chain;
  }
  var chain = create({});
  chain.fn = fn;
  return chain;
}

/**
* Creates a suite of tests, allowing for grouping and hierarchical organization of tests.
* Suites can contain both tests and other suites, enabling complex test structures.
*
* @param {string} name - The name of the suite, used for identification and reporting.
* @param {Function} fn - A function that defines the tests and suites within this suite.
* @example
* ```ts
* // Define a suite with two tests
* suite('Math operations', () => {
*   test('should add two numbers', () => {
*     expect(add(1, 2)).toBe(3);
*   });
*
*   test('should subtract two numbers', () => {
*     expect(subtract(5, 2)).toBe(3);
*   });
* });
* ```
* @example
* ```ts
* // Define nested suites
* suite('String operations', () => {
*   suite('Trimming', () => {
*     test('should trim whitespace from start and end', () => {
*       expect('  hello  '.trim()).toBe('hello');
*     });
*   });
*
*   suite('Concatenation', () => {
*     test('should concatenate two strings', () => {
*       expect('hello' + ' ' + 'world').toBe('hello world');
*     });
*   });
* });
* ```
*/
var suite = createSuite();
/**
* Defines a test case with a given name and test function. The test function can optionally be configured with test options.
*
* @param {string | Function} name - The name of the test or a function that will be used as a test name.
* @param {TestOptions | TestFunction} [optionsOrFn] - Optional. The test options or the test function if no explicit name is provided.
* @param {number | TestOptions | TestFunction} [optionsOrTest] - Optional. The test function or options, depending on the previous parameters.
* @throws {Error} If called inside another test function.
* @example
* ```ts
* // Define a simple test
* test('should add two numbers', () => {
*   expect(add(1, 2)).toBe(3);
* });
* ```
* @example
* ```ts
* // Define a test with options
* test('should subtract two numbers', { retry: 3 }, () => {
*   expect(subtract(5, 2)).toBe(3);
* });
* ```
*/
var test$1 = createTest(function (name, optionsOrFn, optionsOrTest) {
  getCurrentSuite().test.fn.call(this, formatName(name), optionsOrFn, optionsOrTest);
});
/**
* Creates a suite of tests, allowing for grouping and hierarchical organization of tests.
* Suites can contain both tests and other suites, enabling complex test structures.
*
* @param {string} name - The name of the suite, used for identification and reporting.
* @param {Function} fn - A function that defines the tests and suites within this suite.
* @example
* ```ts
* // Define a suite with two tests
* describe('Math operations', () => {
*   test('should add two numbers', () => {
*     expect(add(1, 2)).toBe(3);
*   });
*
*   test('should subtract two numbers', () => {
*     expect(subtract(5, 2)).toBe(3);
*   });
* });
* ```
* @example
* ```ts
* // Define nested suites
* describe('String operations', () => {
*   describe('Trimming', () => {
*     test('should trim whitespace from start and end', () => {
*       expect('  hello  '.trim()).toBe('hello');
*     });
*   });
*
*   describe('Concatenation', () => {
*     test('should concatenate two strings', () => {
*       expect('hello' + ' ' + 'world').toBe('hello world');
*     });
*   });
* });
* ```
*/
var describe = suite;
/**
* Defines a test case with a given name and test function. The test function can optionally be configured with test options.
*
* @param {string | Function} name - The name of the test or a function that will be used as a test name.
* @param {TestOptions | TestFunction} [optionsOrFn] - Optional. The test options or the test function if no explicit name is provided.
* @param {number | TestOptions | TestFunction} [optionsOrTest] - Optional. The test function or options, depending on the previous parameters.
* @throws {Error} If called inside another test function.
* @example
* ```ts
* // Define a simple test
* it('adds two numbers', () => {
*   expect(add(1, 2)).toBe(3);
* });
* ```
* @example
* ```ts
* // Define a test with options
* it('subtracts two numbers', { retry: 3 }, () => {
*   expect(subtract(5, 2)).toBe(3);
* });
* ```
*/
var it = test$1;
var runner;
var defaultSuite;
function assert(condition, message) {
  if (!condition) {
    throw new Error("Vitest failed to find ".concat(message, ". This is a bug in Vitest. Please, open an issue with reproduction."));
  }
}
function getRunner() {
  assert(runner, "the runner");
  return runner;
}
function getCurrentSuite() {
  var currentSuite = collectorContext.currentSuite || defaultSuite;
  assert(currentSuite, "the current suite");
  return currentSuite;
}
function createSuiteHooks() {
  return {
    beforeAll: [],
    afterAll: [],
    beforeEach: [],
    afterEach: []
  };
}
function parseArguments(optionsOrFn, optionsOrTest) {
  var options = {};
  var fn = function fn() {};
  // it('', () => {}, { retry: 2 })
  if (_typeof(optionsOrTest) === "object") {
    // it('', { retry: 2 }, { retry: 3 })
    if (_typeof(optionsOrFn) === "object") {
      throw new TypeError("Cannot use two objects as arguments. Please provide options and a function callback in that order.");
    }
    console.warn("Using an object as a third argument is deprecated. Vitest 4 will throw an error if the third argument is not a timeout number. Please use the second argument for options. See more at https://vitest.dev/guide/migration");
    options = optionsOrTest;
  } else if (typeof optionsOrTest === "number") {
    options = {
      timeout: optionsOrTest
    };
  } else if (_typeof(optionsOrFn) === "object") {
    options = optionsOrFn;
  }
  if (typeof optionsOrFn === "function") {
    if (typeof optionsOrTest === "function") {
      throw new TypeError("Cannot use two functions as arguments. Please use the second argument for options.");
    }
    fn = optionsOrFn;
  } else if (typeof optionsOrTest === "function") {
    fn = optionsOrTest;
  }
  return {
    options: options,
    handler: fn
  };
}
// implementations
function createSuiteCollector(name) {
  var factory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
  var mode = arguments.length > 2 ? arguments[2] : undefined;
  var each = arguments.length > 3 ? arguments[3] : undefined;
  var suiteOptions = arguments.length > 4 ? arguments[4] : undefined;
  var parentCollectorFixtures = arguments.length > 5 ? arguments[5] : undefined;
  var tasks = [];
  var suite;
  initSuite();
  var task = function task() {
    var _ref7, _options$retry, _options$meta;
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var _collectorContext$cur;
    var timeout = (_ref7 = options === null || options === void 0 ? void 0 : options.timeout) !== null && _ref7 !== void 0 ? _ref7 : runner.config.testTimeout;
    var task = {
      id: "",
      name: name,
      suite: (_collectorContext$cur = collectorContext.currentSuite) === null || _collectorContext$cur === void 0 ? void 0 : _collectorContext$cur.suite,
      each: options.each,
      fails: options.fails,
      context: undefined,
      type: "test",
      file: undefined,
      timeout: timeout,
      retry: (_options$retry = options.retry) !== null && _options$retry !== void 0 ? _options$retry : runner.config.retry,
      repeats: options.repeats,
      mode: options.only ? "only" : options.skip ? "skip" : options.todo ? "todo" : "run",
      meta: (_options$meta = options.meta) !== null && _options$meta !== void 0 ? _options$meta : Object.create(null),
      annotations: []
    };
    var handler = options.handler;
    if (options.concurrent || !options.sequential && runner.config.sequence.concurrent) {
      task.concurrent = true;
    }
    task.shuffle = suiteOptions === null || suiteOptions === void 0 ? void 0 : suiteOptions.shuffle;
    var context = createTestContext(task, runner);
    // create test context
    Object.defineProperty(task, "context", {
      value: context,
      enumerable: false
    });
    setTestFixture(context, options.fixtures);
    // custom can be called from any place, let's assume the limit is 15 stacks
    var limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 15;
    var stackTraceError = new Error("STACK_TRACE_ERROR");
    Error.stackTraceLimit = limit;
    if (handler) {
      setFn(task, withTimeout(withAwaitAsyncAssertions(withFixtures(runner, handler, context), task), timeout, false, stackTraceError, function (_, error) {
        return abortIfTimeout([context], error);
      }));
    }
    if (runner.config.includeTaskLocation) ;
    tasks.push(task);
    return task;
  };
  var test = createTest(function (name, optionsOrFn, optionsOrTest) {
    var _parseArguments = parseArguments(optionsOrFn, optionsOrTest),
      options = _parseArguments.options,
      handler = _parseArguments.handler;
    // inherit repeats, retry, timeout from suite
    if (_typeof(suiteOptions) === "object") {
      options = Object.assign({}, suiteOptions, options);
    }
    // inherit concurrent / sequential from suite
    options.concurrent = this.concurrent || !this.sequential && (options === null || options === void 0 ? void 0 : options.concurrent);
    options.sequential = this.sequential || !this.concurrent && (options === null || options === void 0 ? void 0 : options.sequential);
    var test = task(formatName(name), _objectSpread$2(_objectSpread$2(_objectSpread$2({}, this), options), {}, {
      handler: handler
    }));
    test.type = "test";
  });
  var collectorFixtures = parentCollectorFixtures;
  var collector = {
    type: "collector",
    name: name,
    mode: mode,
    suite: suite,
    options: suiteOptions,
    test: test,
    tasks: tasks,
    collect: collect,
    task: task,
    clear: clear,
    on: addHook,
    fixtures: function fixtures() {
      return collectorFixtures;
    },
    scoped: function scoped(fixtures) {
      var parsed = mergeContextFixtures(fixtures, {
        fixtures: collectorFixtures
      }, runner);
      if (parsed.fixtures) {
        collectorFixtures = parsed.fixtures;
      }
    }
  };
  function addHook(name) {
    var _getHooks$name;
    for (var _len2 = arguments.length, fn = new Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {
      fn[_key3 - 1] = arguments[_key3];
    }
    (_getHooks$name = getHooks(suite)[name]).push.apply(_getHooks$name, fn);
  }
  function initSuite(includeLocation) {
    var _collectorContext$cur2;
    if (typeof suiteOptions === "number") {
      suiteOptions = {
        timeout: suiteOptions
      };
    }
    suite = {
      id: "",
      type: "suite",
      name: name,
      suite: (_collectorContext$cur2 = collectorContext.currentSuite) === null || _collectorContext$cur2 === void 0 ? void 0 : _collectorContext$cur2.suite,
      mode: mode,
      each: each,
      file: undefined,
      shuffle: suiteOptions === null || suiteOptions === void 0 ? void 0 : suiteOptions.shuffle,
      tasks: [],
      meta: Object.create(null),
      concurrent: suiteOptions === null || suiteOptions === void 0 ? void 0 : suiteOptions.concurrent
    };
    setHooks(suite, createSuiteHooks());
  }
  function clear() {
    tasks.length = 0;
    initSuite();
  }
  function collect(_x8) {
    return _collect.apply(this, arguments);
  }
  function _collect() {
    _collect = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(file) {
      var allChildren, _iterator3, _step3, i, _t2, _t3, _t4;
      return _regeneratorRuntime.wrap(function (_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            if (file) {
              _context4.next = 1;
              break;
            }
            throw new TypeError("File is required to collect tasks.");
          case 1:
            if (!factory) {
              _context4.next = 2;
              break;
            }
            _context4.next = 2;
            return runWithSuite(collector, function () {
              return factory(test);
            });
          case 2:
            allChildren = [];
            _iterator3 = _createForOfIteratorHelper$3(tasks);
            _context4.prev = 3;
            _iterator3.s();
          case 4:
            if ((_step3 = _iterator3.n()).done) {
              _context4.next = 9;
              break;
            }
            i = _step3.value;
            _t2 = allChildren;
            if (!(i.type === "collector")) {
              _context4.next = 6;
              break;
            }
            _context4.next = 5;
            return i.collect(file);
          case 5:
            _t3 = _context4.sent;
            _context4.next = 7;
            break;
          case 6:
            _t3 = i;
          case 7:
            _t2.push.call(_t2, _t3);
          case 8:
            _context4.next = 4;
            break;
          case 9:
            _context4.next = 11;
            break;
          case 10:
            _context4.prev = 10;
            _t4 = _context4["catch"](3);
            _iterator3.e(_t4);
          case 11:
            _context4.prev = 11;
            _iterator3.f();
            return _context4.finish(11);
          case 12:
            suite.file = file;
            suite.tasks = allChildren;
            allChildren.forEach(function (task) {
              task.file = file;
            });
            return _context4.abrupt("return", suite);
          case 13:
          case "end":
            return _context4.stop();
        }
      }, _callee2, null, [[3, 10, 11, 12]]);
    }));
    return _collect.apply(this, arguments);
  }
  collectTask(collector);
  return collector;
}
function withAwaitAsyncAssertions(fn, task) {
  return /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
    var fnResult,
      result,
      errors,
      _args4 = arguments;
    return _regeneratorRuntime.wrap(function (_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          _context5.next = 1;
          return fn.apply(void 0, _args4);
        case 1:
          fnResult = _context5.sent;
          if (!task.promises) {
            _context5.next = 3;
            break;
          }
          _context5.next = 2;
          return Promise.allSettled(task.promises);
        case 2:
          result = _context5.sent;
          errors = result.map(function (r) {
            return r.status === "rejected" ? r.reason : undefined;
          }).filter(Boolean);
          if (!errors.length) {
            _context5.next = 3;
            break;
          }
          throw errors;
        case 3:
          return _context5.abrupt("return", fnResult);
        case 4:
        case "end":
          return _context5.stop();
      }
    }, _callee3);
  }));
}
function createSuite() {
  function suiteFn(name, factoryOrOptions, optionsOrFactory) {
    var _ref9, _ref0, _this$shuffle;
    var _currentSuite$options;
    var mode = this.only ? "only" : this.skip ? "skip" : this.todo ? "todo" : "run";
    var currentSuite = collectorContext.currentSuite || defaultSuite;
    var _parseArguments2 = parseArguments(factoryOrOptions, optionsOrFactory),
      options = _parseArguments2.options,
      factory = _parseArguments2.handler;
    var isConcurrentSpecified = options.concurrent || this.concurrent || options.sequential === false;
    var isSequentialSpecified = options.sequential || this.sequential || options.concurrent === false;
    // inherit options from current suite
    options = _objectSpread$2(_objectSpread$2(_objectSpread$2({}, currentSuite === null || currentSuite === void 0 ? void 0 : currentSuite.options), options), {}, {
      shuffle: (_ref9 = (_ref0 = (_this$shuffle = this.shuffle) !== null && _this$shuffle !== void 0 ? _this$shuffle : options.shuffle) !== null && _ref0 !== void 0 ? _ref0 : currentSuite === null || currentSuite === void 0 || (_currentSuite$options = currentSuite.options) === null || _currentSuite$options === void 0 ? void 0 : _currentSuite$options.shuffle) !== null && _ref9 !== void 0 ? _ref9 : void 0 
    });
    // inherit concurrent / sequential from suite
    var isConcurrent = isConcurrentSpecified || options.concurrent && !isSequentialSpecified;
    var isSequential = isSequentialSpecified || options.sequential && !isConcurrentSpecified;
    options.concurrent = isConcurrent && !isSequential;
    options.sequential = isSequential && !isConcurrent;
    return createSuiteCollector(formatName(name), factory, mode, this.each, options, currentSuite === null || currentSuite === void 0 ? void 0 : currentSuite.fixtures());
  }
  suiteFn.each = function (cases) {
    var _this3 = this;
    var suite = this.withContext();
    this.setContext("each", true);
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key4 = 1; _key4 < _len3; _key4++) {
      args[_key4 - 1] = arguments[_key4];
    }
    if (Array.isArray(cases) && args.length) {
      cases = formatTemplateString(cases, args);
    }
    return function (name, optionsOrFn, fnOrOptions) {
      var _name = formatName(name);
      var arrayOnlyCases = cases.every(Array.isArray);
      var _parseArguments3 = parseArguments(optionsOrFn, fnOrOptions),
        options = _parseArguments3.options,
        handler = _parseArguments3.handler;
      var fnFirst = typeof optionsOrFn === "function" && _typeof(fnOrOptions) === "object";
      cases.forEach(function (i, idx) {
        var items = Array.isArray(i) ? i : [i];
        if (fnFirst) {
          if (arrayOnlyCases) {
            suite(formatTitle(_name, items, idx), function () {
              return handler.apply(void 0, _toConsumableArray(items));
            }, options);
          } else {
            suite(formatTitle(_name, items, idx), function () {
              return handler(i);
            }, options);
          }
        } else {
          if (arrayOnlyCases) {
            suite(formatTitle(_name, items, idx), options, function () {
              return handler.apply(void 0, _toConsumableArray(items));
            });
          } else {
            suite(formatTitle(_name, items, idx), options, function () {
              return handler(i);
            });
          }
        }
      });
      _this3.setContext("each", undefined);
    };
  };
  suiteFn.for = function (cases) {
    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key5 = 1; _key5 < _len4; _key5++) {
      args[_key5 - 1] = arguments[_key5];
    }
    if (Array.isArray(cases) && args.length) {
      cases = formatTemplateString(cases, args);
    }
    return function (name, optionsOrFn, fnOrOptions) {
      var name_ = formatName(name);
      var _parseArguments4 = parseArguments(optionsOrFn, fnOrOptions),
        options = _parseArguments4.options,
        handler = _parseArguments4.handler;
      cases.forEach(function (item, idx) {
        suite(formatTitle(name_, toArray(item), idx), options, function () {
          return handler(item);
        });
      });
    };
  };
  suiteFn.skipIf = function (condition) {
    return condition ? suite.skip : suite;
  };
  suiteFn.runIf = function (condition) {
    return condition ? suite : suite.skip;
  };
  return createChainable(["concurrent", "sequential", "shuffle", "skip", "only", "todo"], suiteFn);
}
function createTaskCollector(fn, context) {
  var taskFn = fn;
  taskFn.each = function (cases) {
    var _this4 = this;
    var test = this.withContext();
    this.setContext("each", true);
    for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key6 = 1; _key6 < _len5; _key6++) {
      args[_key6 - 1] = arguments[_key6];
    }
    if (Array.isArray(cases) && args.length) {
      cases = formatTemplateString(cases, args);
    }
    return function (name, optionsOrFn, fnOrOptions) {
      var _name = formatName(name);
      var arrayOnlyCases = cases.every(Array.isArray);
      var _parseArguments5 = parseArguments(optionsOrFn, fnOrOptions),
        options = _parseArguments5.options,
        handler = _parseArguments5.handler;
      var fnFirst = typeof optionsOrFn === "function" && _typeof(fnOrOptions) === "object";
      cases.forEach(function (i, idx) {
        var items = Array.isArray(i) ? i : [i];
        if (fnFirst) {
          if (arrayOnlyCases) {
            test(formatTitle(_name, items, idx), function () {
              return handler.apply(void 0, _toConsumableArray(items));
            }, options);
          } else {
            test(formatTitle(_name, items, idx), function () {
              return handler(i);
            }, options);
          }
        } else {
          if (arrayOnlyCases) {
            test(formatTitle(_name, items, idx), options, function () {
              return handler.apply(void 0, _toConsumableArray(items));
            });
          } else {
            test(formatTitle(_name, items, idx), options, function () {
              return handler(i);
            });
          }
        }
      });
      _this4.setContext("each", undefined);
    };
  };
  taskFn.for = function (cases) {
    var test = this.withContext();
    for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key7 = 1; _key7 < _len6; _key7++) {
      args[_key7 - 1] = arguments[_key7];
    }
    if (Array.isArray(cases) && args.length) {
      cases = formatTemplateString(cases, args);
    }
    return function (name, optionsOrFn, fnOrOptions) {
      var _name = formatName(name);
      var _parseArguments6 = parseArguments(optionsOrFn, fnOrOptions),
        options = _parseArguments6.options,
        handler = _parseArguments6.handler;
      cases.forEach(function (item, idx) {
        // monkey-patch handler to allow parsing fixture
        var handlerWrapper = function handlerWrapper(ctx) {
          return handler(item, ctx);
        };
        handlerWrapper.__VITEST_FIXTURE_INDEX__ = 1;
        handlerWrapper.toString = function () {
          return handler.toString();
        };
        test(formatTitle(_name, toArray(item), idx), options, handlerWrapper);
      });
    };
  };
  taskFn.skipIf = function (condition) {
    return condition ? this.skip : this;
  };
  taskFn.runIf = function (condition) {
    return condition ? this : this.skip;
  };
  taskFn.scoped = function (fixtures) {
    var collector = getCurrentSuite();
    collector.scoped(fixtures);
  };
  taskFn.extend = function (fixtures) {
    var _context = mergeContextFixtures(fixtures, context || {}, runner);
    var originalWrapper = fn;
    return createTest(function (name, optionsOrFn, optionsOrTest) {
      var _options$timeout;
      var collector = getCurrentSuite();
      var scopedFixtures = collector.fixtures();
      var context = _objectSpread$2({}, this);
      if (scopedFixtures) {
        context.fixtures = mergeScopedFixtures(context.fixtures || [], scopedFixtures);
      }
      var _parseArguments7 = parseArguments(optionsOrFn, optionsOrTest),
        handler = _parseArguments7.handler,
        options = _parseArguments7.options;
      var timeout = (_options$timeout = options.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : void 0 ;
      originalWrapper.call(context, formatName(name), handler, timeout);
    }, _context);
  };
  var _test = createChainable(["concurrent", "sequential", "skip", "only", "todo", "fails"], taskFn);
  if (context) {
    _test.mergeContext(context);
  }
  return _test;
}
function createTest(fn, context) {
  return createTaskCollector(fn, context);
}
function formatName(name) {
  return typeof name === "string" ? name : typeof name === "function" ? name.name || "<anonymous>" : String(name);
}
function formatTitle(template, items, idx) {
  if (template.includes("%#") || template.includes("%$")) {
    // '%#' match index of the test case
    template = template.replace(/%%/g, "__vitest_escaped_%__").replace(/%#/g, "".concat(idx)).replace(/%\$/g, "".concat(idx + 1)).replace(/__vitest_escaped_%__/g, "%%");
  }
  var count = template.split("%").length - 1;
  if (template.includes("%f")) {
    var placeholders = template.match(/%f/g) || [];
    placeholders.forEach(function (_, i) {
      if (isNegativeNaN(items[i]) || Object.is(items[i], -0)) {
        // Replace the i-th occurrence of '%f' with '-%f'
        var occurrence = 0;
        template = template.replace(/%f/g, function (match) {
          occurrence++;
          return occurrence === i + 1 ? "-%f" : match;
        });
      }
    });
  }
  var formatted = format.apply(void 0, [template].concat(_toConsumableArray(items.slice(0, count))));
  var isObjectItem = isObject$1(items[0]);
  formatted = formatted.replace(/\$([$\w.]+)/g, function (_, key) {
    var isArrayKey = /^\d+$/.test(key);
    if (!isObjectItem && !isArrayKey) {
      return "$".concat(key);
    }
    var arrayElement = isArrayKey ? objectAttr(items, key) : undefined;
    var value = isObjectItem ? objectAttr(items[0], key, arrayElement) : arrayElement;
    return objDisplay(value, {
      truncate: void 0 
    });
  });
  return formatted;
}
function formatTemplateString(cases, args) {
  var header = cases.join("").trim().replace(/ /g, "").split("\n").map(function (i) {
    return i.split("|");
  })[0];
  var res = [];
  for (var i = 0; i < Math.floor(args.length / header.length); i++) {
    var oneCase = {};
    for (var j = 0; j < header.length; j++) {
      oneCase[header[j]] = args[i * header.length + j];
    }
    res.push(oneCase);
  }
  return res;
}
globalThis.performance ? globalThis.performance.now.bind(globalThis.performance) : Date.now;
function getNames(task) {
  var names = [task.name];
  var current = task;
  while (current === null || current === void 0 ? void 0 : current.suite) {
    current = current.suite;
    if (current === null || current === void 0 ? void 0 : current.name) {
      names.unshift(current.name);
    }
  }
  if (current !== task.file) {
    names.unshift(task.file.name);
  }
  return names;
}
function getTestName(task) {
  var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : " > ";
  return getNames(task).slice(1).join(separator);
}
globalThis.performance ? globalThis.performance.now.bind(globalThis.performance) : Date.now;
getSafeTimers();
var packs = new Map();
var eventsPacks = [];
var pendingTasksUpdates = [];
function sendTasksUpdate(runner) {
  if (packs.size) {
    var _runner$onTaskUpdate;
    var taskPacks = Array.from(packs).map(function (_ref8) {
      var _ref1 = _slicedToArray(_ref8, 2),
        id = _ref1[0],
        task = _ref1[1];
      return [id, task[0], task[1]];
    });
    var p = (_runner$onTaskUpdate = runner.onTaskUpdate) === null || _runner$onTaskUpdate === void 0 ? void 0 : _runner$onTaskUpdate.call(runner, taskPacks, eventsPacks);
    if (p) {
      pendingTasksUpdates.push(p);
      // remove successful promise to not grow array indefnitely,
      // but keep rejections so finishSendTasksUpdate can handle them
      p.then(function () {
        return pendingTasksUpdates.splice(pendingTasksUpdates.indexOf(p), 1);
      }, function () {});
    }
    eventsPacks.length = 0;
    packs.clear();
  }
}
function finishSendTasksUpdate(_x18) {
  return _finishSendTasksUpdate.apply(this, arguments);
}
function _finishSendTasksUpdate() {
  _finishSendTasksUpdate = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee13(runner) {
    return _regeneratorRuntime.wrap(function (_context15) {
      while (1) switch (_context15.prev = _context15.next) {
        case 0:
          sendTasksUpdate(runner);
          _context15.next = 1;
          return Promise.all(pendingTasksUpdates);
        case 1:
        case "end":
          return _context15.stop();
      }
    }, _callee13);
  }));
  return _finishSendTasksUpdate.apply(this, arguments);
}
var now$1 = Date.now;
var collectorContext = {
  tasks: [],
  currentSuite: null
};
function collectTask(task) {
  var _collectorContext$cur;
  (_collectorContext$cur = collectorContext.currentSuite) === null || _collectorContext$cur === void 0 ? void 0 : _collectorContext$cur.tasks.push(task);
}
function runWithSuite(_x33, _x34) {
  return _runWithSuite.apply(this, arguments);
}
function _runWithSuite() {
  _runWithSuite = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee23(suite, fn) {
    var prev;
    return _regeneratorRuntime.wrap(function (_context26) {
      while (1) switch (_context26.prev = _context26.next) {
        case 0:
          prev = collectorContext.currentSuite;
          collectorContext.currentSuite = suite;
          _context26.next = 1;
          return fn();
        case 1:
          collectorContext.currentSuite = prev;
        case 2:
        case "end":
          return _context26.stop();
      }
    }, _callee23);
  }));
  return _runWithSuite.apply(this, arguments);
}
function withTimeout(fn, timeout) {
  var isHook = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var stackTraceError = arguments.length > 3 ? arguments[3] : undefined;
  var onTimeout = arguments.length > 4 ? arguments[4] : undefined;
  if (timeout <= 0 || timeout === Number.POSITIVE_INFINITY) {
    return fn;
  }
  var _getSafeTimers2 = getSafeTimers(),
    setTimeout = _getSafeTimers2.setTimeout,
    clearTimeout = _getSafeTimers2.clearTimeout;
  // this function name is used to filter error in test/cli/test/fails.test.ts
  return function runWithTimeout() {
    for (var _len9 = arguments.length, args = new Array(_len9), _key0 = 0; _key0 < _len9; _key0++) {
      args[_key0] = arguments[_key0];
    }
    var startTime = now$1();
    var runner = getRunner();
    runner._currentTaskStartTime = startTime;
    runner._currentTaskTimeout = timeout;
    return new Promise(function (resolve_, reject_) {
      var _timer$unref;
      var timer = setTimeout(function () {
        clearTimeout(timer);
        rejectTimeoutError();
      }, timeout);
      // `unref` might not exist in browser
      (_timer$unref = timer.unref) === null || _timer$unref === void 0 ? void 0 : _timer$unref.call(timer);
      function rejectTimeoutError() {
        var error = makeTimeoutError(isHook, timeout, stackTraceError);
        onTimeout === null || onTimeout === void 0 ? void 0 : onTimeout(args, error);
        reject_(error);
      }
      function resolve(result) {
        runner._currentTaskStartTime = undefined;
        runner._currentTaskTimeout = undefined;
        clearTimeout(timer);
        // if test/hook took too long in microtask, setTimeout won't be triggered,
        // but we still need to fail the test, see
        // https://github.com/vitest-dev/vitest/issues/2920
        if (now$1() - startTime >= timeout) {
          rejectTimeoutError();
          return;
        }
        resolve_(result);
      }
      function reject(error) {
        runner._currentTaskStartTime = undefined;
        runner._currentTaskTimeout = undefined;
        clearTimeout(timer);
        reject_(error);
      }
      // sync test/hook will be caught by try/catch
      try {
        var result = fn.apply(void 0, args);
        // the result is a thenable, we don't wrap this in Promise.resolve
        // to avoid creating new promises
        if (_typeof(result) === "object" && result != null && typeof result.then === "function") {
          result.then(resolve, reject);
        } else {
          resolve(result);
        }
      }
      // user sync test/hook throws an error
      catch (error) {
        reject(error);
      }
    });
  };
}
var abortControllers = new WeakMap();
function abortIfTimeout(_ref10, error) {
  var _ref11 = _slicedToArray(_ref10, 1),
    context = _ref11[0];
  if (context) {
    abortContextSignal(context, error);
  }
}
function abortContextSignal(context, error) {
  var abortController = abortControllers.get(context);
  abortController === null || abortController === void 0 ? void 0 : abortController.abort(error);
}
function createTestContext(test, runner) {
  var _runner$extendTaskCon;
  var context = function context() {
    throw new Error("done() callback is deprecated, use promise instead");
  };
  var abortController = abortControllers.get(context);
  if (!abortController) {
    abortController = new AbortController();
    abortControllers.set(context, abortController);
  }
  context.signal = abortController.signal;
  context.task = test;
  context.skip = function (condition, note) {
    var _test$result5;
    if (condition === false) {
      // do nothing
      return undefined;
    }
    (_test$result5 = test.result) !== null && _test$result5 !== void 0 ? _test$result5 : test.result = {
      state: "skip"
    };
    test.result.pending = true;
    throw new PendingError("test is skipped; abort execution", test, typeof condition === "string" ? condition : note);
  };
  function annotate(_x35, _x36, _x37, _x38) {
    return _annotate.apply(this, arguments);
  }
  function _annotate() {
    _annotate = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(message, location, type, attachment) {
      var annotation, resolvedAnnotation;
      return _regeneratorRuntime.wrap(function (_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            annotation = {
              message: message,
              type: type || "notice"
            };
            if (!attachment) {
              _context6.next = 3;
              break;
            }
            if (!(!attachment.body && !attachment.path)) {
              _context6.next = 1;
              break;
            }
            throw new TypeError("Test attachment requires body or path to be set. Both are missing.");
          case 1:
            if (!(attachment.body && attachment.path)) {
              _context6.next = 2;
              break;
            }
            throw new TypeError("Test attachment requires only one of \"body\" or \"path\" to be set. Both are specified.");
          case 2:
            annotation.attachment = attachment;
            // convert to a string so it's easier to serialise
            if (attachment.body instanceof Uint8Array) {
              attachment.body = encodeUint8Array(attachment.body);
            }
          case 3:
            if (location) {
              annotation.location = location;
            }
            if (runner.onTestAnnotate) {
              _context6.next = 4;
              break;
            }
            throw new Error("Test runner doesn't support test annotations.");
          case 4:
            _context6.next = 5;
            return finishSendTasksUpdate(runner);
          case 5:
            _context6.next = 6;
            return runner.onTestAnnotate(test, annotation);
          case 6:
            resolvedAnnotation = _context6.sent;
            test.annotations.push(resolvedAnnotation);
            return _context6.abrupt("return", resolvedAnnotation);
          case 7:
          case "end":
            return _context6.stop();
        }
      }, _callee4);
    }));
    return _annotate.apply(this, arguments);
  }
  context.annotate = function (message, type, attachment) {
    if (test.result && test.result.state !== "run") {
      throw new Error("Cannot annotate tests outside of the test run. The test \"".concat(test.name, "\" finished running with the \"").concat(test.result.state, "\" state already."));
    }
    var location;
    var stack = new Error("STACK_TRACE").stack;
    var index = stack.includes("STACK_TRACE") ? 2 : 1;
    var stackLine = stack.split("\n")[index];
    var parsed = parseSingleStack(stackLine);
    if (parsed) {
      location = {
        file: parsed.file,
        line: parsed.line,
        column: parsed.column
      };
    }
    if (_typeof(type) === "object") {
      return recordAsyncAnnotation(test, annotate(message, location, undefined, type));
    } else {
      return recordAsyncAnnotation(test, annotate(message, location, type, attachment));
    }
  };
  context.onTestFailed = function (handler, timeout) {
    test.onFailed || (test.onFailed = []);
    test.onFailed.push(withTimeout(handler, timeout !== null && timeout !== void 0 ? timeout : runner.config.hookTimeout, true, new Error("STACK_TRACE_ERROR"), function (_, error) {
      return abortController.abort(error);
    }));
  };
  context.onTestFinished = function (handler, timeout) {
    test.onFinished || (test.onFinished = []);
    test.onFinished.push(withTimeout(handler, timeout !== null && timeout !== void 0 ? timeout : runner.config.hookTimeout, true, new Error("STACK_TRACE_ERROR"), function (_, error) {
      return abortController.abort(error);
    }));
  };
  return ((_runner$extendTaskCon = runner.extendTaskContext) === null || _runner$extendTaskCon === void 0 ? void 0 : _runner$extendTaskCon.call(runner, context)) || context;
}
function makeTimeoutError(isHook, timeout, stackTraceError) {
  var message = "".concat(isHook ? "Hook" : "Test", " timed out in ").concat(timeout, "ms.\nIf this is a long-running ").concat(isHook ? "hook" : "test", ", pass a timeout value as the last argument or configure it globally with \"").concat(isHook ? "hookTimeout" : "testTimeout", "\".");
  var error = new Error(message);
  if (stackTraceError === null || stackTraceError === void 0 ? void 0 : stackTraceError.stack) {
    error.stack = stackTraceError.stack.replace(error.message, stackTraceError.message);
  }
  return error;
}
var fileContexts = new WeakMap();
function getFileContext(file) {
  var context = fileContexts.get(file);
  if (!context) {
    throw new Error("Cannot find file context for ".concat(file.name));
  }
  return context;
}
var table = [];
for (var i$1 = 65; i$1 < 91; i$1++) {
  table.push(String.fromCharCode(i$1));
}
for (var _i = 97; _i < 123; _i++) {
  table.push(String.fromCharCode(_i));
}
for (var _i2 = 0; _i2 < 10; _i2++) {
  table.push(_i2.toString(10));
}
function encodeUint8Array(bytes) {
  var base64 = "";
  var len = bytes.byteLength;
  for (var _i3 = 0; _i3 < len; _i3 += 3) {
    if (len === _i3 + 1) {
      var a = (bytes[_i3] & 252) >> 2;
      var b = (bytes[_i3] & 3) << 4;
      base64 += table[a];
      base64 += table[b];
      base64 += "==";
    } else if (len === _i3 + 2) {
      var _a = (bytes[_i3] & 252) >> 2;
      var _b = (bytes[_i3] & 3) << 4 | (bytes[_i3 + 1] & 240) >> 4;
      var c = (bytes[_i3 + 1] & 15) << 2;
      base64 += table[_a];
      base64 += table[_b];
      base64 += table[c];
      base64 += "=";
    } else {
      var _a2 = (bytes[_i3] & 252) >> 2;
      var _b2 = (bytes[_i3] & 3) << 4 | (bytes[_i3 + 1] & 240) >> 4;
      var _c = (bytes[_i3 + 1] & 15) << 2 | (bytes[_i3 + 2] & 192) >> 6;
      var d = bytes[_i3 + 2] & 63;
      base64 += table[_a2];
      base64 += table[_b2];
      base64 += table[_c];
      base64 += table[d];
    }
  }
  return base64;
}
function recordAsyncAnnotation(test, promise) {
  // if promise is explicitly awaited, remove it from the list
  promise = promise.finally(function () {
    if (!test.promises) {
      return;
    }
    var index = test.promises.indexOf(promise);
    if (index !== -1) {
      test.promises.splice(index, 1);
    }
  });
  // record promise
  if (!test.promises) {
    test.promises = [];
  }
  test.promises.push(promise);
  return promise;
}

function _createForOfIteratorHelper$2(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$2(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray$2(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray$2(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$2(r, a) : void 0; } }
function _arrayLikeToArray$2(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var NAME_WORKER_STATE = "__vitest_worker__";
function getWorkerState() {
  // @ts-expect-error untyped global
  var workerState = globalThis[NAME_WORKER_STATE];
  if (!workerState) {
    var errorMsg = "Vitest failed to access its internal state.\n\nOne of the following is possible:\n- \"vitest\" is imported directly without running \"vitest\" command\n- \"vitest\" is imported inside \"globalSetup\" (to fix this, use \"setupFiles\" instead, because \"globalSetup\" runs in a different context)\n- \"vitest\" is imported inside Vite / Vitest config file\n- Otherwise, it might be a Vitest bug. Please report it to https://github.com/vitest-dev/vitest/issues\n";
    throw new Error(errorMsg);
  }
  return workerState;
}
function getCurrentEnvironment() {
  var state = getWorkerState();
  return state === null || state === void 0 ? void 0 : state.environment.name;
}
function isChildProcess() {
  return typeof process !== "undefined" && !!process.send;
}
function resetModules(modules) {
  var resetMocks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var skipPaths = [/\/vitest\/dist\//, /\/vite-node\/dist\//, /vitest-virtual-\w+\/dist/, /@vitest\/dist/].concat(_toConsumableArray(!resetMocks ? [/^mock:/] : []));
  modules.forEach(function (mod, path) {
    if (skipPaths.some(function (re) {
      return re.test(path);
    })) return;
    modules.invalidateModule(mod);
  });
}
function waitNextTick() {
  var _getSafeTimers = getSafeTimers(),
    setTimeout = _getSafeTimers.setTimeout;
  return new Promise(function (resolve) {
    return setTimeout(resolve, 0);
  });
}
function waitForImportsToResolve() {
  return _waitForImportsToResolve.apply(this, arguments);
}
function _waitForImportsToResolve() {
  _waitForImportsToResolve = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
    var state, promises, resolvingCount, _iterator, _step, mod;
    return _regeneratorRuntime.wrap(function (_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 1;
          return waitNextTick();
        case 1:
          state = getWorkerState();
          promises = [];
          resolvingCount = 0;
          _iterator = _createForOfIteratorHelper$2(state.moduleCache.values());
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              mod = _step.value;
              if (mod.promise && !mod.evaluated) promises.push(mod.promise);
              if (mod.resolving) resolvingCount++;
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          if (!(!promises.length && !resolvingCount)) {
            _context.next = 2;
            break;
          }
          return _context.abrupt("return");
        case 2:
          _context.next = 3;
          return Promise.allSettled(promises);
        case 3:
          _context.next = 4;
          return waitForImportsToResolve();
        case 4:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _waitForImportsToResolve.apply(this, arguments);
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
function getDefaultExportFromCjs$1(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function _createForOfIteratorHelper$1(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$1(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray$1(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray$1(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$1(r, a) : void 0; } }
function _arrayLikeToArray$1(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _callSuper$2(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$2() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$2() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$2 = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function ownKeys$1(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$1(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$1(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var comma = ','.charCodeAt(0);
var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
var intToChar = new Uint8Array(64); // 64 possible chars.
var charToInt = new Uint8Array(128); // z is 122 in ASCII
for (var i = 0; i < chars.length; i++) {
  var c = chars.charCodeAt(i);
  intToChar[i] = c;
  charToInt[c] = i;
}
function decodeInteger(reader, relative) {
  var value = 0;
  var shift = 0;
  var integer = 0;
  do {
    var _c = reader.next();
    integer = charToInt[_c];
    value |= (integer & 31) << shift;
    shift += 5;
  } while (integer & 32);
  var shouldNegate = value & 1;
  value >>>= 1;
  if (shouldNegate) {
    value = -2147483648 | -value;
  }
  return relative + value;
}
function hasMoreVlq(reader, max) {
  if (reader.pos >= max) return false;
  return reader.peek() !== comma;
}
var StringReader = /*#__PURE__*/function () {
  function StringReader(buffer) {
    _classCallCheck(this, StringReader);
    this.pos = 0;
    this.buffer = buffer;
  }
  return _createClass(StringReader, [{
    key: "next",
    value: function next() {
      return this.buffer.charCodeAt(this.pos++);
    }
  }, {
    key: "peek",
    value: function peek() {
      return this.buffer.charCodeAt(this.pos);
    }
  }, {
    key: "indexOf",
    value: function indexOf(char) {
      var buffer = this.buffer,
        pos = this.pos;
      var idx = buffer.indexOf(char, pos);
      return idx === -1 ? buffer.length : idx;
    }
  }]);
}();
function decode(mappings) {
  var length = mappings.length;
  var reader = new StringReader(mappings);
  var decoded = [];
  var genColumn = 0;
  var sourcesIndex = 0;
  var sourceLine = 0;
  var sourceColumn = 0;
  var namesIndex = 0;
  do {
    var semi = reader.indexOf(';');
    var line = [];
    var sorted = true;
    var lastCol = 0;
    genColumn = 0;
    while (reader.pos < semi) {
      var seg = void 0;
      genColumn = decodeInteger(reader, genColumn);
      if (genColumn < lastCol) sorted = false;
      lastCol = genColumn;
      if (hasMoreVlq(reader, semi)) {
        sourcesIndex = decodeInteger(reader, sourcesIndex);
        sourceLine = decodeInteger(reader, sourceLine);
        sourceColumn = decodeInteger(reader, sourceColumn);
        if (hasMoreVlq(reader, semi)) {
          namesIndex = decodeInteger(reader, namesIndex);
          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];
        } else {
          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];
        }
      } else {
        seg = [genColumn];
      }
      line.push(seg);
      reader.pos++;
    }
    if (!sorted) sort(line);
    decoded.push(line);
    reader.pos = semi + 1;
  } while (reader.pos <= length);
  return decoded;
}
function sort(line) {
  line.sort(sortComparator$1);
}
function sortComparator$1(a, b) {
  return a[0] - b[0];
}

// Matches the scheme of a URL, eg "http://"
var schemeRegex = /^[\w+.-]+:\/\//;
/**
 * Matches the parts of a URL:
 * 1. Scheme, including ":", guaranteed.
 * 2. User/password, including "@", optional.
 * 3. Host, guaranteed.
 * 4. Port, including ":", optional.
 * 5. Path, including "/", optional.
 * 6. Query, including "?", optional.
 * 7. Hash, including "#", optional.
 */
var urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
/**
 * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start
 * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).
 *
 * 1. Host, optional.
 * 2. Path, which may include "/", guaranteed.
 * 3. Query, including "?", optional.
 * 4. Hash, including "#", optional.
 */
var fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
var UrlType;
(function (UrlType) {
  UrlType[UrlType["Empty"] = 1] = "Empty";
  UrlType[UrlType["Hash"] = 2] = "Hash";
  UrlType[UrlType["Query"] = 3] = "Query";
  UrlType[UrlType["RelativePath"] = 4] = "RelativePath";
  UrlType[UrlType["AbsolutePath"] = 5] = "AbsolutePath";
  UrlType[UrlType["SchemeRelative"] = 6] = "SchemeRelative";
  UrlType[UrlType["Absolute"] = 7] = "Absolute";
})(UrlType || (UrlType = {}));
function isAbsoluteUrl(input) {
  return schemeRegex.test(input);
}
function isSchemeRelativeUrl(input) {
  return input.startsWith('//');
}
function isAbsolutePath(input) {
  return input.startsWith('/');
}
function isFileUrl(input) {
  return input.startsWith('file:');
}
function isRelative(input) {
  return /^[.?#]/.test(input);
}
function parseAbsoluteUrl(input) {
  var match = urlRegex.exec(input);
  return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');
}
function parseFileUrl(input) {
  var match = fileRegex.exec(input);
  var path = match[2];
  return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');
}
function makeUrl(scheme, user, host, port, path, query, hash) {
  return {
    scheme: scheme,
    user: user,
    host: host,
    port: port,
    path: path,
    query: query,
    hash: hash,
    type: UrlType.Absolute
  };
}
function parseUrl(input) {
  if (isSchemeRelativeUrl(input)) {
    var _url = parseAbsoluteUrl('http:' + input);
    _url.scheme = '';
    _url.type = UrlType.SchemeRelative;
    return _url;
  }
  if (isAbsolutePath(input)) {
    var _url2 = parseAbsoluteUrl('http://foo.com' + input);
    _url2.scheme = '';
    _url2.host = '';
    _url2.type = UrlType.AbsolutePath;
    return _url2;
  }
  if (isFileUrl(input)) return parseFileUrl(input);
  if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);
  var url = parseAbsoluteUrl('http://foo.com/' + input);
  url.scheme = '';
  url.host = '';
  url.type = input ? input.startsWith('?') ? UrlType.Query : input.startsWith('#') ? UrlType.Hash : UrlType.RelativePath : UrlType.Empty;
  return url;
}
function stripPathFilename(path) {
  // If a path ends with a parent directory "..", then it's a relative path with excess parent
  // paths. It's not a file, so we can't strip it.
  if (path.endsWith('/..')) return path;
  var index = path.lastIndexOf('/');
  return path.slice(0, index + 1);
}
function mergePaths(url, base) {
  normalizePath(base, base.type);
  // If the path is just a "/", then it was an empty path to begin with (remember, we're a relative
  // path).
  if (url.path === '/') {
    url.path = base.path;
  } else {
    // Resolution happens relative to the base path's directory, not the file.
    url.path = stripPathFilename(base.path) + url.path;
  }
}
/**
 * The path can have empty directories "//", unneeded parents "foo/..", or current directory
 * "foo/.". We need to normalize to a standard representation.
 */
function normalizePath(url, type) {
  var rel = type <= UrlType.RelativePath;
  var pieces = url.path.split('/');
  // We need to preserve the first piece always, so that we output a leading slash. The item at
  // pieces[0] is an empty string.
  var pointer = 1;
  // Positive is the number of real directories we've output, used for popping a parent directory.
  // Eg, "foo/bar/.." will have a positive 2, and we can decrement to be left with just "foo".
  var positive = 0;
  // We need to keep a trailing slash if we encounter an empty directory (eg, splitting "foo/" will
  // generate `["foo", ""]` pieces). And, if we pop a parent directory. But once we encounter a
  // real directory, we won't need to append, unless the other conditions happen again.
  var addTrailingSlash = false;
  for (var _i = 1; _i < pieces.length; _i++) {
    var piece = pieces[_i];
    // An empty directory, could be a trailing slash, or just a double "//" in the path.
    if (!piece) {
      addTrailingSlash = true;
      continue;
    }
    // If we encounter a real directory, then we don't need to append anymore.
    addTrailingSlash = false;
    // A current directory, which we can always drop.
    if (piece === '.') continue;
    // A parent directory, we need to see if there are any real directories we can pop. Else, we
    // have an excess of parents, and we'll need to keep the "..".
    if (piece === '..') {
      if (positive) {
        addTrailingSlash = true;
        positive--;
        pointer--;
      } else if (rel) {
        // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute
        // URL, protocol relative URL, or an absolute path, we don't need to keep excess.
        pieces[pointer++] = piece;
      }
      continue;
    }
    // We've encountered a real directory. Move it to the next insertion pointer, which accounts for
    // any popped or dropped directories.
    pieces[pointer++] = piece;
    positive++;
  }
  var path = '';
  for (var _i2 = 1; _i2 < pointer; _i2++) {
    path += '/' + pieces[_i2];
  }
  if (!path || addTrailingSlash && !path.endsWith('/..')) {
    path += '/';
  }
  url.path = path;
}
/**
 * Attempts to resolve `input` URL/path relative to `base`.
 */
function resolve$1(input, base) {
  if (!input && !base) return '';
  var url = parseUrl(input);
  var inputType = url.type;
  if (base && inputType !== UrlType.Absolute) {
    var baseUrl = parseUrl(base);
    var baseType = baseUrl.type;
    switch (inputType) {
      case UrlType.Empty:
        url.hash = baseUrl.hash;
      // fall through
      case UrlType.Hash:
        url.query = baseUrl.query;
      // fall through
      case UrlType.Query:
      case UrlType.RelativePath:
        mergePaths(url, baseUrl);
      // fall through
      case UrlType.AbsolutePath:
        // The host, user, and port are joined, you can't copy one without the others.
        url.user = baseUrl.user;
        url.host = baseUrl.host;
        url.port = baseUrl.port;
      // fall through
      case UrlType.SchemeRelative:
        // The input doesn't have a schema at least, so we need to copy at least that over.
        url.scheme = baseUrl.scheme;
    }
    if (baseType > inputType) inputType = baseType;
  }
  normalizePath(url, inputType);
  var queryHash = url.query + url.hash;
  switch (inputType) {
    // This is impossible, because of the empty checks at the start of the function.
    // case UrlType.Empty:
    case UrlType.Hash:
    case UrlType.Query:
      return queryHash;
    case UrlType.RelativePath:
      {
        // The first char is always a "/", and we need it to be relative.
        var path = url.path.slice(1);
        if (!path) return queryHash || '.';
        if (isRelative(base || input) && !isRelative(path)) {
          // If base started with a leading ".", or there is no base and input started with a ".",
          // then we need to ensure that the relative path starts with a ".". We don't know if
          // relative starts with a "..", though, so check before prepending.
          return './' + path + queryHash;
        }
        return path + queryHash;
      }
    case UrlType.AbsolutePath:
      return url.path + queryHash;
    default:
      return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;
  }
}
function resolve(input, base) {
  // The base is always treated as a directory, if it's not empty.
  // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327
  // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401
  if (base && !base.endsWith('/')) base += '/';
  return resolve$1(input, base);
}

/**
 * Removes everything after the last "/", but leaves the slash.
 */
function stripFilename(path) {
  if (!path) return '';
  var index = path.lastIndexOf('/');
  return path.slice(0, index + 1);
}
var COLUMN = 0;
var SOURCES_INDEX = 1;
var SOURCE_LINE = 2;
var SOURCE_COLUMN = 3;
var NAMES_INDEX = 4;
function maybeSort(mappings, owned) {
  var unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
  if (unsortedIndex === mappings.length) return mappings;
  // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If
  // not, we do not want to modify the consumer's input array.
  if (!owned) mappings = mappings.slice();
  for (var _i3 = unsortedIndex; _i3 < mappings.length; _i3 = nextUnsortedSegmentLine(mappings, _i3 + 1)) {
    mappings[_i3] = sortSegments(mappings[_i3], owned);
  }
  return mappings;
}
function nextUnsortedSegmentLine(mappings, start) {
  for (var _i4 = start; _i4 < mappings.length; _i4++) {
    if (!isSorted(mappings[_i4])) return _i4;
  }
  return mappings.length;
}
function isSorted(line) {
  for (var j = 1; j < line.length; j++) {
    if (line[j][COLUMN] < line[j - 1][COLUMN]) {
      return false;
    }
  }
  return true;
}
function sortSegments(line, owned) {
  if (!owned) line = line.slice();
  return line.sort(sortComparator);
}
function sortComparator(a, b) {
  return a[COLUMN] - b[COLUMN];
}
var found = false;
/**
 * A binary search implementation that returns the index if a match is found.
 * If no match is found, then the left-index (the index associated with the item that comes just
 * before the desired index) is returned. To maintain proper sort order, a splice would happen at
 * the next index:
 *
 * ```js
 * const array = [1, 3];
 * const needle = 2;
 * const index = binarySearch(array, needle, (item, needle) => item - needle);
 *
 * assert.equal(index, 0);
 * array.splice(index + 1, 0, needle);
 * assert.deepEqual(array, [1, 2, 3]);
 * ```
 */
function binarySearch(haystack, needle, low, high) {
  while (low <= high) {
    var mid = low + (high - low >> 1);
    var cmp = haystack[mid][COLUMN] - needle;
    if (cmp === 0) {
      found = true;
      return mid;
    }
    if (cmp < 0) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  found = false;
  return low - 1;
}
function upperBound(haystack, needle, index) {
  for (var _i5 = index + 1; _i5 < haystack.length; index = _i5++) {
    if (haystack[_i5][COLUMN] !== needle) break;
  }
  return index;
}
function lowerBound(haystack, needle, index) {
  for (var _i6 = index - 1; _i6 >= 0; index = _i6--) {
    if (haystack[_i6][COLUMN] !== needle) break;
  }
  return index;
}
function memoizedState() {
  return {
    lastKey: -1,
    lastNeedle: -1,
    lastIndex: -1
  };
}
/**
 * This overly complicated beast is just to record the last tested line/column and the resulting
 * index, allowing us to skip a few tests if mappings are monotonically increasing.
 */
function memoizedBinarySearch(haystack, needle, state, key) {
  var lastKey = state.lastKey,
    lastNeedle = state.lastNeedle,
    lastIndex = state.lastIndex;
  var low = 0;
  var high = haystack.length - 1;
  if (key === lastKey) {
    if (needle === lastNeedle) {
      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
      return lastIndex;
    }
    if (needle >= lastNeedle) {
      // lastIndex may be -1 if the previous needle was not found.
      low = lastIndex === -1 ? 0 : lastIndex;
    } else {
      high = lastIndex;
    }
  }
  state.lastKey = key;
  state.lastNeedle = needle;
  return state.lastIndex = binarySearch(haystack, needle, low, high);
}
var LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';
var COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';
var LEAST_UPPER_BOUND = -1;
var GREATEST_LOWER_BOUND = 1;
var TraceMap = /*#__PURE__*/_createClass(function TraceMap(map, mapUrl) {
  _classCallCheck(this, TraceMap);
  var isString = typeof map === 'string';
  if (!isString && map._decodedMemo) return map;
  var parsed = isString ? JSON.parse(map) : map;
  var version = parsed.version,
    file = parsed.file,
    names = parsed.names,
    sourceRoot = parsed.sourceRoot,
    sources = parsed.sources,
    sourcesContent = parsed.sourcesContent;
  this.version = version;
  this.file = file;
  this.names = names || [];
  this.sourceRoot = sourceRoot;
  this.sources = sources;
  this.sourcesContent = sourcesContent;
  this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || undefined;
  var from = resolve(sourceRoot || '', stripFilename(mapUrl));
  this.resolvedSources = sources.map(function (s) {
    return resolve(s || '', from);
  });
  var mappings = parsed.mappings;
  if (typeof mappings === 'string') {
    this._encoded = mappings;
    this._decoded = undefined;
  } else {
    this._encoded = undefined;
    this._decoded = maybeSort(mappings, isString);
  }
  this._decodedMemo = memoizedState();
  this._bySources = undefined;
  this._bySourceMemos = undefined;
});
/**
 * Typescript doesn't allow friend access to private fields, so this just casts the map into a type
 * with public access modifiers.
 */
function cast(map) {
  return map;
}
/**
 * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.
 */
function decodedMappings(map) {
  var _a;
  return (_a = cast(map))._decoded || (_a._decoded = decode(cast(map)._encoded));
}
/**
 * A higher-level API to find the source/line/column associated with a generated line/column
 * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in
 * `source-map` library.
 */
function originalPositionFor(map, needle) {
  var line = needle.line,
    column = needle.column,
    bias = needle.bias;
  line--;
  if (line < 0) throw new Error(LINE_GTR_ZERO);
  if (column < 0) throw new Error(COL_GTR_EQ_ZERO);
  var decoded = decodedMappings(map);
  // It's common for parent source maps to have pointers to lines that have no
  // mapping (like a "//# sourceMappingURL=") at the end of the child file.
  if (line >= decoded.length) return OMapping(null, null, null, null);
  var segments = decoded[line];
  var index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
  if (index === -1) return OMapping(null, null, null, null);
  var segment = segments[index];
  if (segment.length === 1) return OMapping(null, null, null, null);
  var names = map.names,
    resolvedSources = map.resolvedSources;
  return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);
}
function OMapping(source, line, column, name) {
  return {
    source: source,
    line: line,
    column: column,
    name: name
  };
}
function traceSegmentInternal(segments, memo, line, column, bias) {
  var index = memoizedBinarySearch(segments, column, memo, line);
  if (found) {
    index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
  } else if (bias === LEAST_UPPER_BOUND) index++;
  if (index === -1 || index === segments.length) return -1;
  return index;
}

/**
* Get original stacktrace without source map support the most performant way.
* - Create only 1 stack frame.
* - Rewrite prepareStackTrace to bypass "support-stack-trace" (usually takes ~250ms).
*/
function notNullish(v) {
  return v != null;
}
function isPrimitive(value) {
  return value === null || typeof value !== "function" && _typeof(value) !== "object";
}
function isObject(item) {
  return item != null && _typeof(item) === "object" && !Array.isArray(item);
}
/**
* If code starts with a function call, will return its last index, respecting arguments.
* This will return 25 - last ending character of toMatch ")"
* Also works with callbacks
* ```
* toMatch({ test: '123' });
* toBeAliased('123')
* ```
*/
function getCallLastIndex(code) {
  var charIndex = -1;
  var inString = null;
  var startedBracers = 0;
  var endedBracers = 0;
  var beforeChar = null;
  while (charIndex <= code.length) {
    beforeChar = code[charIndex];
    charIndex++;
    var char = code[charIndex];
    var isCharString = char === "\"" || char === "'" || char === "`";
    if (isCharString && beforeChar !== "\\") {
      if (inString === char) {
        inString = null;
      } else if (!inString) {
        inString = char;
      }
    }
    if (!inString) {
      if (char === "(") {
        startedBracers++;
      }
      if (char === ")") {
        endedBracers++;
      }
    }
    if (startedBracers && endedBracers && startedBracers === endedBracers) {
      return charIndex;
    }
  }
  return null;
}
var CHROME_IE_STACK_REGEXP = /^\s*at .*(?:\S:\d+|\(native\))/m;
var SAFARI_NATIVE_CODE_REGEXP = /^(?:eval@)?(?:\[native code\])?$/;
var stackIgnorePatterns = ["node:internal", /\/packages\/\w+\/dist\//, /\/@vitest\/\w+\/dist\//, "/vitest/dist/", "/vitest/src/", "/vite-node/dist/", "/vite-node/src/", "/node_modules/chai/", "/node_modules/tinypool/", "/node_modules/tinyspy/", "/deps/chunk-", "/deps/@vitest", "/deps/loupe", "/deps/chai", /node:\w+/, /__vitest_test__/, /__vitest_browser__/, /\/deps\/vitest_/];
function extractLocation(urlLike) {
  // Fail-fast but return locations like "(native)"
  if (!urlLike.includes(":")) {
    return [urlLike];
  }
  var regExp = /(.+?)(?::(\d+))?(?::(\d+))?$/;
  var parts = regExp.exec(urlLike.replace(/^\(|\)$/g, ""));
  if (!parts) {
    return [urlLike];
  }
  var url = parts[1];
  if (url.startsWith("async ")) {
    url = url.slice(6);
  }
  if (url.startsWith("http:") || url.startsWith("https:")) {
    var urlObj = new URL(url);
    urlObj.searchParams.delete("import");
    urlObj.searchParams.delete("browserv");
    url = urlObj.pathname + urlObj.hash + urlObj.search;
  }
  if (url.startsWith("/@fs/")) {
    var isWindows = /^\/@fs\/[a-zA-Z]:\//.test(url);
    url = url.slice(isWindows ? 5 : 4);
  }
  return [url, parts[2] || undefined, parts[3] || undefined];
}
function parseSingleFFOrSafariStack(raw) {
  var line = raw.trim();
  if (SAFARI_NATIVE_CODE_REGEXP.test(line)) {
    return null;
  }
  if (line.includes(" > eval")) {
    line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ":$1");
  }
  if (!line.includes("@") && !line.includes(":")) {
    return null;
  }
  // eslint-disable-next-line regexp/no-super-linear-backtracking, regexp/optimal-quantifier-concatenation
  var functionNameRegex = /((.*".+"[^@]*)?[^@]*)(@)/;
  var matches = line.match(functionNameRegex);
  var functionName = matches && matches[1] ? matches[1] : undefined;
  var _extractLocation = extractLocation(line.replace(functionNameRegex, "")),
    _extractLocation2 = _slicedToArray(_extractLocation, 3),
    url = _extractLocation2[0],
    lineNumber = _extractLocation2[1],
    columnNumber = _extractLocation2[2];
  if (!url || !lineNumber || !columnNumber) {
    return null;
  }
  return {
    file: url,
    method: functionName || "",
    line: Number.parseInt(lineNumber),
    column: Number.parseInt(columnNumber)
  };
}
// Based on https://github.com/stacktracejs/error-stack-parser
// Credit to stacktracejs
function parseSingleV8Stack(raw) {
  var line = raw.trim();
  if (!CHROME_IE_STACK_REGEXP.test(line)) {
    return null;
  }
  if (line.includes("(eval ")) {
    line = line.replace(/eval code/g, "eval").replace(/(\(eval at [^()]*)|(,.*$)/g, "");
  }
  var sanitizedLine = line.replace(/^\s+/, "").replace(/\(eval code/g, "(").replace(/^.*?\s+/, "");
  // capture and preserve the parenthesized location "(/foo/my bar.js:12:87)" in
  // case it has spaces in it, as the string is split on \s+ later on
  var location = sanitizedLine.match(/ (\(.+\)$)/);
  // remove the parenthesized location from the line, if it was matched
  sanitizedLine = location ? sanitizedLine.replace(location[0], "") : sanitizedLine;
  // if a location was matched, pass it to extractLocation() otherwise pass all sanitizedLine
  // because this line doesn't have function name
  var _extractLocation3 = extractLocation(location ? location[1] : sanitizedLine),
    _extractLocation4 = _slicedToArray(_extractLocation3, 3),
    url = _extractLocation4[0],
    lineNumber = _extractLocation4[1],
    columnNumber = _extractLocation4[2];
  var method = location && sanitizedLine || "";
  var file = url && ["eval", "<anonymous>"].includes(url) ? undefined : url;
  if (!file || !lineNumber || !columnNumber) {
    return null;
  }
  if (method.startsWith("async ")) {
    method = method.slice(6);
  }
  if (file.startsWith("file://")) {
    file = file.slice(7);
  }
  // normalize Windows path (\ -> /)
  file = file.startsWith("node:") || file.startsWith("internal:") ? file : resolve$2(file);
  if (method) {
    method = method.replace(/__vite_ssr_import_\d+__\./g, "");
  }
  return {
    method: method,
    file: file,
    line: Number.parseInt(lineNumber),
    column: Number.parseInt(columnNumber)
  };
}
function parseStacktrace(stack) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _options$ignoreStackE = options.ignoreStackEntries,
    ignoreStackEntries = _options$ignoreStackE === void 0 ? stackIgnorePatterns : _options$ignoreStackE;
  var stacks = !CHROME_IE_STACK_REGEXP.test(stack) ? parseFFOrSafariStackTrace(stack) : parseV8Stacktrace(stack);
  return stacks.map(function (stack) {
    var _options$getSourceMap;
    if (options.getUrlId) {
      stack.file = options.getUrlId(stack.file);
    }
    var map = (_options$getSourceMap = options.getSourceMap) === null || _options$getSourceMap === void 0 ? void 0 : _options$getSourceMap.call(options, stack.file);
    if (!map || _typeof(map) !== "object" || !map.version) {
      return shouldFilter(ignoreStackEntries, stack.file) ? null : stack;
    }
    var traceMap = new TraceMap(map);
    var _originalPositionFor = originalPositionFor(traceMap, stack),
      line = _originalPositionFor.line,
      column = _originalPositionFor.column,
      source = _originalPositionFor.source,
      name = _originalPositionFor.name;
    var file = stack.file;
    if (source) {
      var fileUrl = stack.file.startsWith("file://") ? stack.file : "file://".concat(stack.file);
      var sourceRootUrl = map.sourceRoot ? new URL(map.sourceRoot, fileUrl) : fileUrl;
      file = new URL(source, sourceRootUrl).pathname;
      // if the file path is on windows, we need to remove the leading slash
      if (file.match(/\/\w:\//)) {
        file = file.slice(1);
      }
    }
    if (shouldFilter(ignoreStackEntries, file)) {
      return null;
    }
    if (line != null && column != null) {
      return {
        line: line,
        column: column,
        file: file,
        method: name || stack.method
      };
    }
    return stack;
  }).filter(function (s) {
    return s != null;
  });
}
function shouldFilter(ignoreStackEntries, file) {
  return ignoreStackEntries.some(function (p) {
    return file.match(p);
  });
}
function parseFFOrSafariStackTrace(stack) {
  return stack.split("\n").map(function (line) {
    return parseSingleFFOrSafariStack(line);
  }).filter(notNullish);
}
function parseV8Stacktrace(stack) {
  return stack.split("\n").map(function (line) {
    return parseSingleV8Stack(line);
  }).filter(notNullish);
}
function parseErrorStacktrace(e) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (!e || isPrimitive(e)) {
    return [];
  }
  if (e.stacks) {
    return e.stacks;
  }
  var stackStr = e.stack || "";
  // if "stack" property was overwritten at runtime to be something else,
  // ignore the value because we don't know how to process it
  var stackFrames = typeof stackStr === "string" ? parseStacktrace(stackStr, options) : [];
  if (!stackFrames.length) {
    var e_ = e;
    if (e_.fileName != null && e_.lineNumber != null && e_.columnNumber != null) {
      stackFrames = parseStacktrace("".concat(e_.fileName, ":").concat(e_.lineNumber, ":").concat(e_.columnNumber), options);
    }
    if (e_.sourceURL != null && e_.line != null && e_._column != null) {
      stackFrames = parseStacktrace("".concat(e_.sourceURL, ":").concat(e_.line, ":").concat(e_.column), options);
    }
  }
  if (options.frameFilter) {
    stackFrames = stackFrames.filter(function (f) {
      return options.frameFilter(e, f) !== false;
    });
  }
  e.stacks = stackFrames;
  return stackFrames;
}
var getPromiseValue = function getPromiseValue() {
  return 'Promise{…}';
};
try {
  // @ts-ignore
  var _process$binding = process.binding('util'),
    getPromiseDetails = _process$binding.getPromiseDetails,
    kPending = _process$binding.kPending,
    kRejected = _process$binding.kRejected;
  if (Array.isArray(getPromiseDetails(Promise.resolve()))) {
    getPromiseValue = function getPromiseValue(value, options) {
      var _getPromiseDetails = getPromiseDetails(value),
        _getPromiseDetails2 = _slicedToArray(_getPromiseDetails, 2),
        state = _getPromiseDetails2[0],
        innerValue = _getPromiseDetails2[1];
      if (state === kPending) {
        return 'Promise{<pending>}';
      }
      return "Promise".concat(state === kRejected ? '!' : '', "{").concat(options.inspect(innerValue, options), "}");
    };
  }
} catch (notNode) {
  /* ignore */
}
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}
var jsTokens_1;
var hasRequiredJsTokens;
function requireJsTokens() {
  if (hasRequiredJsTokens) return jsTokens_1;
  hasRequiredJsTokens = 1;
  // Copyright 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023 Simon Lydell
  // License: MIT.
  var Identifier, JSXIdentifier, JSXPunctuator, JSXString, JSXText, KeywordsWithExpressionAfter, KeywordsWithNoLineTerminatorAfter, LineTerminatorSequence, MultiLineComment, Newline, NumericLiteral, Punctuator, RegularExpressionLiteral, SingleLineComment, StringLiteral, Template, TokensNotPrecedingObjectLiteral, TokensPrecedingExpression, WhiteSpace;
  RegularExpressionLiteral = new RegExp("\\/(?![\\*\\/])(?:\\[(?:(?![\\\\\\]])(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])|\\\\(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]))*\\]|(?![\\/\\\\])(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])|\\\\(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]))*(\\/(?:[\\$0-9A-Z_a-z\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u07FD\\u0800-\\u082D\\u0840-\\u085B\\u0860-\\u086A\\u0870-\\u0887\\u0889-\\u088F\\u0897-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u09FC\\u09FE\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9-\\u0AFF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B55-\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3C-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C5C\\u0C5D\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDC-\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1-\\u0CF3\\u0D00-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D81-\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECE\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u1715\\u171F-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u180F-\\u1819\\u1820-\\u1878\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1ABF-\\u1ADD\\u1AE0-\\u1AEB\\u1B00-\\u1B4C\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C8A\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CD0-\\u1CD2\\u1CD4-\\u1CFA\\u1D00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7DC\\uA7F1-\\uA827\\uA82C\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF65-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDD70-\\uDD7A\\uDD7C-\\uDD8A\\uDD8C-\\uDD92\\uDD94\\uDD95\\uDD97-\\uDDA1\\uDDA3-\\uDDB1\\uDDB3-\\uDDB9\\uDDBB\\uDDBC\\uDDC0-\\uDDF3\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67\\uDF80-\\uDF85\\uDF87-\\uDFB0\\uDFB2-\\uDFBA]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD40-\\uDD59\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD27\\uDD30-\\uDD39\\uDD40-\\uDD65\\uDD69-\\uDD6D\\uDD6F-\\uDD85\\uDE80-\\uDEA9\\uDEAB\\uDEAC\\uDEB0\\uDEB1\\uDEC2-\\uDEC7\\uDEFA-\\uDF1C\\uDF27\\uDF30-\\uDF50\\uDF70-\\uDF85\\uDFB0-\\uDFC4\\uDFE0-\\uDFF6]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC75\\uDC7F-\\uDCBA\\uDCC2\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD44-\\uDD47\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDC9-\\uDDCC\\uDDCE-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E-\\uDE41\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3B-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74\\uDF80-\\uDF89\\uDF8B\\uDF8E\\uDF90-\\uDFB5\\uDFB7-\\uDFC0\\uDFC2\\uDFC5\\uDFC7-\\uDFCA\\uDFCC-\\uDFD3\\uDFE1\\uDFE2]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC5E-\\uDC61\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB8\\uDEC0-\\uDEC9\\uDED0-\\uDEE3\\uDF00-\\uDF1A\\uDF1D-\\uDF2B\\uDF30-\\uDF39\\uDF40-\\uDF46]|\\uD806[\\uDC00-\\uDC3A\\uDCA0-\\uDCE9\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD35\\uDD37\\uDD38\\uDD3B-\\uDD43\\uDD50-\\uDD59\\uDDA0-\\uDDA7\\uDDAA-\\uDDD7\\uDDDA-\\uDDE1\\uDDE3\\uDDE4\\uDE00-\\uDE3E\\uDE47\\uDE50-\\uDE99\\uDE9D\\uDEB0-\\uDEF8\\uDF60-\\uDF67\\uDFC0-\\uDFE0\\uDFF0-\\uDFF9]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD47\\uDD50-\\uDD59\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD8E\\uDD90\\uDD91\\uDD93-\\uDD98\\uDDA0-\\uDDA9\\uDDB0-\\uDDDB\\uDDE0-\\uDDE9\\uDEE0-\\uDEF6\\uDF00-\\uDF10\\uDF12-\\uDF3A\\uDF3E-\\uDF42\\uDF50-\\uDF5A\\uDFB0]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|\\uD80B[\\uDF90-\\uDFF0]|[\\uD80C\\uD80E\\uD80F\\uD81C-\\uD822\\uD840-\\uD868\\uD86A-\\uD86D\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883\\uD885-\\uD88C][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2F\\uDC40-\\uDC55\\uDC60-\\uDFFF]|\\uD810[\\uDC00-\\uDFFA]|\\uD811[\\uDC00-\\uDE46]|\\uD818[\\uDD00-\\uDD39]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDE70-\\uDEBE\\uDEC0-\\uDEC9\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDD40-\\uDD6C\\uDD70-\\uDD79\\uDE40-\\uDE7F\\uDEA0-\\uDEB8\\uDEBB-\\uDED3\\uDF00-\\uDF4A\\uDF4F-\\uDF87\\uDF8F-\\uDF9F\\uDFE0\\uDFE1\\uDFE3\\uDFE4\\uDFF0-\\uDFF6]|\\uD823[\\uDC00-\\uDCD5\\uDCFF-\\uDD1E\\uDD80-\\uDDF2]|\\uD82B[\\uDFF0-\\uDFF3\\uDFF5-\\uDFFB\\uDFFD\\uDFFE]|\\uD82C[\\uDC00-\\uDD22\\uDD32\\uDD50-\\uDD52\\uDD55\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD833[\\uDCF0-\\uDCF9\\uDF00-\\uDF2D\\uDF30-\\uDF46]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD837[\\uDF00-\\uDF1E\\uDF25-\\uDF2A]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDC30-\\uDC6D\\uDC8F\\uDD00-\\uDD2C\\uDD30-\\uDD3D\\uDD40-\\uDD49\\uDD4E\\uDE90-\\uDEAE\\uDEC0-\\uDEF9]|\\uD839[\\uDCD0-\\uDCF9\\uDDD0-\\uDDFA\\uDEC0-\\uDEDE\\uDEE0-\\uDEF5\\uDEFE\\uDEFF\\uDFE0-\\uDFE6\\uDFE8-\\uDFEB\\uDFED\\uDFEE\\uDFF0-\\uDFFE]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4B\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD83E[\\uDFF0-\\uDFF9]|\\uD869[\\uDC00-\\uDEDF\\uDF00-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEAD\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0\\uDFF0-\\uDFFF]|\\uD87B[\\uDC00-\\uDE5D]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A\\uDF50-\\uDFFF]|\\uD88D[\\uDC00-\\uDC79]|\\uDB40[\\uDD00-\\uDDEF])*|\\\\)?", "y");
  Punctuator = new RegExp("--|\\+\\+|=>|\\.{3}|\\??\\.(?!\\d)|(?:&&|\\|\\||\\?\\?|[+\\-%&|^]|\\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\\/(?![\\/*]))=?|[?~,:;[\\](){}]", "y");
  Identifier = new RegExp("(#?)(?=(?:[\\$A-Z\\\\_a-z\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u0870-\\u0887\\u0889-\\u088F\\u08A0-\\u08C9\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C5C\\u0C5D\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDC-\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D04-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u1711\\u171F-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1878\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4C\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C8A\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7DC\\uA7F1-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDD70-\\uDD7A\\uDD7C-\\uDD8A\\uDD8C-\\uDD92\\uDD94\\uDD95\\uDD97-\\uDDA1\\uDDA3-\\uDDB1\\uDDB3-\\uDDB9\\uDDBB\\uDDBC\\uDDC0-\\uDDF3\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67\\uDF80-\\uDF85\\uDF87-\\uDFB0\\uDFB2-\\uDFBA]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD40-\\uDD59\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD23\\uDD4A-\\uDD65\\uDD6F-\\uDD85\\uDE80-\\uDEA9\\uDEB0\\uDEB1\\uDEC2-\\uDEC7\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF45\\uDF70-\\uDF81\\uDFB0-\\uDFC4\\uDFE0-\\uDFF6]|\\uD804[\\uDC03-\\uDC37\\uDC71\\uDC72\\uDC75\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD44\\uDD47\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE3F\\uDE40\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61\\uDF80-\\uDF89\\uDF8B\\uDF8E\\uDF90-\\uDFB5\\uDFB7\\uDFD1\\uDFD3]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC5F-\\uDC61\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDEB8\\uDF00-\\uDF1A\\uDF40-\\uDF46]|\\uD806[\\uDC00-\\uDC2B\\uDCA0-\\uDCDF\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD2F\\uDD3F\\uDD41\\uDDA0-\\uDDA7\\uDDAA-\\uDDD0\\uDDE1\\uDDE3\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE89\\uDE9D\\uDEB0-\\uDEF8\\uDFC0-\\uDFE0]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD89\\uDD98\\uDDB0-\\uDDDB\\uDEE0-\\uDEF2\\uDF02\\uDF04-\\uDF10\\uDF12-\\uDF33\\uDFB0]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|\\uD80B[\\uDF90-\\uDFF0]|[\\uD80C\\uD80E\\uD80F\\uD81C-\\uD822\\uD840-\\uD868\\uD86A-\\uD86D\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883\\uD885-\\uD88C][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2F\\uDC41-\\uDC46\\uDC60-\\uDFFF]|\\uD810[\\uDC00-\\uDFFA]|\\uD811[\\uDC00-\\uDE46]|\\uD818[\\uDD00-\\uDD1D]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE70-\\uDEBE\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDD40-\\uDD6C\\uDE40-\\uDE7F\\uDEA0-\\uDEB8\\uDEBB-\\uDED3\\uDF00-\\uDF4A\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1\\uDFE3\\uDFF2-\\uDFF6]|\\uD823[\\uDC00-\\uDCD5\\uDCFF-\\uDD1E\\uDD80-\\uDDF2]|\\uD82B[\\uDFF0-\\uDFF3\\uDFF5-\\uDFFB\\uDFFD\\uDFFE]|\\uD82C[\\uDC00-\\uDD22\\uDD32\\uDD50-\\uDD52\\uDD55\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD837[\\uDF00-\\uDF1E\\uDF25-\\uDF2A]|\\uD838[\\uDC30-\\uDC6D\\uDD00-\\uDD2C\\uDD37-\\uDD3D\\uDD4E\\uDE90-\\uDEAD\\uDEC0-\\uDEEB]|\\uD839[\\uDCD0-\\uDCEB\\uDDD0-\\uDDED\\uDDF0\\uDEC0-\\uDEDE\\uDEE0-\\uDEE2\\uDEE4\\uDEE5\\uDEE7-\\uDEED\\uDEF0-\\uDEF4\\uDEFE\\uDEFF\\uDFE0-\\uDFE6\\uDFE8-\\uDFEB\\uDFED\\uDFEE\\uDFF0-\\uDFFE]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43\\uDD4B]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDEDF\\uDF00-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEAD\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0\\uDFF0-\\uDFFF]|\\uD87B[\\uDC00-\\uDE5D]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A\\uDF50-\\uDFFF]|\\uD88D[\\uDC00-\\uDC79]))(?:(?:[\\$0-9A-Z_a-z\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u07FD\\u0800-\\u082D\\u0840-\\u085B\\u0860-\\u086A\\u0870-\\u0887\\u0889-\\u088F\\u0897-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u09FC\\u09FE\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9-\\u0AFF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B55-\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3C-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C5C\\u0C5D\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDC-\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1-\\u0CF3\\u0D00-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D81-\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECE\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u1715\\u171F-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u180F-\\u1819\\u1820-\\u1878\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1ABF-\\u1ADD\\u1AE0-\\u1AEB\\u1B00-\\u1B4C\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C8A\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CD0-\\u1CD2\\u1CD4-\\u1CFA\\u1D00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7DC\\uA7F1-\\uA827\\uA82C\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF65-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDD70-\\uDD7A\\uDD7C-\\uDD8A\\uDD8C-\\uDD92\\uDD94\\uDD95\\uDD97-\\uDDA1\\uDDA3-\\uDDB1\\uDDB3-\\uDDB9\\uDDBB\\uDDBC\\uDDC0-\\uDDF3\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67\\uDF80-\\uDF85\\uDF87-\\uDFB0\\uDFB2-\\uDFBA]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD40-\\uDD59\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD27\\uDD30-\\uDD39\\uDD40-\\uDD65\\uDD69-\\uDD6D\\uDD6F-\\uDD85\\uDE80-\\uDEA9\\uDEAB\\uDEAC\\uDEB0\\uDEB1\\uDEC2-\\uDEC7\\uDEFA-\\uDF1C\\uDF27\\uDF30-\\uDF50\\uDF70-\\uDF85\\uDFB0-\\uDFC4\\uDFE0-\\uDFF6]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC75\\uDC7F-\\uDCBA\\uDCC2\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD44-\\uDD47\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDC9-\\uDDCC\\uDDCE-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E-\\uDE41\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3B-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74\\uDF80-\\uDF89\\uDF8B\\uDF8E\\uDF90-\\uDFB5\\uDFB7-\\uDFC0\\uDFC2\\uDFC5\\uDFC7-\\uDFCA\\uDFCC-\\uDFD3\\uDFE1\\uDFE2]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC5E-\\uDC61\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB8\\uDEC0-\\uDEC9\\uDED0-\\uDEE3\\uDF00-\\uDF1A\\uDF1D-\\uDF2B\\uDF30-\\uDF39\\uDF40-\\uDF46]|\\uD806[\\uDC00-\\uDC3A\\uDCA0-\\uDCE9\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD35\\uDD37\\uDD38\\uDD3B-\\uDD43\\uDD50-\\uDD59\\uDDA0-\\uDDA7\\uDDAA-\\uDDD7\\uDDDA-\\uDDE1\\uDDE3\\uDDE4\\uDE00-\\uDE3E\\uDE47\\uDE50-\\uDE99\\uDE9D\\uDEB0-\\uDEF8\\uDF60-\\uDF67\\uDFC0-\\uDFE0\\uDFF0-\\uDFF9]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD47\\uDD50-\\uDD59\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD8E\\uDD90\\uDD91\\uDD93-\\uDD98\\uDDA0-\\uDDA9\\uDDB0-\\uDDDB\\uDDE0-\\uDDE9\\uDEE0-\\uDEF6\\uDF00-\\uDF10\\uDF12-\\uDF3A\\uDF3E-\\uDF42\\uDF50-\\uDF5A\\uDFB0]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|\\uD80B[\\uDF90-\\uDFF0]|[\\uD80C\\uD80E\\uD80F\\uD81C-\\uD822\\uD840-\\uD868\\uD86A-\\uD86D\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883\\uD885-\\uD88C][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2F\\uDC40-\\uDC55\\uDC60-\\uDFFF]|\\uD810[\\uDC00-\\uDFFA]|\\uD811[\\uDC00-\\uDE46]|\\uD818[\\uDD00-\\uDD39]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDE70-\\uDEBE\\uDEC0-\\uDEC9\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDD40-\\uDD6C\\uDD70-\\uDD79\\uDE40-\\uDE7F\\uDEA0-\\uDEB8\\uDEBB-\\uDED3\\uDF00-\\uDF4A\\uDF4F-\\uDF87\\uDF8F-\\uDF9F\\uDFE0\\uDFE1\\uDFE3\\uDFE4\\uDFF0-\\uDFF6]|\\uD823[\\uDC00-\\uDCD5\\uDCFF-\\uDD1E\\uDD80-\\uDDF2]|\\uD82B[\\uDFF0-\\uDFF3\\uDFF5-\\uDFFB\\uDFFD\\uDFFE]|\\uD82C[\\uDC00-\\uDD22\\uDD32\\uDD50-\\uDD52\\uDD55\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD833[\\uDCF0-\\uDCF9\\uDF00-\\uDF2D\\uDF30-\\uDF46]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD837[\\uDF00-\\uDF1E\\uDF25-\\uDF2A]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDC30-\\uDC6D\\uDC8F\\uDD00-\\uDD2C\\uDD30-\\uDD3D\\uDD40-\\uDD49\\uDD4E\\uDE90-\\uDEAE\\uDEC0-\\uDEF9]|\\uD839[\\uDCD0-\\uDCF9\\uDDD0-\\uDDFA\\uDEC0-\\uDEDE\\uDEE0-\\uDEF5\\uDEFE\\uDEFF\\uDFE0-\\uDFE6\\uDFE8-\\uDFEB\\uDFED\\uDFEE\\uDFF0-\\uDFFE]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4B\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD83E[\\uDFF0-\\uDFF9]|\\uD869[\\uDC00-\\uDEDF\\uDF00-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEAD\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0\\uDFF0-\\uDFFF]|\\uD87B[\\uDC00-\\uDE5D]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A\\uDF50-\\uDFFF]|\\uD88D[\\uDC00-\\uDC79]|\\uDB40[\\uDD00-\\uDDEF])|\\\\u[0-9A-Fa-f]{4}|\\\\u\\{[0-9A-Fa-f]+\\})+", "y");
  StringLiteral = new RegExp("(['\"])(?:(?!\\1)[^\\\\\\n\\r]|\\\\(?:\\r\\n|[^]))*(\\1)?", "y");
  NumericLiteral = new RegExp("(?:0[xX][\\da-fA-F](?:_?[\\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\\d)*n|(?:(?:0(?!\\d)|0\\d*[89]\\d*|[1-9](?:_?\\d)*)(?:\\.(?:\\d(?:_?\\d)*)?)?|\\.\\d(?:_?\\d)*)(?:[eE][+-]?\\d(?:_?\\d)*)?|0[0-7]+", "y");
  Template = new RegExp("[`}](?:[^`\\\\$]|\\\\[^]|\\$(?!\\{))*(`|\\$\\{)?", "y");
  WhiteSpace = new RegExp("[\\t\\x0B\\f \\xA0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000\\uFEFF]+", "y");
  LineTerminatorSequence = new RegExp("\\r?\\n|[\\r\\u2028\\u2029]", "y");
  MultiLineComment = new RegExp("\\/\\*(?:[^*]|\\*(?!\\/))*(\\*\\/)?", "y");
  SingleLineComment = new RegExp("\\/\\/.*", "y");
  JSXPunctuator = new RegExp("[<>.:={}]|\\/(?![\\/*])", "y");
  JSXIdentifier = new RegExp("(?:[\\$A-Z_a-z\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u0870-\\u0887\\u0889-\\u088F\\u08A0-\\u08C9\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C5C\\u0C5D\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDC-\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D04-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u1711\\u171F-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1878\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4C\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C8A\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7DC\\uA7F1-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDD70-\\uDD7A\\uDD7C-\\uDD8A\\uDD8C-\\uDD92\\uDD94\\uDD95\\uDD97-\\uDDA1\\uDDA3-\\uDDB1\\uDDB3-\\uDDB9\\uDDBB\\uDDBC\\uDDC0-\\uDDF3\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67\\uDF80-\\uDF85\\uDF87-\\uDFB0\\uDFB2-\\uDFBA]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD40-\\uDD59\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD23\\uDD4A-\\uDD65\\uDD6F-\\uDD85\\uDE80-\\uDEA9\\uDEB0\\uDEB1\\uDEC2-\\uDEC7\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF45\\uDF70-\\uDF81\\uDFB0-\\uDFC4\\uDFE0-\\uDFF6]|\\uD804[\\uDC03-\\uDC37\\uDC71\\uDC72\\uDC75\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD44\\uDD47\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE3F\\uDE40\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61\\uDF80-\\uDF89\\uDF8B\\uDF8E\\uDF90-\\uDFB5\\uDFB7\\uDFD1\\uDFD3]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC5F-\\uDC61\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDEB8\\uDF00-\\uDF1A\\uDF40-\\uDF46]|\\uD806[\\uDC00-\\uDC2B\\uDCA0-\\uDCDF\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD2F\\uDD3F\\uDD41\\uDDA0-\\uDDA7\\uDDAA-\\uDDD0\\uDDE1\\uDDE3\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE89\\uDE9D\\uDEB0-\\uDEF8\\uDFC0-\\uDFE0]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD89\\uDD98\\uDDB0-\\uDDDB\\uDEE0-\\uDEF2\\uDF02\\uDF04-\\uDF10\\uDF12-\\uDF33\\uDFB0]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|\\uD80B[\\uDF90-\\uDFF0]|[\\uD80C\\uD80E\\uD80F\\uD81C-\\uD822\\uD840-\\uD868\\uD86A-\\uD86D\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883\\uD885-\\uD88C][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2F\\uDC41-\\uDC46\\uDC60-\\uDFFF]|\\uD810[\\uDC00-\\uDFFA]|\\uD811[\\uDC00-\\uDE46]|\\uD818[\\uDD00-\\uDD1D]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE70-\\uDEBE\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDD40-\\uDD6C\\uDE40-\\uDE7F\\uDEA0-\\uDEB8\\uDEBB-\\uDED3\\uDF00-\\uDF4A\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1\\uDFE3\\uDFF2-\\uDFF6]|\\uD823[\\uDC00-\\uDCD5\\uDCFF-\\uDD1E\\uDD80-\\uDDF2]|\\uD82B[\\uDFF0-\\uDFF3\\uDFF5-\\uDFFB\\uDFFD\\uDFFE]|\\uD82C[\\uDC00-\\uDD22\\uDD32\\uDD50-\\uDD52\\uDD55\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD837[\\uDF00-\\uDF1E\\uDF25-\\uDF2A]|\\uD838[\\uDC30-\\uDC6D\\uDD00-\\uDD2C\\uDD37-\\uDD3D\\uDD4E\\uDE90-\\uDEAD\\uDEC0-\\uDEEB]|\\uD839[\\uDCD0-\\uDCEB\\uDDD0-\\uDDED\\uDDF0\\uDEC0-\\uDEDE\\uDEE0-\\uDEE2\\uDEE4\\uDEE5\\uDEE7-\\uDEED\\uDEF0-\\uDEF4\\uDEFE\\uDEFF\\uDFE0-\\uDFE6\\uDFE8-\\uDFEB\\uDFED\\uDFEE\\uDFF0-\\uDFFE]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43\\uDD4B]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDEDF\\uDF00-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEAD\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0\\uDFF0-\\uDFFF]|\\uD87B[\\uDC00-\\uDE5D]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A\\uDF50-\\uDFFF]|\\uD88D[\\uDC00-\\uDC79])(?:[\\$\\x2D0-9A-Z_a-z\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u07FD\\u0800-\\u082D\\u0840-\\u085B\\u0860-\\u086A\\u0870-\\u0887\\u0889-\\u088F\\u0897-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u09FC\\u09FE\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9-\\u0AFF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B55-\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3C-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C5C\\u0C5D\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDC-\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1-\\u0CF3\\u0D00-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D81-\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECE\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u1715\\u171F-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u180F-\\u1819\\u1820-\\u1878\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1ABF-\\u1ADD\\u1AE0-\\u1AEB\\u1B00-\\u1B4C\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C8A\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CD0-\\u1CD2\\u1CD4-\\u1CFA\\u1D00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7DC\\uA7F1-\\uA827\\uA82C\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF65-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDD70-\\uDD7A\\uDD7C-\\uDD8A\\uDD8C-\\uDD92\\uDD94\\uDD95\\uDD97-\\uDDA1\\uDDA3-\\uDDB1\\uDDB3-\\uDDB9\\uDDBB\\uDDBC\\uDDC0-\\uDDF3\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67\\uDF80-\\uDF85\\uDF87-\\uDFB0\\uDFB2-\\uDFBA]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD40-\\uDD59\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD27\\uDD30-\\uDD39\\uDD40-\\uDD65\\uDD69-\\uDD6D\\uDD6F-\\uDD85\\uDE80-\\uDEA9\\uDEAB\\uDEAC\\uDEB0\\uDEB1\\uDEC2-\\uDEC7\\uDEFA-\\uDF1C\\uDF27\\uDF30-\\uDF50\\uDF70-\\uDF85\\uDFB0-\\uDFC4\\uDFE0-\\uDFF6]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC75\\uDC7F-\\uDCBA\\uDCC2\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD44-\\uDD47\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDC9-\\uDDCC\\uDDCE-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E-\\uDE41\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3B-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74\\uDF80-\\uDF89\\uDF8B\\uDF8E\\uDF90-\\uDFB5\\uDFB7-\\uDFC0\\uDFC2\\uDFC5\\uDFC7-\\uDFCA\\uDFCC-\\uDFD3\\uDFE1\\uDFE2]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC5E-\\uDC61\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB8\\uDEC0-\\uDEC9\\uDED0-\\uDEE3\\uDF00-\\uDF1A\\uDF1D-\\uDF2B\\uDF30-\\uDF39\\uDF40-\\uDF46]|\\uD806[\\uDC00-\\uDC3A\\uDCA0-\\uDCE9\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD35\\uDD37\\uDD38\\uDD3B-\\uDD43\\uDD50-\\uDD59\\uDDA0-\\uDDA7\\uDDAA-\\uDDD7\\uDDDA-\\uDDE1\\uDDE3\\uDDE4\\uDE00-\\uDE3E\\uDE47\\uDE50-\\uDE99\\uDE9D\\uDEB0-\\uDEF8\\uDF60-\\uDF67\\uDFC0-\\uDFE0\\uDFF0-\\uDFF9]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD47\\uDD50-\\uDD59\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD8E\\uDD90\\uDD91\\uDD93-\\uDD98\\uDDA0-\\uDDA9\\uDDB0-\\uDDDB\\uDDE0-\\uDDE9\\uDEE0-\\uDEF6\\uDF00-\\uDF10\\uDF12-\\uDF3A\\uDF3E-\\uDF42\\uDF50-\\uDF5A\\uDFB0]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|\\uD80B[\\uDF90-\\uDFF0]|[\\uD80C\\uD80E\\uD80F\\uD81C-\\uD822\\uD840-\\uD868\\uD86A-\\uD86D\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883\\uD885-\\uD88C][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2F\\uDC40-\\uDC55\\uDC60-\\uDFFF]|\\uD810[\\uDC00-\\uDFFA]|\\uD811[\\uDC00-\\uDE46]|\\uD818[\\uDD00-\\uDD39]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDE70-\\uDEBE\\uDEC0-\\uDEC9\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDD40-\\uDD6C\\uDD70-\\uDD79\\uDE40-\\uDE7F\\uDEA0-\\uDEB8\\uDEBB-\\uDED3\\uDF00-\\uDF4A\\uDF4F-\\uDF87\\uDF8F-\\uDF9F\\uDFE0\\uDFE1\\uDFE3\\uDFE4\\uDFF0-\\uDFF6]|\\uD823[\\uDC00-\\uDCD5\\uDCFF-\\uDD1E\\uDD80-\\uDDF2]|\\uD82B[\\uDFF0-\\uDFF3\\uDFF5-\\uDFFB\\uDFFD\\uDFFE]|\\uD82C[\\uDC00-\\uDD22\\uDD32\\uDD50-\\uDD52\\uDD55\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD833[\\uDCF0-\\uDCF9\\uDF00-\\uDF2D\\uDF30-\\uDF46]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD837[\\uDF00-\\uDF1E\\uDF25-\\uDF2A]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDC30-\\uDC6D\\uDC8F\\uDD00-\\uDD2C\\uDD30-\\uDD3D\\uDD40-\\uDD49\\uDD4E\\uDE90-\\uDEAE\\uDEC0-\\uDEF9]|\\uD839[\\uDCD0-\\uDCF9\\uDDD0-\\uDDFA\\uDEC0-\\uDEDE\\uDEE0-\\uDEF5\\uDEFE\\uDEFF\\uDFE0-\\uDFE6\\uDFE8-\\uDFEB\\uDFED\\uDFEE\\uDFF0-\\uDFFE]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4B\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD83E[\\uDFF0-\\uDFF9]|\\uD869[\\uDC00-\\uDEDF\\uDF00-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEAD\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0\\uDFF0-\\uDFFF]|\\uD87B[\\uDC00-\\uDE5D]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A\\uDF50-\\uDFFF]|\\uD88D[\\uDC00-\\uDC79]|\\uDB40[\\uDD00-\\uDDEF])*", "y");
  JSXString = new RegExp("(['\"])(?:(?!\\1)[^])*(\\1)?", "y");
  JSXText = new RegExp("[^<>{}]+", "y");
  TokensPrecedingExpression = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/;
  TokensNotPrecedingObjectLiteral = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/;
  KeywordsWithExpressionAfter = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/;
  KeywordsWithNoLineTerminatorAfter = /^(?:return|throw|yield)$/;
  Newline = RegExp(LineTerminatorSequence.source);
  jsTokens_1 = function jsTokens_1(input) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$jsx = _ref.jsx,
      jsx = _ref$jsx === void 0 ? false : _ref$jsx;
    return /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      var braces, firstCodePoint, isExpression, lastIndex, lastSignificantToken, length, match, mode, nextLastIndex, nextLastSignificantToken, parenNesting, postfixIncDec, punctuator, stack, _t, _t2, _t3, _t4, _t5;
      return _regeneratorRuntime.wrap(function (_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            length = input.length;
            lastIndex = 0;
            lastSignificantToken = "";
            stack = [{
              tag: "JS"
            }];
            braces = [];
            parenNesting = 0;
            postfixIncDec = false;
          case 1:
            if (!(lastIndex < length)) {
              _context.next = 65;
              break;
            }
            mode = stack[stack.length - 1];
            _t = mode.tag;
            _context.next = _t === "JS" ? 2 : _t === "JSNonExpressionParen" ? 2 : _t === "InterpolationInTemplate" ? 2 : _t === "InterpolationInJSX" ? 2 : _t === "JSXTag" ? 36 : _t === "JSXTagEnd" ? 36 : _t === "JSXChildren" ? 48 : 55;
            break;
          case 2:
            if (!(input[lastIndex] === "/" && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken)))) {
              _context.next = 4;
              break;
            }
            RegularExpressionLiteral.lastIndex = lastIndex;
            if (!(match = RegularExpressionLiteral.exec(input))) {
              _context.next = 4;
              break;
            }
            lastIndex = RegularExpressionLiteral.lastIndex;
            lastSignificantToken = match[0];
            postfixIncDec = true;
            _context.next = 3;
            return {
              type: "RegularExpressionLiteral",
              value: match[0],
              closed: match[1] !== void 0 && match[1] !== "\\"
            };
          case 3:
            return _context.abrupt("continue", 1);
          case 4:
            Punctuator.lastIndex = lastIndex;
            if (!(match = Punctuator.exec(input))) {
              _context.next = 25;
              break;
            }
            punctuator = match[0];
            nextLastIndex = Punctuator.lastIndex;
            nextLastSignificantToken = punctuator;
            _t2 = punctuator;
            _context.next = _t2 === "(" ? 5 : _t2 === ")" ? 6 : _t2 === "{" ? 7 : _t2 === "}" ? 8 : _t2 === "]" ? 17 : _t2 === "++" ? 18 : _t2 === "--" ? 18 : _t2 === "<" ? 19 : 22;
            break;
          case 5:
            if (lastSignificantToken === "?NonExpressionParenKeyword") {
              stack.push({
                tag: "JSNonExpressionParen",
                nesting: parenNesting
              });
            }
            parenNesting++;
            postfixIncDec = false;
            return _context.abrupt("continue", 23);
          case 6:
            parenNesting--;
            postfixIncDec = true;
            if (mode.tag === "JSNonExpressionParen" && parenNesting === mode.nesting) {
              stack.pop();
              nextLastSignificantToken = "?NonExpressionParenEnd";
              postfixIncDec = false;
            }
            return _context.abrupt("continue", 23);
          case 7:
            Punctuator.lastIndex = 0;
            isExpression = !TokensNotPrecedingObjectLiteral.test(lastSignificantToken) && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken));
            braces.push(isExpression);
            postfixIncDec = false;
            return _context.abrupt("continue", 23);
          case 8:
            _t3 = mode.tag;
            _context.next = _t3 === "InterpolationInTemplate" ? 9 : _t3 === "InterpolationInJSX" ? 14 : 16;
            break;
          case 9:
            if (!(braces.length === mode.nesting)) {
              _context.next = 13;
              break;
            }
            Template.lastIndex = lastIndex;
            match = Template.exec(input);
            lastIndex = Template.lastIndex;
            lastSignificantToken = match[0];
            if (!(match[1] === "${")) {
              _context.next = 11;
              break;
            }
            lastSignificantToken = "?InterpolationInTemplate";
            postfixIncDec = false;
            _context.next = 10;
            return {
              type: "TemplateMiddle",
              value: match[0]
            };
          case 10:
            _context.next = 12;
            break;
          case 11:
            stack.pop();
            postfixIncDec = true;
            _context.next = 12;
            return {
              type: "TemplateTail",
              value: match[0],
              closed: match[1] === "`"
            };
          case 12:
            return _context.abrupt("continue", 1);
          case 13:
            return _context.abrupt("continue", 16);
          case 14:
            if (!(braces.length === mode.nesting)) {
              _context.next = 16;
              break;
            }
            stack.pop();
            lastIndex += 1;
            lastSignificantToken = "}";
            _context.next = 15;
            return {
              type: "JSXPunctuator",
              value: "}"
            };
          case 15:
            return _context.abrupt("continue", 1);
          case 16:
            postfixIncDec = braces.pop();
            nextLastSignificantToken = postfixIncDec ? "?ExpressionBraceEnd" : "}";
            return _context.abrupt("continue", 23);
          case 17:
            postfixIncDec = true;
            return _context.abrupt("continue", 23);
          case 18:
            nextLastSignificantToken = postfixIncDec ? "?PostfixIncDec" : "?UnaryIncDec";
            return _context.abrupt("continue", 23);
          case 19:
            if (!(jsx && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken)))) {
              _context.next = 21;
              break;
            }
            stack.push({
              tag: "JSXTag"
            });
            lastIndex += 1;
            lastSignificantToken = "<";
            _context.next = 20;
            return {
              type: "JSXPunctuator",
              value: punctuator
            };
          case 20:
            return _context.abrupt("continue", 1);
          case 21:
            postfixIncDec = false;
            return _context.abrupt("continue", 23);
          case 22:
            postfixIncDec = false;
          case 23:
            lastIndex = nextLastIndex;
            lastSignificantToken = nextLastSignificantToken;
            _context.next = 24;
            return {
              type: "Punctuator",
              value: punctuator
            };
          case 24:
            return _context.abrupt("continue", 1);
          case 25:
            Identifier.lastIndex = lastIndex;
            if (!(match = Identifier.exec(input))) {
              _context.next = 27;
              break;
            }
            lastIndex = Identifier.lastIndex;
            nextLastSignificantToken = match[0];
            switch (match[0]) {
              case "for":
              case "if":
              case "while":
              case "with":
                if (lastSignificantToken !== "." && lastSignificantToken !== "?.") {
                  nextLastSignificantToken = "?NonExpressionParenKeyword";
                }
            }
            lastSignificantToken = nextLastSignificantToken;
            postfixIncDec = !KeywordsWithExpressionAfter.test(match[0]);
            _context.next = 26;
            return {
              type: match[1] === "#" ? "PrivateIdentifier" : "IdentifierName",
              value: match[0]
            };
          case 26:
            return _context.abrupt("continue", 1);
          case 27:
            StringLiteral.lastIndex = lastIndex;
            if (!(match = StringLiteral.exec(input))) {
              _context.next = 29;
              break;
            }
            lastIndex = StringLiteral.lastIndex;
            lastSignificantToken = match[0];
            postfixIncDec = true;
            _context.next = 28;
            return {
              type: "StringLiteral",
              value: match[0],
              closed: match[2] !== void 0
            };
          case 28:
            return _context.abrupt("continue", 1);
          case 29:
            NumericLiteral.lastIndex = lastIndex;
            if (!(match = NumericLiteral.exec(input))) {
              _context.next = 31;
              break;
            }
            lastIndex = NumericLiteral.lastIndex;
            lastSignificantToken = match[0];
            postfixIncDec = true;
            _context.next = 30;
            return {
              type: "NumericLiteral",
              value: match[0]
            };
          case 30:
            return _context.abrupt("continue", 1);
          case 31:
            Template.lastIndex = lastIndex;
            if (!(match = Template.exec(input))) {
              _context.next = 35;
              break;
            }
            lastIndex = Template.lastIndex;
            lastSignificantToken = match[0];
            if (!(match[1] === "${")) {
              _context.next = 33;
              break;
            }
            lastSignificantToken = "?InterpolationInTemplate";
            stack.push({
              tag: "InterpolationInTemplate",
              nesting: braces.length
            });
            postfixIncDec = false;
            _context.next = 32;
            return {
              type: "TemplateHead",
              value: match[0]
            };
          case 32:
            _context.next = 34;
            break;
          case 33:
            postfixIncDec = true;
            _context.next = 34;
            return {
              type: "NoSubstitutionTemplate",
              value: match[0],
              closed: match[1] === "`"
            };
          case 34:
            return _context.abrupt("continue", 1);
          case 35:
            return _context.abrupt("continue", 55);
          case 36:
            JSXPunctuator.lastIndex = lastIndex;
            if (!(match = JSXPunctuator.exec(input))) {
              _context.next = 43;
              break;
            }
            lastIndex = JSXPunctuator.lastIndex;
            nextLastSignificantToken = match[0];
            _t4 = match[0];
            _context.next = _t4 === "<" ? 37 : _t4 === ">" ? 38 : _t4 === "{" ? 39 : _t4 === "/" ? 40 : 41;
            break;
          case 37:
            stack.push({
              tag: "JSXTag"
            });
            return _context.abrupt("continue", 41);
          case 38:
            stack.pop();
            if (lastSignificantToken === "/" || mode.tag === "JSXTagEnd") {
              nextLastSignificantToken = "?JSX";
              postfixIncDec = true;
            } else {
              stack.push({
                tag: "JSXChildren"
              });
            }
            return _context.abrupt("continue", 41);
          case 39:
            stack.push({
              tag: "InterpolationInJSX",
              nesting: braces.length
            });
            nextLastSignificantToken = "?InterpolationInJSX";
            postfixIncDec = false;
            return _context.abrupt("continue", 41);
          case 40:
            if (lastSignificantToken === "<") {
              stack.pop();
              if (stack[stack.length - 1].tag === "JSXChildren") {
                stack.pop();
              }
              stack.push({
                tag: "JSXTagEnd"
              });
            }
          case 41:
            lastSignificantToken = nextLastSignificantToken;
            _context.next = 42;
            return {
              type: "JSXPunctuator",
              value: match[0]
            };
          case 42:
            return _context.abrupt("continue", 1);
          case 43:
            JSXIdentifier.lastIndex = lastIndex;
            if (!(match = JSXIdentifier.exec(input))) {
              _context.next = 45;
              break;
            }
            lastIndex = JSXIdentifier.lastIndex;
            lastSignificantToken = match[0];
            _context.next = 44;
            return {
              type: "JSXIdentifier",
              value: match[0]
            };
          case 44:
            return _context.abrupt("continue", 1);
          case 45:
            JSXString.lastIndex = lastIndex;
            if (!(match = JSXString.exec(input))) {
              _context.next = 47;
              break;
            }
            lastIndex = JSXString.lastIndex;
            lastSignificantToken = match[0];
            _context.next = 46;
            return {
              type: "JSXString",
              value: match[0],
              closed: match[2] !== void 0
            };
          case 46:
            return _context.abrupt("continue", 1);
          case 47:
            return _context.abrupt("continue", 55);
          case 48:
            JSXText.lastIndex = lastIndex;
            if (!(match = JSXText.exec(input))) {
              _context.next = 50;
              break;
            }
            lastIndex = JSXText.lastIndex;
            lastSignificantToken = match[0];
            _context.next = 49;
            return {
              type: "JSXText",
              value: match[0]
            };
          case 49:
            return _context.abrupt("continue", 1);
          case 50:
            _t5 = input[lastIndex];
            _context.next = _t5 === "<" ? 51 : _t5 === "{" ? 53 : 55;
            break;
          case 51:
            stack.push({
              tag: "JSXTag"
            });
            lastIndex++;
            lastSignificantToken = "<";
            _context.next = 52;
            return {
              type: "JSXPunctuator",
              value: "<"
            };
          case 52:
            return _context.abrupt("continue", 1);
          case 53:
            stack.push({
              tag: "InterpolationInJSX",
              nesting: braces.length
            });
            lastIndex++;
            lastSignificantToken = "?InterpolationInJSX";
            postfixIncDec = false;
            _context.next = 54;
            return {
              type: "JSXPunctuator",
              value: "{"
            };
          case 54:
            return _context.abrupt("continue", 1);
          case 55:
            WhiteSpace.lastIndex = lastIndex;
            if (!(match = WhiteSpace.exec(input))) {
              _context.next = 57;
              break;
            }
            lastIndex = WhiteSpace.lastIndex;
            _context.next = 56;
            return {
              type: "WhiteSpace",
              value: match[0]
            };
          case 56:
            return _context.abrupt("continue", 1);
          case 57:
            LineTerminatorSequence.lastIndex = lastIndex;
            if (!(match = LineTerminatorSequence.exec(input))) {
              _context.next = 59;
              break;
            }
            lastIndex = LineTerminatorSequence.lastIndex;
            postfixIncDec = false;
            if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {
              lastSignificantToken = "?NoLineTerminatorHere";
            }
            _context.next = 58;
            return {
              type: "LineTerminatorSequence",
              value: match[0]
            };
          case 58:
            return _context.abrupt("continue", 1);
          case 59:
            MultiLineComment.lastIndex = lastIndex;
            if (!(match = MultiLineComment.exec(input))) {
              _context.next = 61;
              break;
            }
            lastIndex = MultiLineComment.lastIndex;
            if (Newline.test(match[0])) {
              postfixIncDec = false;
              if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {
                lastSignificantToken = "?NoLineTerminatorHere";
              }
            }
            _context.next = 60;
            return {
              type: "MultiLineComment",
              value: match[0],
              closed: match[1] !== void 0
            };
          case 60:
            return _context.abrupt("continue", 1);
          case 61:
            SingleLineComment.lastIndex = lastIndex;
            if (!(match = SingleLineComment.exec(input))) {
              _context.next = 63;
              break;
            }
            lastIndex = SingleLineComment.lastIndex;
            postfixIncDec = false;
            _context.next = 62;
            return {
              type: "SingleLineComment",
              value: match[0]
            };
          case 62:
            return _context.abrupt("continue", 1);
          case 63:
            firstCodePoint = String.fromCodePoint(input.codePointAt(lastIndex));
            lastIndex += firstCodePoint.length;
            lastSignificantToken = firstCodePoint;
            postfixIncDec = false;
            _context.next = 64;
            return {
              type: mode.tag.startsWith("JSX") ? "JSXInvalid" : "Invalid",
              value: firstCodePoint
            };
          case 64:
            _context.next = 1;
            break;
          case 65:
            return _context.abrupt("return", void 0);
          case 66:
          case "end":
            return _context.stop();
        }
      }, _callee);
    })();
  };
  return jsTokens_1;
}
requireJsTokens();

// src/index.ts
var f = {
    reset: [0, 0],
    bold: [1, 22, "\x1B[22m\x1B[1m"],
    dim: [2, 22, "\x1B[22m\x1B[2m"],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29],
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    gray: [90, 39],
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    blackBright: [90, 39],
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39],
    bgBlackBright: [100, 49],
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  },
  h = Object.entries(f);
function a(n) {
  return String(n);
}
a.open = "";
a.close = "";
function C() {
  var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var e = typeof process != "undefined" ? process : void 0,
    i = (e == null ? void 0 : e.env) || {},
    g = (e == null ? void 0 : e.argv) || [];
  return !("NO_COLOR" in i || g.includes("--no-color")) && ("FORCE_COLOR" in i || g.includes("--color") || (e == null ? void 0 : e.platform) === "win32" || n && i.TERM !== "dumb" || "CI" in i) || typeof window != "undefined" && !!window.chrome;
}
function p() {
  var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var e = C(n),
    i = function i(r, t, c, o) {
      var l = "",
        s = 0;
      do l += r.substring(s, o) + c, s = o + t.length, o = r.indexOf(t, s); while (~o);
      return l + r.substring(s);
    },
    g = function g(r, t) {
      var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : r;
      var o = function o(l) {
        var s = String(l),
          b = s.indexOf(t, r.length);
        return ~b ? r + i(s, t, c, b) + t : r + s + t;
      };
      return o.open = r, o.close = t, o;
    },
    u = {
      isColorSupported: e
    },
    d = function d(r) {
      return "\x1B[".concat(r, "m");
    };
  for (var _i7 = 0, _h = h; _i7 < _h.length; _i7++) {
    var _h$_i = _slicedToArray(_h[_i7], 2),
      r = _h$_i[0],
      t = _h$_i[1];
    u[r] = e ? g(d(t[0]), d(t[1]), t[2]) : a;
  }
  return u;
}
p();
var lineSplitRE = /\r?\n/;
function positionToOffset(source, lineNumber, columnNumber) {
  var lines = source.split(lineSplitRE);
  var nl = /\r\n/.test(source) ? 2 : 1;
  var start = 0;
  if (lineNumber > lines.length) {
    return source.length;
  }
  for (var _i8 = 0; _i8 < lineNumber - 1; _i8++) {
    start += lines[_i8].length + nl;
  }
  return start + columnNumber;
}
function offsetToLineNumber(source, offset) {
  if (offset > source.length) {
    throw new Error("offset is longer than source length! offset ".concat(offset, " > length ").concat(source.length));
  }
  var lines = source.split(lineSplitRE);
  var nl = /\r\n/.test(source) ? 2 : 1;
  var counted = 0;
  var line = 0;
  for (; line < lines.length; line++) {
    var lineLength = lines[line].length + nl;
    if (counted + lineLength >= offset) {
      break;
    }
    counted += lineLength;
  }
  return line + 1;
}
function saveInlineSnapshots(_x, _x2) {
  return _saveInlineSnapshots.apply(this, arguments);
}
function _saveInlineSnapshots() {
  _saveInlineSnapshots = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee9(environment, snapshots) {
    var MagicString, files;
    return _regeneratorRuntime.wrap(function (_context9) {
      while (1) switch (_context9.prev = _context9.next) {
        case 0:
          _context9.next = 1;
          return import('./dep-87922651.js');
        case 1:
          MagicString = _context9.sent.default;
          files = new Set(snapshots.map(function (i) {
            return i.file;
          }));
          _context9.next = 2;
          return Promise.all(Array.from(files).map(/*#__PURE__*/function () {
            var _ref4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee8(file) {
              var snaps, code, s, _iterator3, _step3, snap, index, transformed;
              return _regeneratorRuntime.wrap(function (_context8) {
                while (1) switch (_context8.prev = _context8.next) {
                  case 0:
                    snaps = snapshots.filter(function (i) {
                      return i.file === file;
                    });
                    _context8.next = 1;
                    return environment.readSnapshotFile(file);
                  case 1:
                    code = _context8.sent;
                    s = new MagicString(code);
                    _iterator3 = _createForOfIteratorHelper$1(snaps);
                    try {
                      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                        snap = _step3.value;
                        index = positionToOffset(code, snap.line, snap.column);
                        replaceInlineSnap(code, s, index, snap.snapshot);
                      }
                    } catch (err) {
                      _iterator3.e(err);
                    } finally {
                      _iterator3.f();
                    }
                    transformed = s.toString();
                    if (!(transformed !== code)) {
                      _context8.next = 2;
                      break;
                    }
                    _context8.next = 2;
                    return environment.saveSnapshotFile(file, transformed);
                  case 2:
                  case "end":
                    return _context8.stop();
                }
              }, _callee8);
            }));
            return function (_x12) {
              return _ref4.apply(this, arguments);
            };
          }()));
        case 2:
        case "end":
          return _context9.stop();
      }
    }, _callee9);
  }));
  return _saveInlineSnapshots.apply(this, arguments);
}
var startObjectRegex = /(?:toMatchInlineSnapshot|toThrowErrorMatchingInlineSnapshot)\s*\(\s*(?:\/\*[\s\S]*\*\/\s*|\/\/.*(?:[\n\r\u2028\u2029]\s*|[\t\v\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]))*\{/;
function replaceObjectSnap(code, s, index, newSnap) {
  var _code = code.slice(index);
  var startMatch = startObjectRegex.exec(_code);
  if (!startMatch) {
    return false;
  }
  _code = _code.slice(startMatch.index);
  var callEnd = getCallLastIndex(_code);
  if (callEnd === null) {
    return false;
  }
  callEnd += index + startMatch.index;
  var shapeStart = index + startMatch.index + startMatch[0].length;
  var shapeEnd = getObjectShapeEndIndex(code, shapeStart);
  var snap = ", ".concat(prepareSnapString(newSnap, code, index));
  if (shapeEnd === callEnd) {
    // toMatchInlineSnapshot({ foo: expect.any(String) })
    s.appendLeft(callEnd, snap);
  } else {
    // toMatchInlineSnapshot({ foo: expect.any(String) }, ``)
    s.overwrite(shapeEnd, callEnd, snap);
  }
  return true;
}
function getObjectShapeEndIndex(code, index) {
  var startBraces = 1;
  var endBraces = 0;
  while (startBraces !== endBraces && index < code.length) {
    var s = code[index++];
    if (s === "{") {
      startBraces++;
    } else if (s === "}") {
      endBraces++;
    }
  }
  return index;
}
function prepareSnapString(snap, source, index) {
  var lineNumber = offsetToLineNumber(source, index);
  var line = source.split(lineSplitRE)[lineNumber - 1];
  var indent = line.match(/^\s*/)[0] || "";
  var indentNext = indent.includes("	") ? "".concat(indent, "\t") : "".concat(indent, "  ");
  var lines = snap.trim().replace(/\\/g, "\\\\").split(/\n/g);
  var isOneline = lines.length <= 1;
  var quote = "`";
  if (isOneline) {
    return "".concat(quote).concat(lines.join("\n").replace(/`/g, "\\`").replace(/\$\{/g, "\\${")).concat(quote);
  }
  return "".concat(quote, "\n").concat(lines.map(function (i) {
    return i ? indentNext + i : "";
  }).join("\n").replace(/`/g, "\\`").replace(/\$\{/g, "\\${"), "\n").concat(indent).concat(quote);
}
var toMatchInlineName = "toMatchInlineSnapshot";
var toThrowErrorMatchingInlineName = "toThrowErrorMatchingInlineSnapshot";
// on webkit, the line number is at the end of the method, not at the start
function getCodeStartingAtIndex(code, index) {
  var indexInline = index - toMatchInlineName.length;
  if (code.slice(indexInline, index) === toMatchInlineName) {
    return {
      code: code.slice(indexInline),
      index: indexInline
    };
  }
  var indexThrowInline = index - toThrowErrorMatchingInlineName.length;
  if (code.slice(index - indexThrowInline, index) === toThrowErrorMatchingInlineName) {
    return {
      code: code.slice(index - indexThrowInline),
      index: index - indexThrowInline
    };
  }
  return {
    code: code.slice(index),
    index: index
  };
}
var startRegex = /(?:toMatchInlineSnapshot|toThrowErrorMatchingInlineSnapshot)\s*\(\s*(?:\/\*[\s\S]*\*\/\s*|\/\/.*(?:[\n\r\u2028\u2029]\s*|[\t\v\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]))*[\w$]*(['"`)])/;
function replaceInlineSnap(code, s, currentIndex, newSnap) {
  var _getCodeStartingAtInd = getCodeStartingAtIndex(code, currentIndex),
    codeStartingAtIndex = _getCodeStartingAtInd.code,
    index = _getCodeStartingAtInd.index;
  var startMatch = startRegex.exec(codeStartingAtIndex);
  var firstKeywordMatch = /toMatchInlineSnapshot|toThrowErrorMatchingInlineSnapshot/.exec(codeStartingAtIndex);
  if (!startMatch || startMatch.index !== (firstKeywordMatch === null || firstKeywordMatch === void 0 ? void 0 : firstKeywordMatch.index)) {
    return replaceObjectSnap(code, s, index, newSnap);
  }
  var quote = startMatch[1];
  var startIndex = index + startMatch.index + startMatch[0].length;
  var snapString = prepareSnapString(newSnap, code, index);
  if (quote === ")") {
    s.appendRight(startIndex - 1, snapString);
    return true;
  }
  var quoteEndRE = new RegExp("(?:^|[^\\\\])".concat(quote));
  var endMatch = quoteEndRE.exec(code.slice(startIndex));
  if (!endMatch) {
    return false;
  }
  var endIndex = startIndex + endMatch.index + endMatch[0].length;
  s.overwrite(startIndex - 1, endIndex, snapString);
  return true;
}
var INDENTATION_REGEX = /^([^\S\n]*)\S/m;
function stripSnapshotIndentation(inlineSnapshot) {
  // Find indentation if exists.
  var match = inlineSnapshot.match(INDENTATION_REGEX);
  if (!match || !match[1]) {
    // No indentation.
    return inlineSnapshot;
  }
  var indentation = match[1];
  var lines = inlineSnapshot.split(/\n/g);
  if (lines.length <= 2) {
    // Must be at least 3 lines.
    return inlineSnapshot;
  }
  if (lines[0].trim() !== "" || lines[lines.length - 1].trim() !== "") {
    // If not blank first and last lines, abort.
    return inlineSnapshot;
  }
  for (var _i9 = 1; _i9 < lines.length - 1; _i9++) {
    if (lines[_i9] !== "") {
      if (lines[_i9].indexOf(indentation) !== 0) {
        // All lines except first and last should either be blank or have the same
        // indent as the first line (or more). If this isn't the case we don't
        // want to touch the snapshot at all.
        return inlineSnapshot;
      }
      lines[_i9] = lines[_i9].substring(indentation.length);
    }
  }
  // Last line is a special case because it won't have the same indent as others
  // but may still have been given some indent to line up.
  lines[lines.length - 1] = "";
  // Return inline snapshot, now at indent 0.
  inlineSnapshot = lines.join("\n");
  return inlineSnapshot;
}
function saveRawSnapshots(_x3, _x4) {
  return _saveRawSnapshots.apply(this, arguments);
}
function _saveRawSnapshots() {
  _saveRawSnapshots = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee1(environment, snapshots) {
    return _regeneratorRuntime.wrap(function (_context1) {
      while (1) switch (_context1.prev = _context1.next) {
        case 0:
          _context1.next = 1;
          return Promise.all(snapshots.map(/*#__PURE__*/function () {
            var _ref5 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee0(snap) {
              return _regeneratorRuntime.wrap(function (_context0) {
                while (1) switch (_context0.prev = _context0.next) {
                  case 0:
                    if (snap.readonly) {
                      _context0.next = 1;
                      break;
                    }
                    _context0.next = 1;
                    return environment.saveSnapshotFile(snap.file, snap.snapshot);
                  case 1:
                  case "end":
                    return _context0.stop();
                }
              }, _callee0);
            }));
            return function (_x13) {
              return _ref5.apply(this, arguments);
            };
          }()));
        case 1:
        case "end":
          return _context1.stop();
      }
    }, _callee1);
  }));
  return _saveRawSnapshots.apply(this, arguments);
}
var naturalCompare$1 = {
  exports: {}
};
var hasRequiredNaturalCompare;
function requireNaturalCompare() {
  if (hasRequiredNaturalCompare) return naturalCompare$1.exports;
  hasRequiredNaturalCompare = 1;
  /*
   * @version    1.4.0
   * @date       2015-10-26
   * @stability  3 - Stable
   * @author     Lauri Rooden (https://github.com/litejs/natural-compare-lite)
   * @license    MIT License
   */

  var naturalCompare = function naturalCompare(a, b) {
    var i,
      codeA,
      codeB = 1,
      posA = 0,
      posB = 0,
      alphabet = String.alphabet;
    function getCode(str, pos, code) {
      if (code) {
        for (i = pos; code = getCode(str, i), code < 76 && code > 65;) ++i;
        return +str.slice(pos - 1, i);
      }
      code = alphabet && alphabet.indexOf(str.charAt(pos));
      return code > -1 ? code + 76 : (code = str.charCodeAt(pos) || 0, code < 45 || code > 127) ? code : code < 46 ? 65 // -
      : code < 48 ? code - 1 : code < 58 ? code + 18 // 0-9
      : code < 65 ? code - 11 : code < 91 ? code + 11 // A-Z
      : code < 97 ? code - 37 : code < 123 ? code + 5 // a-z
      : code - 63;
    }
    if ((a += "") != (b += "")) for (; codeB;) {
      codeA = getCode(a, posA++);
      codeB = getCode(b, posB++);
      if (codeA < 76 && codeB < 76 && codeA > 66 && codeB > 66) {
        codeA = getCode(a, posA, posA);
        codeB = getCode(b, posB, posA = i);
        posB = i;
      }
      if (codeA != codeB) return codeA < codeB ? -1 : 1;
    }
    return 0;
  };
  try {
    naturalCompare$1.exports = naturalCompare;
  } catch (e) {
    String.naturalCompare = naturalCompare;
  }
  return naturalCompare$1.exports;
}
var naturalCompareExports = requireNaturalCompare();
var naturalCompare = /*@__PURE__*/getDefaultExportFromCjs(naturalCompareExports);
var serialize$1 = function serialize$1(val, config, indentation, depth, refs, printer) {
  // Serialize a non-default name, even if config.printFunctionName is false.
  var name = val.getMockName();
  var nameString = name === "vi.fn()" ? "" : " ".concat(name);
  var callsString = "";
  if (val.mock.calls.length !== 0) {
    var indentationNext = indentation + config.indent;
    callsString = " {".concat(config.spacingOuter).concat(indentationNext, "\"calls\": ").concat(printer(val.mock.calls, config, indentationNext, depth, refs)).concat(config.min ? ", " : ",").concat(config.spacingOuter).concat(indentationNext, "\"results\": ").concat(printer(val.mock.results, config, indentationNext, depth, refs)).concat(config.min ? "" : ",").concat(config.spacingOuter).concat(indentation, "}");
  }
  return "[MockFunction".concat(nameString, "]").concat(callsString);
};
var test = function test(val) {
  return val && !!val._isMockFunction;
};
var plugin = {
  serialize: serialize$1,
  test: test
};
var DOMCollection = plugins.DOMCollection,
  DOMElement = plugins.DOMElement,
  Immutable = plugins.Immutable,
  ReactElement = plugins.ReactElement,
  ReactTestComponent = plugins.ReactTestComponent,
  AsymmetricMatcher = plugins.AsymmetricMatcher;
var PLUGINS = [ReactTestComponent, ReactElement, DOMElement, DOMCollection, Immutable, AsymmetricMatcher, plugin];
function addSerializer(plugin) {
  PLUGINS = [plugin].concat(PLUGINS);
}
function getSerializers() {
  return PLUGINS;
}

// TODO: rewrite and clean up
function testNameToKey(testName, count) {
  return "".concat(testName, " ").concat(count);
}
function keyToTestName(key) {
  if (!/ \d+$/.test(key)) {
    throw new Error("Snapshot keys must end with a number.");
  }
  return key.replace(/ \d+$/, "");
}
function getSnapshotData(content, options) {
  var update = options.updateSnapshot;
  var data = Object.create(null);
  var snapshotContents = "";
  var dirty = false;
  if (content != null) {
    try {
      snapshotContents = content;
      // eslint-disable-next-line no-new-func
      var populate = new Function("exports", snapshotContents);
      populate(data);
    } catch (_unused) {}
  }
  // const validationResult = validateSnapshotVersion(snapshotContents)
  var isInvalid = snapshotContents;
  // if (update === 'none' && isInvalid)
  //   throw validationResult
  if ((update === "all" || update === "new") && isInvalid) {
    dirty = true;
  }
  return {
    data: data,
    dirty: dirty
  };
}
// Add extra line breaks at beginning and end of multiline snapshot
// to make the content easier to read.
function addExtraLineBreaks(string) {
  return string.includes("\n") ? "\n".concat(string, "\n") : string;
}
// Remove extra line breaks at beginning and end of multiline snapshot.
// Instead of trim, which can remove additional newlines or spaces
// at beginning or end of the content from a custom serializer.
function removeExtraLineBreaks(string) {
  return string.length > 2 && string.startsWith("\n") && string.endsWith("\n") ? string.slice(1, -1) : string;
}
// export const removeLinesBeforeExternalMatcherTrap = (stack: string): string => {
//   const lines = stack.split('\n')
//   for (let i = 0; i < lines.length; i += 1) {
//     // It's a function name specified in `packages/expect/src/index.ts`
//     // for external custom matchers.
//     if (lines[i].includes('__EXTERNAL_MATCHER_TRAP__'))
//       return lines.slice(i + 1).join('\n')
//   }
//   return stack
// }
var escapeRegex = true;
var printFunctionName = false;
function serialize(val) {
  var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  var formatOverrides = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return normalizeNewlines(format$1(val, _objectSpread$1({
    escapeRegex: escapeRegex,
    indent: indent,
    plugins: getSerializers(),
    printFunctionName: printFunctionName
  }, formatOverrides)));
}
function escapeBacktickString(str) {
  return str.replace(/`|\\|\$\{/g, "\\$&");
}
function printBacktickString(str) {
  return "`".concat(escapeBacktickString(str), "`");
}
function normalizeNewlines(string) {
  return string.replace(/\r\n|\r/g, "\n");
}
function saveSnapshotFile(_x5, _x6, _x7) {
  return _saveSnapshotFile.apply(this, arguments);
}
function _saveSnapshotFile() {
  _saveSnapshotFile = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee10(environment, snapshotData, snapshotPath) {
    var snapshots, content, oldContent, skipWriting;
    return _regeneratorRuntime.wrap(function (_context10) {
      while (1) switch (_context10.prev = _context10.next) {
        case 0:
          snapshots = Object.keys(snapshotData).sort(naturalCompare).map(function (key) {
            return "exports[".concat(printBacktickString(key), "] = ").concat(printBacktickString(normalizeNewlines(snapshotData[key])), ";");
          });
          content = "".concat(environment.getHeader(), "\n\n").concat(snapshots.join("\n\n"), "\n");
          _context10.next = 1;
          return environment.readSnapshotFile(snapshotPath);
        case 1:
          oldContent = _context10.sent;
          skipWriting = oldContent != null && oldContent === content;
          if (!skipWriting) {
            _context10.next = 2;
            break;
          }
          return _context10.abrupt("return");
        case 2:
          _context10.next = 3;
          return environment.saveSnapshotFile(snapshotPath, content);
        case 3:
        case "end":
          return _context10.stop();
      }
    }, _callee10);
  }));
  return _saveSnapshotFile.apply(this, arguments);
}
function deepMergeArray() {
  var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var mergedOutput = Array.from(target);
  source.forEach(function (sourceElement, index) {
    var targetElement = mergedOutput[index];
    if (Array.isArray(target[index])) {
      mergedOutput[index] = deepMergeArray(target[index], sourceElement);
    } else if (isObject(targetElement)) {
      mergedOutput[index] = deepMergeSnapshot(target[index], sourceElement);
    } else {
      // Source does not exist in target or target is primitive and cannot be deep merged
      mergedOutput[index] = sourceElement;
    }
  });
  return mergedOutput;
}
/**
* Deep merge, but considers asymmetric matchers. Unlike base util's deep merge,
* will merge any object-like instance.
* Compatible with Jest's snapshot matcher. Should not be used outside of snapshot.
*
* @example
* ```ts
* toMatchSnapshot({
*   name: expect.stringContaining('text')
* })
* ```
*/
function deepMergeSnapshot(target, source) {
  if (isObject(target) && isObject(source)) {
    var mergedOutput = _objectSpread$1({}, target);
    Object.keys(source).forEach(function (key) {
      if (isObject(source[key]) && !source[key].$$typeof) {
        if (!(key in target)) {
          Object.assign(mergedOutput, _defineProperty({}, key, source[key]));
        } else {
          mergedOutput[key] = deepMergeSnapshot(target[key], source[key]);
        }
      } else if (Array.isArray(source[key])) {
        mergedOutput[key] = deepMergeArray(target[key], source[key]);
      } else {
        Object.assign(mergedOutput, _defineProperty({}, key, source[key]));
      }
    });
    return mergedOutput;
  } else if (Array.isArray(target) && Array.isArray(source)) {
    return deepMergeArray(target, source);
  }
  return target;
}
var DefaultMap = /*#__PURE__*/function (_Map) {
  function DefaultMap(defaultFn, entries) {
    var _this;
    _classCallCheck(this, DefaultMap);
    _this = _callSuper$2(this, DefaultMap, [entries]);
    _this.defaultFn = defaultFn;
    return _this;
  }
  _inherits(DefaultMap, _Map);
  return _createClass(DefaultMap, [{
    key: "get",
    value: function get(key) {
      if (!this.has(key)) {
        this.set(key, this.defaultFn(key));
      }
      return _superPropGet(DefaultMap, "get", this, 3)([key]);
    }
  }]);
}(/*#__PURE__*/_wrapNativeSuper(Map));
var CounterMap = /*#__PURE__*/function (_DefaultMap) {
  function CounterMap() {
    var _this2;
    _classCallCheck(this, CounterMap);
    _this2 = _callSuper$2(this, CounterMap, [function () {
      return 0;
    }]);
    // compat for jest-image-snapshot https://github.com/vitest-dev/vitest/issues/7322
    // `valueOf` and `Snapshot.added` setter allows
    //   snapshotState.added = snapshotState.added + 1
    // to function as
    //   snapshotState.added.total_ = snapshotState.added.total() + 1
    _defineProperty(_this2, "_total", void 0);
    return _this2;
  }
  _inherits(CounterMap, _DefaultMap);
  return _createClass(CounterMap, [{
    key: "valueOf",
    value: function valueOf() {
      return this._total = this.total();
    }
  }, {
    key: "increment",
    value: function increment(key) {
      if (typeof this._total !== "undefined") {
        this._total++;
      }
      this.set(key, this.get(key) + 1);
    }
  }, {
    key: "total",
    value: function total() {
      if (typeof this._total !== "undefined") {
        return this._total;
      }
      var total = 0;
      var _iterator = _createForOfIteratorHelper$1(this.values()),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var x = _step.value;
          total += x;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return total;
    }
  }]);
}(DefaultMap);
function isSameStackPosition(x, y) {
  return x.file === y.file && x.column === y.column && x.line === y.line;
}
var SnapshotState = /*#__PURE__*/function () {
  function SnapshotState(testFilePath, snapshotPath, snapshotContent, options) {
    _classCallCheck(this, SnapshotState);
    _defineProperty(this, "_counters", new CounterMap());
    _defineProperty(this, "_dirty", void 0);
    _defineProperty(this, "_updateSnapshot", void 0);
    _defineProperty(this, "_snapshotData", void 0);
    _defineProperty(this, "_initialData", void 0);
    _defineProperty(this, "_inlineSnapshots", void 0);
    _defineProperty(this, "_inlineSnapshotStacks", void 0);
    _defineProperty(this, "_testIdToKeys", new DefaultMap(function () {
      return [];
    }));
    _defineProperty(this, "_rawSnapshots", void 0);
    _defineProperty(this, "_uncheckedKeys", void 0);
    _defineProperty(this, "_snapshotFormat", void 0);
    _defineProperty(this, "_environment", void 0);
    _defineProperty(this, "_fileExists", void 0);
    _defineProperty(this, "expand", void 0);
    // getter/setter for jest-image-snapshot compat
    // https://github.com/vitest-dev/vitest/issues/7322
    _defineProperty(this, "_added", new CounterMap());
    _defineProperty(this, "_matched", new CounterMap());
    _defineProperty(this, "_unmatched", new CounterMap());
    _defineProperty(this, "_updated", new CounterMap());
    this.testFilePath = testFilePath;
    this.snapshotPath = snapshotPath;
    var _getSnapshotData = getSnapshotData(snapshotContent, options),
      data = _getSnapshotData.data,
      dirty = _getSnapshotData.dirty;
    this._fileExists = snapshotContent != null;
    this._initialData = _objectSpread$1({}, data);
    this._snapshotData = _objectSpread$1({}, data);
    this._dirty = dirty;
    this._inlineSnapshots = [];
    this._inlineSnapshotStacks = [];
    this._rawSnapshots = [];
    this._uncheckedKeys = new Set(Object.keys(this._snapshotData));
    this.expand = options.expand || false;
    this._updateSnapshot = options.updateSnapshot;
    this._snapshotFormat = _objectSpread$1({
      printBasicPrototype: false,
      escapeString: false
    }, options.snapshotFormat);
    this._environment = options.snapshotEnvironment;
  }
  return _createClass(SnapshotState, [{
    key: "added",
    get: function get() {
      return this._added;
    },
    set: function set(value) {
      this._added._total = value;
    }
  }, {
    key: "matched",
    get: function get() {
      return this._matched;
    },
    set: function set(value) {
      this._matched._total = value;
    }
  }, {
    key: "unmatched",
    get: function get() {
      return this._unmatched;
    },
    set: function set(value) {
      this._unmatched._total = value;
    }
  }, {
    key: "updated",
    get: function get() {
      return this._updated;
    },
    set: function set(value) {
      this._updated._total = value;
    }
  }, {
    key: "environment",
    get: function get() {
      return this._environment;
    }
  }, {
    key: "markSnapshotsAsCheckedForTest",
    value: function markSnapshotsAsCheckedForTest(testName) {
      var _this3 = this;
      this._uncheckedKeys.forEach(function (uncheckedKey) {
        // skip snapshots with following keys
        //   testName n
        //   testName > xxx n (this is for toMatchSnapshot("xxx") API)
        if (/ \d+$| > /.test(uncheckedKey.slice(testName.length))) {
          _this3._uncheckedKeys.delete(uncheckedKey);
        }
      });
    }
  }, {
    key: "clearTest",
    value: function clearTest(testId) {
      // clear inline
      this._inlineSnapshots = this._inlineSnapshots.filter(function (s) {
        return s.testId !== testId;
      });
      this._inlineSnapshotStacks = this._inlineSnapshotStacks.filter(function (s) {
        return s.testId !== testId;
      });
      // clear file
      var _iterator2 = _createForOfIteratorHelper$1(this._testIdToKeys.get(testId)),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var key = _step2.value;
          var name = keyToTestName(key);
          var count = this._counters.get(name);
          if (count > 0) {
            if (key in this._snapshotData || key in this._initialData) {
              this._snapshotData[key] = this._initialData[key];
            }
            this._counters.set(name, count - 1);
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      this._testIdToKeys.delete(testId);
      // clear stats
      this.added.delete(testId);
      this.updated.delete(testId);
      this.matched.delete(testId);
      this.unmatched.delete(testId);
    }
  }, {
    key: "_inferInlineSnapshotStack",
    value: function _inferInlineSnapshotStack(stacks) {
      // if called inside resolves/rejects, stacktrace is different
      var promiseIndex = stacks.findIndex(function (i) {
        return i.method.match(/__VITEST_(RESOLVES|REJECTS)__/);
      });
      if (promiseIndex !== -1) {
        return stacks[promiseIndex + 3];
      }
      // inline snapshot function is called __INLINE_SNAPSHOT__
      // in integrations/snapshot/chai.ts
      var stackIndex = stacks.findIndex(function (i) {
        return i.method.includes("__INLINE_SNAPSHOT__");
      });
      return stackIndex !== -1 ? stacks[stackIndex + 2] : null;
    }
  }, {
    key: "_addSnapshot",
    value: function _addSnapshot(key, receivedSerialized, options) {
      this._dirty = true;
      if (options.stack) {
        this._inlineSnapshots.push(_objectSpread$1({
          snapshot: receivedSerialized,
          testId: options.testId
        }, options.stack));
      } else if (options.rawSnapshot) {
        this._rawSnapshots.push(_objectSpread$1(_objectSpread$1({}, options.rawSnapshot), {}, {
          snapshot: receivedSerialized
        }));
      } else {
        this._snapshotData[key] = receivedSerialized;
      }
    }
  }, {
    key: "save",
    value: function () {
      var _save = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        var hasExternalSnapshots, hasInlineSnapshots, hasRawSnapshots, isEmpty, status;
        return _regeneratorRuntime.wrap(function (_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              hasExternalSnapshots = Object.keys(this._snapshotData).length;
              hasInlineSnapshots = this._inlineSnapshots.length;
              hasRawSnapshots = this._rawSnapshots.length;
              isEmpty = !hasExternalSnapshots && !hasInlineSnapshots && !hasRawSnapshots;
              status = {
                deleted: false,
                saved: false
              };
              if (!((this._dirty || this._uncheckedKeys.size) && !isEmpty)) {
                _context2.next = 5;
                break;
              }
              if (!hasExternalSnapshots) {
                _context2.next = 2;
                break;
              }
              _context2.next = 1;
              return saveSnapshotFile(this._environment, this._snapshotData, this.snapshotPath);
            case 1:
              this._fileExists = true;
            case 2:
              if (!hasInlineSnapshots) {
                _context2.next = 3;
                break;
              }
              _context2.next = 3;
              return saveInlineSnapshots(this._environment, this._inlineSnapshots);
            case 3:
              if (!hasRawSnapshots) {
                _context2.next = 4;
                break;
              }
              _context2.next = 4;
              return saveRawSnapshots(this._environment, this._rawSnapshots);
            case 4:
              status.saved = true;
              _context2.next = 8;
              break;
            case 5:
              if (!(!hasExternalSnapshots && this._fileExists)) {
                _context2.next = 8;
                break;
              }
              if (!(this._updateSnapshot === "all")) {
                _context2.next = 7;
                break;
              }
              _context2.next = 6;
              return this._environment.removeSnapshotFile(this.snapshotPath);
            case 6:
              this._fileExists = false;
            case 7:
              status.deleted = true;
            case 8:
              return _context2.abrupt("return", status);
            case 9:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function save() {
        return _save.apply(this, arguments);
      }
      return save;
    }()
  }, {
    key: "getUncheckedCount",
    value: function getUncheckedCount() {
      return this._uncheckedKeys.size || 0;
    }
  }, {
    key: "getUncheckedKeys",
    value: function getUncheckedKeys() {
      return Array.from(this._uncheckedKeys);
    }
  }, {
    key: "removeUncheckedKeys",
    value: function removeUncheckedKeys() {
      var _this4 = this;
      if (this._updateSnapshot === "all" && this._uncheckedKeys.size) {
        this._dirty = true;
        this._uncheckedKeys.forEach(function (key) {
          return delete _this4._snapshotData[key];
        });
        this._uncheckedKeys.clear();
      }
    }
  }, {
    key: "match",
    value: function match(_ref2) {
      var testId = _ref2.testId,
        testName = _ref2.testName,
        received = _ref2.received,
        key = _ref2.key,
        inlineSnapshot = _ref2.inlineSnapshot,
        isInline = _ref2.isInline,
        error = _ref2.error,
        rawSnapshot = _ref2.rawSnapshot;
      // this also increments counter for inline snapshots. maybe we shouldn't?
      this._counters.increment(testName);
      var count = this._counters.get(testName);
      if (!key) {
        key = testNameToKey(testName, count);
      }
      this._testIdToKeys.get(testId).push(key);
      // Do not mark the snapshot as "checked" if the snapshot is inline and
      // there's an external snapshot. This way the external snapshot can be
      // removed with `--updateSnapshot`.
      if (!(isInline && this._snapshotData[key] !== undefined)) {
        this._uncheckedKeys.delete(key);
      }
      var receivedSerialized = rawSnapshot && typeof received === "string" ? received : serialize(received, undefined, this._snapshotFormat);
      if (!rawSnapshot) {
        receivedSerialized = addExtraLineBreaks(receivedSerialized);
      }
      if (rawSnapshot) {
        // normalize EOL when snapshot contains CRLF but received is LF
        if (rawSnapshot.content && rawSnapshot.content.match(/\r\n/) && !receivedSerialized.match(/\r\n/)) {
          rawSnapshot.content = normalizeNewlines(rawSnapshot.content);
        }
      }
      var expected = isInline ? inlineSnapshot : rawSnapshot ? rawSnapshot.content : this._snapshotData[key];
      var expectedTrimmed = rawSnapshot ? expected : expected === null || expected === void 0 ? void 0 : expected.trim();
      var pass = expectedTrimmed === (rawSnapshot ? receivedSerialized : receivedSerialized.trim());
      var hasSnapshot = expected !== undefined;
      var snapshotIsPersisted = isInline || this._fileExists || rawSnapshot && rawSnapshot.content != null;
      if (pass && !isInline && !rawSnapshot) {
        // Executing a snapshot file as JavaScript and writing the strings back
        // when other snapshots have changed loses the proper escaping for some
        // characters. Since we check every snapshot in every test, use the newly
        // generated formatted string.
        // Note that this is only relevant when a snapshot is added and the dirty
        // flag is set.
        this._snapshotData[key] = receivedSerialized;
      }
      // find call site of toMatchInlineSnapshot
      var stack;
      if (isInline) {
        var _this$environment$pro, _this$environment;
        var stacks = parseErrorStacktrace(error || new Error("snapshot"), {
          ignoreStackEntries: []
        });
        var _stack = this._inferInlineSnapshotStack(stacks);
        if (!_stack) {
          throw new Error("@vitest/snapshot: Couldn't infer stack frame for inline snapshot.\n".concat(JSON.stringify(stacks)));
        }
        stack = ((_this$environment$pro = (_this$environment = this.environment).processStackTrace) === null || _this$environment$pro === void 0 ? void 0 : _this$environment$pro.call(_this$environment, _stack)) || _stack;
        // removing 1 column, because source map points to the wrong
        // location for js files, but `column-1` points to the same in both js/ts
        // https://github.com/vitejs/vite/issues/8657
        stack.column--;
        // reject multiple inline snapshots at the same location if snapshot is different
        var snapshotsWithSameStack = this._inlineSnapshotStacks.filter(function (s) {
          return isSameStackPosition(s, stack);
        });
        if (snapshotsWithSameStack.length > 0) {
          // ensure only one snapshot will be written at the same location
          this._inlineSnapshots = this._inlineSnapshots.filter(function (s) {
            return !isSameStackPosition(s, stack);
          });
          var differentSnapshot = snapshotsWithSameStack.find(function (s) {
            return s.snapshot !== receivedSerialized;
          });
          if (differentSnapshot) {
            throw Object.assign(new Error("toMatchInlineSnapshot with different snapshots cannot be called at the same location"), {
              actual: receivedSerialized,
              expected: differentSnapshot.snapshot
            });
          }
        }
        this._inlineSnapshotStacks.push(_objectSpread$1(_objectSpread$1({}, stack), {}, {
          testId: testId,
          snapshot: receivedSerialized
        }));
      }
      // These are the conditions on when to write snapshots:
      //  * There's no snapshot file in a non-CI environment.
      //  * There is a snapshot file and we decided to update the snapshot.
      //  * There is a snapshot file, but it doesn't have this snapshot.
      // These are the conditions on when not to write snapshots:
      //  * The update flag is set to 'none'.
      //  * There's no snapshot file or a file without this snapshot on a CI environment.
      if (hasSnapshot && this._updateSnapshot === "all" || (!hasSnapshot || !snapshotIsPersisted) && (this._updateSnapshot === "new" || this._updateSnapshot === "all")) {
        if (this._updateSnapshot === "all") {
          if (!pass) {
            if (hasSnapshot) {
              this.updated.increment(testId);
            } else {
              this.added.increment(testId);
            }
            this._addSnapshot(key, receivedSerialized, {
              stack: stack,
              testId: testId,
              rawSnapshot: rawSnapshot
            });
          } else {
            this.matched.increment(testId);
          }
        } else {
          this._addSnapshot(key, receivedSerialized, {
            stack: stack,
            testId: testId,
            rawSnapshot: rawSnapshot
          });
          this.added.increment(testId);
        }
        return {
          actual: "",
          count: count,
          expected: "",
          key: key,
          pass: true
        };
      } else {
        if (!pass) {
          this.unmatched.increment(testId);
          return {
            actual: rawSnapshot ? receivedSerialized : removeExtraLineBreaks(receivedSerialized),
            count: count,
            expected: expectedTrimmed !== undefined ? rawSnapshot ? expectedTrimmed : removeExtraLineBreaks(expectedTrimmed) : undefined,
            key: key,
            pass: false
          };
        } else {
          this.matched.increment(testId);
          return {
            actual: "",
            count: count,
            expected: "",
            key: key,
            pass: true
          };
        }
      }
    }
  }, {
    key: "pack",
    value: function () {
      var _pack = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
        var snapshot, uncheckedCount, uncheckedKeys, status;
        return _regeneratorRuntime.wrap(function (_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              snapshot = {
                filepath: this.testFilePath,
                added: 0,
                fileDeleted: false,
                matched: 0,
                unchecked: 0,
                uncheckedKeys: [],
                unmatched: 0,
                updated: 0
              };
              uncheckedCount = this.getUncheckedCount();
              uncheckedKeys = this.getUncheckedKeys();
              if (uncheckedCount) {
                this.removeUncheckedKeys();
              }
              _context3.next = 1;
              return this.save();
            case 1:
              status = _context3.sent;
              snapshot.fileDeleted = status.deleted;
              snapshot.added = this.added.total();
              snapshot.matched = this.matched.total();
              snapshot.unmatched = this.unmatched.total();
              snapshot.updated = this.updated.total();
              snapshot.unchecked = !status.deleted ? uncheckedCount : 0;
              snapshot.uncheckedKeys = Array.from(uncheckedKeys);
              return _context3.abrupt("return", snapshot);
            case 2:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function pack() {
        return _pack.apply(this, arguments);
      }
      return pack;
    }()
  }], [{
    key: "create",
    value: function () {
      var _create = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(testFilePath, options) {
        var snapshotPath, content;
        return _regeneratorRuntime.wrap(function (_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 1;
              return options.snapshotEnvironment.resolvePath(testFilePath);
            case 1:
              snapshotPath = _context4.sent;
              _context4.next = 2;
              return options.snapshotEnvironment.readSnapshotFile(snapshotPath);
            case 2:
              content = _context4.sent;
              return _context4.abrupt("return", new SnapshotState(testFilePath, snapshotPath, content, options));
            case 3:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }));
      function create(_x8, _x9) {
        return _create.apply(this, arguments);
      }
      return create;
    }()
  }]);
}();
function createMismatchError(message, expand, actual, expected) {
  var error = new Error(message);
  Object.defineProperty(error, "actual", {
    value: actual,
    enumerable: true,
    configurable: true,
    writable: true
  });
  Object.defineProperty(error, "expected", {
    value: expected,
    enumerable: true,
    configurable: true,
    writable: true
  });
  Object.defineProperty(error, "diffOptions", {
    value: {
      expand: expand
    }
  });
  return error;
}
var SnapshotClient = /*#__PURE__*/function () {
  function SnapshotClient() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, SnapshotClient);
    _defineProperty(this, "snapshotStateMap", new Map());
    this.options = options;
  }
  return _createClass(SnapshotClient, [{
    key: "setup",
    value: function () {
      var _setup = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee5(filepath, options) {
        var _t6, _t7;
        return _regeneratorRuntime.wrap(function (_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              if (!this.snapshotStateMap.has(filepath)) {
                _context5.next = 1;
                break;
              }
              return _context5.abrupt("return");
            case 1:
              _t6 = this.snapshotStateMap;
              _t7 = filepath;
              _context5.next = 2;
              return SnapshotState.create(filepath, options);
            case 2:
              _t6.set.call(_t6, _t7, _context5.sent);
            case 3:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function setup(_x0, _x1) {
        return _setup.apply(this, arguments);
      }
      return setup;
    }()
  }, {
    key: "finish",
    value: function () {
      var _finish = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee6(filepath) {
        var state, result;
        return _regeneratorRuntime.wrap(function (_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              state = this.getSnapshotState(filepath);
              _context6.next = 1;
              return state.pack();
            case 1:
              result = _context6.sent;
              this.snapshotStateMap.delete(filepath);
              return _context6.abrupt("return", result);
            case 2:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function finish(_x10) {
        return _finish.apply(this, arguments);
      }
      return finish;
    }()
  }, {
    key: "skipTest",
    value: function skipTest(filepath, testName) {
      var state = this.getSnapshotState(filepath);
      state.markSnapshotsAsCheckedForTest(testName);
    }
  }, {
    key: "clearTest",
    value: function clearTest(filepath, testId) {
      var state = this.getSnapshotState(filepath);
      state.clearTest(testId);
    }
  }, {
    key: "getSnapshotState",
    value: function getSnapshotState(filepath) {
      var state = this.snapshotStateMap.get(filepath);
      if (!state) {
        throw new Error("The snapshot state for '".concat(filepath, "' is not found. Did you call 'SnapshotClient.setup()'?"));
      }
      return state;
    }
  }, {
    key: "assert",
    value: function assert(options) {
      var filepath = options.filepath,
        name = options.name,
        _options$testId = options.testId,
        testId = _options$testId === void 0 ? name : _options$testId,
        message = options.message,
        _options$isInline = options.isInline,
        isInline = _options$isInline === void 0 ? false : _options$isInline,
        properties = options.properties,
        inlineSnapshot = options.inlineSnapshot,
        error = options.error,
        errorMessage = options.errorMessage,
        rawSnapshot = options.rawSnapshot;
      var received = options.received;
      if (!filepath) {
        throw new Error("Snapshot cannot be used outside of test");
      }
      var snapshotState = this.getSnapshotState(filepath);
      if (_typeof(properties) === "object") {
        if (_typeof(received) !== "object" || !received) {
          throw new Error("Received value must be an object when the matcher has properties");
        }
        try {
          var _ref3;
          var _this$options$isEqual, _this$options;
          var _pass = (_ref3 = (_this$options$isEqual = (_this$options = this.options).isEqual) === null || _this$options$isEqual === void 0 ? void 0 : _this$options$isEqual.call(_this$options, received, properties)) !== null && _ref3 !== void 0 ? _ref3 : false;
          // const pass = equals(received, properties, [iterableEquality, subsetEquality])
          if (!_pass) {
            throw createMismatchError("Snapshot properties mismatched", snapshotState.expand, received, properties);
          } else {
            received = deepMergeSnapshot(received, properties);
          }
        } catch (err) {
          err.message = errorMessage || "Snapshot mismatched";
          throw err;
        }
      }
      var testName = [name].concat(_toConsumableArray(message ? [message] : [])).join(" > ");
      var _snapshotState$match = snapshotState.match({
          testId: testId,
          testName: testName,
          received: received,
          isInline: isInline,
          error: error,
          inlineSnapshot: inlineSnapshot,
          rawSnapshot: rawSnapshot
        }),
        actual = _snapshotState$match.actual,
        expected = _snapshotState$match.expected,
        key = _snapshotState$match.key,
        pass = _snapshotState$match.pass;
      if (!pass) {
        throw createMismatchError("Snapshot `".concat(key || "unknown", "` mismatched"), snapshotState.expand, rawSnapshot ? actual : actual === null || actual === void 0 ? void 0 : actual.trim(), rawSnapshot ? expected : expected === null || expected === void 0 ? void 0 : expected.trim());
      }
    }
  }, {
    key: "assertRaw",
    value: function () {
      var _assertRaw = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee7(options) {
        var filepath, rawSnapshot, _yield$snapshotState$, snapshotState, _t8, _t9, _t0;
        return _regeneratorRuntime.wrap(function (_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              if (options.rawSnapshot) {
                _context7.next = 1;
                break;
              }
              throw new Error("Raw snapshot is required");
            case 1:
              filepath = options.filepath, rawSnapshot = options.rawSnapshot;
              if (!(rawSnapshot.content == null)) {
                _context7.next = 8;
                break;
              }
              if (filepath) {
                _context7.next = 2;
                break;
              }
              throw new Error("Snapshot cannot be used outside of test");
            case 2:
              snapshotState = this.getSnapshotState(filepath); // save the filepath, so it don't lose even if the await make it out-of-context
              options.filepath || (options.filepath = filepath);
              // resolve and read the raw snapshot file
              _context7.next = 3;
              return snapshotState.environment.resolveRawPath(filepath, rawSnapshot.file);
            case 3:
              rawSnapshot.file = _context7.sent;
              _context7.next = 4;
              return snapshotState.environment.readSnapshotFile(rawSnapshot.file);
            case 4:
              _t9 = _yield$snapshotState$ = _context7.sent;
              _t8 = _t9 !== null;
              if (!_t8) {
                _context7.next = 5;
                break;
              }
              _t8 = _yield$snapshotState$ !== void 0;
            case 5:
              if (!_t8) {
                _context7.next = 6;
                break;
              }
              _t0 = _yield$snapshotState$;
              _context7.next = 7;
              break;
            case 6:
              _t0 = undefined;
            case 7:
              rawSnapshot.content = _t0;
            case 8:
              return _context7.abrupt("return", this.assert(options));
            case 9:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function assertRaw(_x11) {
        return _assertRaw.apply(this, arguments);
      }
      return assertRaw;
    }()
  }, {
    key: "clear",
    value: function clear() {
      this.snapshotStateMap.clear();
    }
  }]);
}();

function _callSuper$1(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$1() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$1() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$1 = function _isNativeReflectConstruct() { return !!t; })(); }
/* Ported from https://github.com/boblauer/MockDate/blob/master/src/mockdate.ts */
/*
The MIT License (MIT)

Copyright (c) 2014 Bob Lauer

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
var RealDate = Date;
var now = null;
var MockDate = /*#__PURE__*/function (_RealDate) {
  function MockDate(y, m, d, h, M, s, ms) {
    var _this;
    _classCallCheck(this, MockDate);
    _this = _callSuper$1(this, MockDate);
    var date;
    switch (arguments.length) {
      case 0:
        if (now !== null) date = new RealDate(now.valueOf());else date = new RealDate();
        break;
      case 1:
        date = new RealDate(y);
        break;
      default:
        d = typeof d === "undefined" ? 1 : d;
        h = h || 0;
        M = M || 0;
        s = s || 0;
        ms = ms || 0;
        date = new RealDate(y, m, d, h, M, s, ms);
        break;
    }
    Object.setPrototypeOf(date, MockDate.prototype);
    return _possibleConstructorReturn(_this, date);
  }
  _inherits(MockDate, _RealDate);
  return _createClass(MockDate);
}(RealDate);
MockDate.UTC = RealDate.UTC;
MockDate.now = function () {
  return new MockDate().valueOf();
};
MockDate.parse = function (dateString) {
  return RealDate.parse(dateString);
};
MockDate.toString = function () {
  return RealDate.toString();
};
function mockDate(date) {
  var dateObj = new RealDate(date.valueOf());
  if (Number.isNaN(dateObj.getTime())) throw new TypeError("mockdate: The time set is an invalid date: ".concat(date));
  // @ts-expect-error global
  globalThis.Date = MockDate;
  now = dateObj.valueOf();
}
function resetDate() {
  globalThis.Date = RealDate;
}

function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }

// these matchers are not supported because they don't make sense with poll
var unsupported = ["matchSnapshot", "toMatchSnapshot", "toMatchInlineSnapshot", "toThrowErrorMatchingSnapshot", "toThrowErrorMatchingInlineSnapshot", "throws", "Throw", "throw", "toThrow", "toThrowError"];
function createExpectPoll(expect) {
  return function poll(fn) {
    var _state$config$expect$, _state$config$expect, _defaults$interval, _defaults$timeout;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var state = getWorkerState();
    var defaults = (_state$config$expect$ = (_state$config$expect = state.config.expect) === null || _state$config$expect === void 0 ? void 0 : _state$config$expect.poll) !== null && _state$config$expect$ !== void 0 ? _state$config$expect$ : {};
    var _options$interval = options.interval,
      interval = _options$interval === void 0 ? (_defaults$interval = defaults.interval) !== null && _defaults$interval !== void 0 ? _defaults$interval : 50 : _options$interval,
      _options$timeout = options.timeout,
      timeout = _options$timeout === void 0 ? (_defaults$timeout = defaults.timeout) !== null && _defaults$timeout !== void 0 ? _defaults$timeout : 1e3 : _options$timeout,
      message = options.message;
    // @ts-expect-error private poll access
    var assertion = expect(null, message).withContext({
      poll: true
    });
    fn = fn.bind(assertion);
    var test = utils_exports.flag(assertion, "vitest-test");
    if (!test) throw new Error("expect.poll() must be called inside a test");
    var proxy = new Proxy(assertion, {
      get: function get(target, key, receiver) {
        var assertionFunction = Reflect.get(target, key, receiver);
        if (typeof assertionFunction !== "function") return assertionFunction instanceof Assertion ? proxy : assertionFunction;
        if (key === "assert") return assertionFunction;
        if (typeof key === "string" && unsupported.includes(key)) throw new SyntaxError("expect.poll() is not supported in combination with .".concat(key, "(). Use vi.waitFor() if your assertion condition is unstable."));
        return function () {
          var _test$onFinished;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          var STACK_TRACE_ERROR = new Error("STACK_TRACE_ERROR");
          var promise = function promise() {
            return new Promise(function (resolve, reject) {
              var intervalId;
              var timeoutId;
              var lastError;
              var _getSafeTimers = getSafeTimers(),
                setTimeout = _getSafeTimers.setTimeout,
                clearTimeout = _getSafeTimers.clearTimeout;
              var _check = /*#__PURE__*/function () {
                var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
                  var obj, _t, _t2;
                  return _regeneratorRuntime.wrap(function (_context) {
                    while (1) switch (_context.prev = _context.next) {
                      case 0:
                        _context.prev = 0;
                        utils_exports.flag(assertion, "_name", key);
                        _context.next = 1;
                        return fn();
                      case 1:
                        obj = _context.sent;
                        utils_exports.flag(assertion, "object", obj);
                        _t = resolve;
                        _context.next = 2;
                        return assertionFunction.call.apply(assertionFunction, [assertion].concat(args));
                      case 2:
                        _t(_context.sent);
                        clearTimeout(intervalId);
                        clearTimeout(timeoutId);
                        _context.next = 4;
                        break;
                      case 3:
                        _context.prev = 3;
                        _t2 = _context["catch"](0);
                        lastError = _t2;
                        if (!utils_exports.flag(assertion, "_isLastPollAttempt")) intervalId = setTimeout(_check, interval);
                      case 4:
                      case "end":
                        return _context.stop();
                    }
                  }, _callee, null, [[0, 3]]);
                }));
                return function check() {
                  return _ref.apply(this, arguments);
                };
              }();
              timeoutId = setTimeout(function () {
                clearTimeout(intervalId);
                utils_exports.flag(assertion, "_isLastPollAttempt", true);
                var rejectWithCause = function rejectWithCause(cause) {
                  reject(copyStackTrace$1(new Error("Matcher did not succeed in time.", {
                    cause: cause
                  }), STACK_TRACE_ERROR));
                };
                _check().then(function () {
                  return rejectWithCause(lastError);
                }).catch(function (e) {
                  return rejectWithCause(e);
                });
              }, timeout);
              _check();
            });
          };
          var awaited = false;
          (_test$onFinished = test.onFinished) !== null && _test$onFinished !== void 0 ? _test$onFinished : test.onFinished = [];
          test.onFinished.push(function () {
            if (!awaited) {
              var negated = utils_exports.flag(assertion, "negate") ? "not." : "";
              var name = utils_exports.flag(assertion, "_poll.element") ? "element(locator)" : "poll(assertion)";
              var assertionString = "expect.".concat(name, ".").concat(negated).concat(String(key), "()");
              var error = new Error("".concat(assertionString, " was not awaited. This assertion is asynchronous and must be awaited; otherwise, it is not executed to avoid unhandled rejections:\n\nawait ").concat(assertionString, "\n"));
              throw copyStackTrace$1(error, STACK_TRACE_ERROR);
            }
          });
          var resultPromise;
          // only .then is enough to check awaited, but we type this as `Promise<void>` in global types
          // so let's follow it
          return _defineProperty({
            then: function then(onFulfilled, onRejected) {
              awaited = true;
              return (resultPromise || (resultPromise = promise())).then(onFulfilled, onRejected);
            },
            catch: function _catch(onRejected) {
              return (resultPromise || (resultPromise = promise())).catch(onRejected);
            },
            finally: function _finally(onFinally) {
              return (resultPromise || (resultPromise = promise())).finally(onFinally);
            }
          }, Symbol.toStringTag, "Promise");
        };
      }
    });
    return proxy;
  };
}
function copyStackTrace$1(target, source) {
  if (source.stack !== void 0) target.stack = source.stack.replace(source.message, target.message);
  return target;
}
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var chaiSubset$1 = {
  exports: {}
};
var chaiSubset = chaiSubset$1.exports;
var hasRequiredChaiSubset;
function requireChaiSubset() {
  if (hasRequiredChaiSubset) return chaiSubset$1.exports;
  hasRequiredChaiSubset = 1;
  (function (module, exports) {
    (function () {
      (function (chaiSubset) {
        if (typeof commonjsRequire === 'function' && 'object' === 'object' && 'object' === 'object') {
          return module.exports = chaiSubset;
        } else {
          return chai.use(chaiSubset);
        }
      })(function (chai, utils) {
        var Assertion = chai.Assertion;
        var assertionPrototype = Assertion.prototype;
        Assertion.addMethod('containSubset', function (expected) {
          var actual = utils.flag(this, 'object');
          var showDiff = chai.config.showDiff;
          assertionPrototype.assert.call(this, compare(expected, actual), 'expected #{act} to contain subset #{exp}', 'expected #{act} to not contain subset #{exp}', expected, actual, showDiff);
        });
        chai.assert.containSubset = function (val, exp, msg) {
          new chai.Assertion(val, msg).to.be.containSubset(exp);
        };
        function compare(expected, actual) {
          if (expected === actual) {
            return true;
          }
          if (_typeof(actual) !== _typeof(expected)) {
            return false;
          }
          if (_typeof(expected) !== 'object' || expected === null) {
            return expected === actual;
          }
          if (!!expected && !actual) {
            return false;
          }
          if (Array.isArray(expected)) {
            if (typeof actual.length !== 'number') {
              return false;
            }
            var aa = Array.prototype.slice.call(actual);
            return expected.every(function (exp) {
              return aa.some(function (act) {
                return compare(exp, act);
              });
            });
          }
          if (expected instanceof Date) {
            if (actual instanceof Date) {
              return expected.getTime() === actual.getTime();
            } else {
              return false;
            }
          }
          return Object.keys(expected).every(function (key) {
            var eo = expected[key];
            var ao = actual[key];
            if (_typeof(eo) === 'object' && eo !== null && ao !== null) {
              return compare(eo, ao);
            }
            if (typeof eo === 'function') {
              return eo(ao);
            }
            return ao === eo;
          });
        }
      });
    }).call(chaiSubset);
  })(chaiSubset$1);
  return chaiSubset$1.exports;
}
var chaiSubsetExports = requireChaiSubset();
var Subset = /*@__PURE__*/getDefaultExportFromCjs$1(chaiSubsetExports);
function createAssertionMessage(util, assertion, hasArgs) {
  var not = util.flag(assertion, "negate") ? "not." : "";
  var name = "".concat(util.flag(assertion, "_name"), "(", "expected", ")");
  var promiseName = util.flag(assertion, "promise");
  var promise = promiseName ? ".".concat(promiseName) : "";
  return "expect(actual)".concat(promise, ".").concat(not).concat(name);
}
function recordAsyncExpect(_test, promise, assertion, error) {
  var test = _test;
  // record promise for test, that resolves before test ends
  if (test && promise instanceof Promise) {
    var _test$onFinished2;
    // if promise is explicitly awaited, remove it from the list
    promise = promise.finally(function () {
      if (!test.promises) return;
      var index = test.promises.indexOf(promise);
      if (index !== -1) test.promises.splice(index, 1);
    });
    // record promise
    if (!test.promises) test.promises = [];
    test.promises.push(promise);
    var resolved = false;
    (_test$onFinished2 = test.onFinished) !== null && _test$onFinished2 !== void 0 ? _test$onFinished2 : test.onFinished = [];
    test.onFinished.push(function () {
      if (!resolved) {
        var _globalThis$__vitest_;
        var processor = ((_globalThis$__vitest_ = globalThis.__vitest_worker__) === null || _globalThis$__vitest_ === void 0 ? void 0 : _globalThis$__vitest_.onFilterStackTrace) || function (s) {
          return s || "";
        };
        var stack = processor(error.stack);
        console.warn(["Promise returned by `".concat(assertion, "` was not awaited. "), "Vitest currently auto-awaits hanging assertions at the end of the test, but this will cause the test to fail in Vitest 3. ", "Please remember to await the assertion.\n", stack].join(""));
      }
    });
    return _defineProperty({
      then: function then(onFulfilled, onRejected) {
        resolved = true;
        return promise.then(onFulfilled, onRejected);
      },
      catch: function _catch(onRejected) {
        return promise.catch(onRejected);
      },
      finally: function _finally(onFinally) {
        return promise.finally(onFinally);
      }
    }, Symbol.toStringTag, "Promise");
  }
  return promise;
}
var _client;
function getSnapshotClient() {
  if (!_client) _client = new SnapshotClient({
    isEqual: function isEqual(received, expected) {
      return equals(received, expected, [iterableEquality, subsetEquality]);
    }
  });
  return _client;
}
function getError(expected, promise) {
  if (typeof expected !== "function") {
    if (!promise) throw new Error("expected must be a function, received ".concat(_typeof(expected)));
    // when "promised", it receives thrown error
    return expected;
  }
  try {
    expected();
  } catch (e) {
    return e;
  }
  throw new Error("snapshot function didn't throw");
}
function getTestNames(test) {
  return {
    filepath: test.file.filepath,
    name: getNames(test).slice(1).join(" > "),
    testId: test.id
  };
}
var SnapshotPlugin = function SnapshotPlugin(chai, utils) {
  function getTest(assertionName, obj) {
    var test = utils.flag(obj, "vitest-test");
    if (!test) throw new Error("'".concat(assertionName, "' cannot be used without test context"));
    return test;
  }
  var _loop = function _loop() {
    var key = _arr[_i];
    utils.addMethod(chai.Assertion.prototype, key, function (properties, message) {
      utils.flag(this, "_name", key);
      var isNot = utils.flag(this, "negate");
      if (isNot) throw new Error("".concat(key, " cannot be used with \"not\""));
      var expected = utils.flag(this, "object");
      var test = getTest(key, this);
      if (typeof properties === "string" && typeof message === "undefined") {
        message = properties;
        properties = void 0;
      }
      var errorMessage = utils.flag(this, "message");
      getSnapshotClient().assert(_objectSpread({
        received: expected,
        message: message,
        isInline: false,
        properties: properties,
        errorMessage: errorMessage
      }, getTestNames(test)));
    });
  };
  for (var _i = 0, _arr = ["matchSnapshot", "toMatchSnapshot"]; _i < _arr.length; _i++) {
    _loop();
  }
  utils.addMethod(chai.Assertion.prototype, "toMatchFileSnapshot", function (file, message) {
    utils.flag(this, "_name", "toMatchFileSnapshot");
    var isNot = utils.flag(this, "negate");
    if (isNot) throw new Error("toMatchFileSnapshot cannot be used with \"not\"");
    var error = new Error("resolves");
    var expected = utils.flag(this, "object");
    var test = getTest("toMatchFileSnapshot", this);
    var errorMessage = utils.flag(this, "message");
    var promise = getSnapshotClient().assertRaw(_objectSpread({
      received: expected,
      message: message,
      isInline: false,
      rawSnapshot: {
        file: file
      },
      errorMessage: errorMessage
    }, getTestNames(test)));
    return recordAsyncExpect(test, promise, createAssertionMessage(utils, this), error);
  });
  utils.addMethod(chai.Assertion.prototype, "toMatchInlineSnapshot", function __INLINE_SNAPSHOT__(properties, inlineSnapshot, message) {
    var _test$suite;
    utils.flag(this, "_name", "toMatchInlineSnapshot");
    var isNot = utils.flag(this, "negate");
    if (isNot) throw new Error("toMatchInlineSnapshot cannot be used with \"not\"");
    var test = getTest("toMatchInlineSnapshot", this);
    var isInsideEach = test.each || ((_test$suite = test.suite) === null || _test$suite === void 0 ? void 0 : _test$suite.each);
    if (isInsideEach) throw new Error("InlineSnapshot cannot be used inside of test.each or describe.each");
    var expected = utils.flag(this, "object");
    var error = utils.flag(this, "error");
    if (typeof properties === "string") {
      message = inlineSnapshot;
      inlineSnapshot = properties;
      properties = void 0;
    }
    if (inlineSnapshot) inlineSnapshot = stripSnapshotIndentation(inlineSnapshot);
    var errorMessage = utils.flag(this, "message");
    getSnapshotClient().assert(_objectSpread({
      received: expected,
      message: message,
      isInline: true,
      properties: properties,
      inlineSnapshot: inlineSnapshot,
      error: error,
      errorMessage: errorMessage
    }, getTestNames(test)));
  });
  utils.addMethod(chai.Assertion.prototype, "toThrowErrorMatchingSnapshot", function (message) {
    utils.flag(this, "_name", "toThrowErrorMatchingSnapshot");
    var isNot = utils.flag(this, "negate");
    if (isNot) throw new Error("toThrowErrorMatchingSnapshot cannot be used with \"not\"");
    var expected = utils.flag(this, "object");
    var test = getTest("toThrowErrorMatchingSnapshot", this);
    var promise = utils.flag(this, "promise");
    var errorMessage = utils.flag(this, "message");
    getSnapshotClient().assert(_objectSpread({
      received: getError(expected, promise),
      message: message,
      errorMessage: errorMessage
    }, getTestNames(test)));
  });
  utils.addMethod(chai.Assertion.prototype, "toThrowErrorMatchingInlineSnapshot", function __INLINE_SNAPSHOT__(inlineSnapshot, message) {
    var _test$suite2;
    var isNot = utils.flag(this, "negate");
    if (isNot) throw new Error("toThrowErrorMatchingInlineSnapshot cannot be used with \"not\"");
    var test = getTest("toThrowErrorMatchingInlineSnapshot", this);
    var isInsideEach = test.each || ((_test$suite2 = test.suite) === null || _test$suite2 === void 0 ? void 0 : _test$suite2.each);
    if (isInsideEach) throw new Error("InlineSnapshot cannot be used inside of test.each or describe.each");
    var expected = utils.flag(this, "object");
    var error = utils.flag(this, "error");
    var promise = utils.flag(this, "promise");
    var errorMessage = utils.flag(this, "message");
    if (inlineSnapshot) inlineSnapshot = stripSnapshotIndentation(inlineSnapshot);
    getSnapshotClient().assert(_objectSpread({
      received: getError(expected, promise),
      message: message,
      inlineSnapshot: inlineSnapshot,
      isInline: true,
      error: error,
      errorMessage: errorMessage
    }, getTestNames(test)));
  });
  utils.addMethod(chai.expect, "addSnapshotSerializer", addSerializer);
};
use(JestExtend);
use(JestChaiExpect);
use(Subset);
use(SnapshotPlugin);
use(JestAsymmetricMatchers);
function createExpect(test) {
  var _expect = function expect$1(value, message) {
    var _getState = getState(_expect),
      assertionCalls = _getState.assertionCalls;
    setState({
      assertionCalls: assertionCalls + 1
    }, _expect);
    var assert = expect(value, message);
    var _test = test || getCurrentTest();
    if (_test)
      // @ts-expect-error internal
      return assert.withTest(_test);else return assert;
  };
  Object.assign(_expect, expect);
  Object.assign(_expect, globalThis[ASYMMETRIC_MATCHERS_OBJECT]);
  _expect.getState = function () {
    return getState(_expect);
  };
  _expect.setState = function (state) {
    return setState(state, _expect);
  };
  // @ts-expect-error global is not typed
  var globalState = getState(globalThis[GLOBAL_EXPECT]) || {};
  setState(_objectSpread(_objectSpread({}, globalState), {}, {
    assertionCalls: 0,
    isExpectingAssertions: false,
    isExpectingAssertionsError: null,
    expectedAssertionsNumber: null,
    expectedAssertionsNumberErrorGen: null,
    environment: getCurrentEnvironment(),
    get testPath() {
      return getWorkerState().filepath;
    },
    currentTestName: test ? getTestName(test) : globalState.currentTestName
  }), _expect);
  // @ts-expect-error untyped
  _expect.extend = function (matchers) {
    return expect.extend(_expect, matchers);
  };
  _expect.addEqualityTesters = function (customTesters) {
    return addCustomEqualityTesters(customTesters);
  };
  _expect.soft = function () {
    // @ts-expect-error private soft access
    return _expect.apply(void 0, arguments).withContext({
      soft: true
    });
  };
  _expect.poll = createExpectPoll(_expect);
  _expect.unreachable = function (message) {
    assert$1.fail("expected".concat(message ? " \"".concat(message, "\" ") : " ", "not to be reached"));
  };
  function assertions(expected) {
    var errorGen = function errorGen() {
      return new Error("expected number of assertions to be ".concat(expected, ", but got ").concat(_expect.getState().assertionCalls));
    };
    if (Error.captureStackTrace) Error.captureStackTrace(errorGen(), assertions);
    _expect.setState({
      expectedAssertionsNumber: expected,
      expectedAssertionsNumberErrorGen: errorGen
    });
  }
  function hasAssertions() {
    var error = new Error("expected any number of assertion, but got none");
    if (Error.captureStackTrace) Error.captureStackTrace(error, hasAssertions);
    _expect.setState({
      isExpectingAssertions: true,
      isExpectingAssertionsError: error
    });
  }
  utils_exports.addMethod(_expect, "assertions", assertions);
  utils_exports.addMethod(_expect, "hasAssertions", hasAssertions);
  _expect.extend(customMatchers);
  return _expect;
}
var globalExpect = createExpect();
Object.defineProperty(globalThis, GLOBAL_EXPECT, {
  value: globalExpect,
  writable: true,
  configurable: true
});
var fakeTimersSrc = {};
var global$1;
var hasRequiredGlobal;
function requireGlobal() {
  if (hasRequiredGlobal) return global$1;
  hasRequiredGlobal = 1;

  /**
   * A reference to the global object
   * @type {object} globalObject
   */
  var globalObject;

  /* istanbul ignore else */
  if (typeof commonjsGlobal !== "undefined") {
    // Node
    globalObject = commonjsGlobal;
  } else if (typeof window !== "undefined") {
    // Browser
    globalObject = window;
  } else {
    // WebWorker
    globalObject = self;
  }
  global$1 = globalObject;
  return global$1;
}
var throwsOnProto_1;
var hasRequiredThrowsOnProto;
function requireThrowsOnProto() {
  if (hasRequiredThrowsOnProto) return throwsOnProto_1;
  hasRequiredThrowsOnProto = 1;

  /**
   * Is true when the environment causes an error to be thrown for accessing the
   * __proto__ property.
   * This is necessary in order to support `node --disable-proto=throw`.
   *
   * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto
   * @type {boolean}
   */
  var throwsOnProto;
  try {
    var _object = {};
    // eslint-disable-next-line no-proto, no-unused-expressions
    _object.__proto__;
    throwsOnProto = false;
  } catch (_) {
    // This branch is covered when tests are run with `--disable-proto=throw`,
    // however we can test both branches at the same time, so this is ignored
    /* istanbul ignore next */
    throwsOnProto = true;
  }
  throwsOnProto_1 = throwsOnProto;
  return throwsOnProto_1;
}
var copyPrototypeMethods;
var hasRequiredCopyPrototypeMethods;
function requireCopyPrototypeMethods() {
  if (hasRequiredCopyPrototypeMethods) return copyPrototypeMethods;
  hasRequiredCopyPrototypeMethods = 1;
  var call = Function.call;
  var throwsOnProto = requireThrowsOnProto();
  var disallowedProperties = [
  // ignore size because it throws from Map
  "size", "caller", "callee", "arguments"];

  // This branch is covered when tests are run with `--disable-proto=throw`,
  // however we can test both branches at the same time, so this is ignored
  /* istanbul ignore next */
  if (throwsOnProto) {
    disallowedProperties.push("__proto__");
  }
  copyPrototypeMethods = function copyPrototypeMethods(prototype) {
    // eslint-disable-next-line @sinonjs/no-prototype-methods/no-prototype-methods
    return Object.getOwnPropertyNames(prototype).reduce(function (result, name) {
      if (disallowedProperties.includes(name)) {
        return result;
      }
      if (typeof prototype[name] !== "function") {
        return result;
      }
      result[name] = call.bind(prototype[name]);
      return result;
    }, Object.create(null));
  };
  return copyPrototypeMethods;
}
var array;
var hasRequiredArray;
function requireArray() {
  if (hasRequiredArray) return array;
  hasRequiredArray = 1;
  var copyPrototype = requireCopyPrototypeMethods();
  array = copyPrototype(Array.prototype);
  return array;
}
var calledInOrder_1;
var hasRequiredCalledInOrder;
function requireCalledInOrder() {
  if (hasRequiredCalledInOrder) return calledInOrder_1;
  hasRequiredCalledInOrder = 1;
  var every = requireArray().every;

  /**
   * @private
   */
  function hasCallsLeft(callMap, spy) {
    if (callMap[spy.id] === undefined) {
      callMap[spy.id] = 0;
    }
    return callMap[spy.id] < spy.callCount;
  }

  /**
   * @private
   */
  function checkAdjacentCalls(callMap, spy, index, spies) {
    var calledBeforeNext = true;
    if (index !== spies.length - 1) {
      calledBeforeNext = spy.calledBefore(spies[index + 1]);
    }
    if (hasCallsLeft(callMap, spy) && calledBeforeNext) {
      callMap[spy.id] += 1;
      return true;
    }
    return false;
  }

  /**
   * A Sinon proxy object (fake, spy, stub)
   * @typedef {object} SinonProxy
   * @property {Function} calledBefore - A method that determines if this proxy was called before another one
   * @property {string} id - Some id
   * @property {number} callCount - Number of times this proxy has been called
   */

  /**
   * Returns true when the spies have been called in the order they were supplied in
   * @param  {SinonProxy[] | SinonProxy} spies An array of proxies, or several proxies as arguments
   * @returns {boolean} true when spies are called in order, false otherwise
   */
  function calledInOrder(spies) {
    var callMap = {};
    // eslint-disable-next-line no-underscore-dangle
    var _spies = arguments.length > 1 ? arguments : spies;
    return every(_spies, checkAdjacentCalls.bind(null, callMap));
  }
  calledInOrder_1 = calledInOrder;
  return calledInOrder_1;
}
var className_1;
var hasRequiredClassName;
function requireClassName() {
  if (hasRequiredClassName) return className_1;
  hasRequiredClassName = 1;

  /**
   * Returns a display name for a value from a constructor
   * @param  {object} value A value to examine
   * @returns {(string|null)} A string or null
   */
  function className(value) {
    var name = value.constructor && value.constructor.name;
    return name || null;
  }
  className_1 = className;
  return className_1;
}
var deprecated = {};

/* eslint-disable no-console */

var hasRequiredDeprecated;
function requireDeprecated() {
  if (hasRequiredDeprecated) return deprecated;
  hasRequiredDeprecated = 1;
  (function (exports) {
    /**
     * Returns a function that will invoke the supplied function and print a
     * deprecation warning to the console each time it is called.
     * @param  {Function} func
     * @param  {string} msg
     * @returns {Function}
     */
    exports.wrap = function (func, msg) {
      var wrapped = function wrapped() {
        exports.printWarning(msg);
        return func.apply(this, arguments);
      };
      if (func.prototype) {
        wrapped.prototype = func.prototype;
      }
      return wrapped;
    };

    /**
     * Returns a string which can be supplied to `wrap()` to notify the user that a
     * particular part of the sinon API has been deprecated.
     * @param  {string} packageName
     * @param  {string} funcName
     * @returns {string}
     */
    exports.defaultMsg = function (packageName, funcName) {
      return "".concat(packageName, ".").concat(funcName, " is deprecated and will be removed from the public API in a future version of ").concat(packageName, ".");
    };

    /**
     * Prints a warning on the console, when it exists
     * @param  {string} msg
     * @returns {undefined}
     */
    exports.printWarning = function (msg) {
      /* istanbul ignore next */
      if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && process.emitWarning) {
        // Emit Warnings in Node
        process.emitWarning(msg);
      } else if (console.info) {
        console.info(msg);
      } else {
        console.log(msg);
      }
    };
  })(deprecated);
  return deprecated;
}
var every;
var hasRequiredEvery;
function requireEvery() {
  if (hasRequiredEvery) return every;
  hasRequiredEvery = 1;

  /**
   * Returns true when fn returns true for all members of obj.
   * This is an every implementation that works for all iterables
   * @param  {object}   obj
   * @param  {Function} fn
   * @returns {boolean}
   */
  every = function every(obj, fn) {
    var pass = true;
    try {
      // eslint-disable-next-line @sinonjs/no-prototype-methods/no-prototype-methods
      obj.forEach(function () {
        if (!fn.apply(this, arguments)) {
          // Throwing an error is the only way to break `forEach`
          throw new Error();
        }
      });
    } catch (e) {
      pass = false;
    }
    return pass;
  };
  return every;
}
var functionName;
var hasRequiredFunctionName;
function requireFunctionName() {
  if (hasRequiredFunctionName) return functionName;
  hasRequiredFunctionName = 1;

  /**
   * Returns a display name for a function
   * @param  {Function} func
   * @returns {string}
   */
  functionName = function functionName(func) {
    if (!func) {
      return "";
    }
    try {
      return func.displayName || func.name ||
      // Use function decomposition as a last resort to get function
      // name. Does not rely on function decomposition to work - if it
      // doesn't debugging will be slightly less informative
      // (i.e. toString will say 'spy' rather than 'myFunc').
      (String(func).match(/function ([^\s(]+)/) || [])[1];
    } catch (e) {
      // Stringify may fail and we might get an exception, as a last-last
      // resort fall back to empty string.
      return "";
    }
  };
  return functionName;
}
var orderByFirstCall_1;
var hasRequiredOrderByFirstCall;
function requireOrderByFirstCall() {
  if (hasRequiredOrderByFirstCall) return orderByFirstCall_1;
  hasRequiredOrderByFirstCall = 1;
  var sort = requireArray().sort;
  var slice = requireArray().slice;

  /**
   * @private
   */
  function comparator(a, b) {
    // uuid, won't ever be equal
    var aCall = a.getCall(0);
    var bCall = b.getCall(0);
    var aId = aCall && aCall.callId || -1;
    var bId = bCall && bCall.callId || -1;
    return aId < bId ? -1 : 1;
  }

  /**
   * A Sinon proxy object (fake, spy, stub)
   * @typedef {object} SinonProxy
   * @property {Function} getCall - A method that can return the first call
   */

  /**
   * Sorts an array of SinonProxy instances (fake, spy, stub) by their first call
   * @param  {SinonProxy[] | SinonProxy} spies
   * @returns {SinonProxy[]}
   */
  function orderByFirstCall(spies) {
    return sort(slice(spies), comparator);
  }
  orderByFirstCall_1 = orderByFirstCall;
  return orderByFirstCall_1;
}
var _function;
var hasRequired_function;
function require_function() {
  if (hasRequired_function) return _function;
  hasRequired_function = 1;
  var copyPrototype = requireCopyPrototypeMethods();
  _function = copyPrototype(Function.prototype);
  return _function;
}
var map;
var hasRequiredMap;
function requireMap() {
  if (hasRequiredMap) return map;
  hasRequiredMap = 1;
  var copyPrototype = requireCopyPrototypeMethods();
  map = copyPrototype(Map.prototype);
  return map;
}
var object;
var hasRequiredObject;
function requireObject() {
  if (hasRequiredObject) return object;
  hasRequiredObject = 1;
  var copyPrototype = requireCopyPrototypeMethods();
  object = copyPrototype(Object.prototype);
  return object;
}
var set;
var hasRequiredSet;
function requireSet() {
  if (hasRequiredSet) return set;
  hasRequiredSet = 1;
  var copyPrototype = requireCopyPrototypeMethods();
  set = copyPrototype(Set.prototype);
  return set;
}
var string;
var hasRequiredString;
function requireString() {
  if (hasRequiredString) return string;
  hasRequiredString = 1;
  var copyPrototype = requireCopyPrototypeMethods();
  string = copyPrototype(String.prototype);
  return string;
}
var prototypes;
var hasRequiredPrototypes;
function requirePrototypes() {
  if (hasRequiredPrototypes) return prototypes;
  hasRequiredPrototypes = 1;
  prototypes = {
    array: requireArray(),
    function: require_function(),
    map: requireMap(),
    object: requireObject(),
    set: requireSet(),
    string: requireString()
  };
  return prototypes;
}
var typeDetect$1 = {
  exports: {}
};
var typeDetect = typeDetect$1.exports;
var hasRequiredTypeDetect;
function requireTypeDetect() {
  if (hasRequiredTypeDetect) return typeDetect$1.exports;
  hasRequiredTypeDetect = 1;
  (function (module, exports) {
    (function (global, factory) {
      module.exports = factory();
    })(typeDetect, function () {
      /* !
       * type-detect
       * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
       * MIT Licensed
       */
      var promiseExists = typeof Promise === 'function';

      /* eslint-disable no-undef */
      var globalObject = (typeof self === "undefined" ? "undefined" : _typeof(self)) === 'object' ? self : commonjsGlobal; // eslint-disable-line id-blacklist

      var symbolExists = typeof Symbol !== 'undefined';
      var mapExists = typeof Map !== 'undefined';
      var setExists = typeof Set !== 'undefined';
      var weakMapExists = typeof WeakMap !== 'undefined';
      var weakSetExists = typeof WeakSet !== 'undefined';
      var dataViewExists = typeof DataView !== 'undefined';
      var symbolIteratorExists = symbolExists && typeof Symbol.iterator !== 'undefined';
      var symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== 'undefined';
      var setEntriesExists = setExists && typeof Set.prototype.entries === 'function';
      var mapEntriesExists = mapExists && typeof Map.prototype.entries === 'function';
      var setIteratorPrototype = setEntriesExists && Object.getPrototypeOf(new Set().entries());
      var mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf(new Map().entries());
      var arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';
      var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());
      var stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] === 'function';
      var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(''[Symbol.iterator]());
      var toStringLeftSliceLength = 8;
      var toStringRightSliceLength = -1;
      /**
       * ### typeOf (obj)
       *
       * Uses `Object.prototype.toString` to determine the type of an object,
       * normalising behaviour across engine versions & well optimised.
       *
       * @param {Mixed} object
       * @return {String} object type
       * @api public
       */
      function typeDetect(obj) {
        /* ! Speed optimisation
         * Pre:
         *   string literal     x 3,039,035 ops/sec ±1.62% (78 runs sampled)
         *   boolean literal    x 1,424,138 ops/sec ±4.54% (75 runs sampled)
         *   number literal     x 1,653,153 ops/sec ±1.91% (82 runs sampled)
         *   undefined          x 9,978,660 ops/sec ±1.92% (75 runs sampled)
         *   function           x 2,556,769 ops/sec ±1.73% (77 runs sampled)
         * Post:
         *   string literal     x 38,564,796 ops/sec ±1.15% (79 runs sampled)
         *   boolean literal    x 31,148,940 ops/sec ±1.10% (79 runs sampled)
         *   number literal     x 32,679,330 ops/sec ±1.90% (78 runs sampled)
         *   undefined          x 32,363,368 ops/sec ±1.07% (82 runs sampled)
         *   function           x 31,296,870 ops/sec ±0.96% (83 runs sampled)
         */
        var typeofObj = _typeof(obj);
        if (typeofObj !== 'object') {
          return typeofObj;
        }

        /* ! Speed optimisation
         * Pre:
         *   null               x 28,645,765 ops/sec ±1.17% (82 runs sampled)
         * Post:
         *   null               x 36,428,962 ops/sec ±1.37% (84 runs sampled)
         */
        if (obj === null) {
          return 'null';
        }

        /* ! Spec Conformance
         * Test: `Object.prototype.toString.call(window)``
         *  - Node === "[object global]"
         *  - Chrome === "[object global]"
         *  - Firefox === "[object Window]"
         *  - PhantomJS === "[object Window]"
         *  - Safari === "[object Window]"
         *  - IE 11 === "[object Window]"
         *  - IE Edge === "[object Window]"
         * Test: `Object.prototype.toString.call(this)``
         *  - Chrome Worker === "[object global]"
         *  - Firefox Worker === "[object DedicatedWorkerGlobalScope]"
         *  - Safari Worker === "[object DedicatedWorkerGlobalScope]"
         *  - IE 11 Worker === "[object WorkerGlobalScope]"
         *  - IE Edge Worker === "[object WorkerGlobalScope]"
         */
        if (obj === globalObject) {
          return 'global';
        }

        /* ! Speed optimisation
         * Pre:
         *   array literal      x 2,888,352 ops/sec ±0.67% (82 runs sampled)
         * Post:
         *   array literal      x 22,479,650 ops/sec ±0.96% (81 runs sampled)
         */
        if (Array.isArray(obj) && (symbolToStringTagExists === false || !(Symbol.toStringTag in obj))) {
          return 'Array';
        }

        // Not caching existence of `window` and related properties due to potential
        // for `window` to be unset before tests in quasi-browser environments.
        if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object' && window !== null) {
          /* ! Spec Conformance
           * (https://html.spec.whatwg.org/multipage/browsers.html#location)
           * WhatWG HTML$7.7.3 - The `Location` interface
           * Test: `Object.prototype.toString.call(window.location)``
           *  - IE <=11 === "[object Object]"
           *  - IE Edge <=13 === "[object Object]"
           */
          if (_typeof(window.location) === 'object' && obj === window.location) {
            return 'Location';
          }

          /* ! Spec Conformance
           * (https://html.spec.whatwg.org/#document)
           * WhatWG HTML$3.1.1 - The `Document` object
           * Note: Most browsers currently adher to the W3C DOM Level 2 spec
           *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)
           *       which suggests that browsers should use HTMLTableCellElement for
           *       both TD and TH elements. WhatWG separates these.
           *       WhatWG HTML states:
           *         > For historical reasons, Window objects must also have a
           *         > writable, configurable, non-enumerable property named
           *         > HTMLDocument whose value is the Document interface object.
           * Test: `Object.prototype.toString.call(document)``
           *  - Chrome === "[object HTMLDocument]"
           *  - Firefox === "[object HTMLDocument]"
           *  - Safari === "[object HTMLDocument]"
           *  - IE <=10 === "[object Document]"
           *  - IE 11 === "[object HTMLDocument]"
           *  - IE Edge <=13 === "[object HTMLDocument]"
           */
          if (_typeof(window.document) === 'object' && obj === window.document) {
            return 'Document';
          }
          if (_typeof(window.navigator) === 'object') {
            /* ! Spec Conformance
             * (https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)
             * WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray
             * Test: `Object.prototype.toString.call(navigator.mimeTypes)``
             *  - IE <=10 === "[object MSMimeTypesCollection]"
             */
            if (_typeof(window.navigator.mimeTypes) === 'object' && obj === window.navigator.mimeTypes) {
              return 'MimeTypeArray';
            }

            /* ! Spec Conformance
             * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
             * WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray
             * Test: `Object.prototype.toString.call(navigator.plugins)``
             *  - IE <=10 === "[object MSPluginsCollection]"
             */
            if (_typeof(window.navigator.plugins) === 'object' && obj === window.navigator.plugins) {
              return 'PluginArray';
            }
          }
          if ((typeof window.HTMLElement === 'function' || _typeof(window.HTMLElement) === 'object') && obj instanceof window.HTMLElement) {
            /* ! Spec Conformance
            * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
            * WhatWG HTML$4.4.4 - The `blockquote` element - Interface `HTMLQuoteElement`
            * Test: `Object.prototype.toString.call(document.createElement('blockquote'))``
            *  - IE <=10 === "[object HTMLBlockElement]"
            */
            if (obj.tagName === 'BLOCKQUOTE') {
              return 'HTMLQuoteElement';
            }

            /* ! Spec Conformance
             * (https://html.spec.whatwg.org/#htmltabledatacellelement)
             * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableDataCellElement`
             * Note: Most browsers currently adher to the W3C DOM Level 2 spec
             *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
             *       which suggests that browsers should use HTMLTableCellElement for
             *       both TD and TH elements. WhatWG separates these.
             * Test: Object.prototype.toString.call(document.createElement('td'))
             *  - Chrome === "[object HTMLTableCellElement]"
             *  - Firefox === "[object HTMLTableCellElement]"
             *  - Safari === "[object HTMLTableCellElement]"
             */
            if (obj.tagName === 'TD') {
              return 'HTMLTableDataCellElement';
            }

            /* ! Spec Conformance
             * (https://html.spec.whatwg.org/#htmltableheadercellelement)
             * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableHeaderCellElement`
             * Note: Most browsers currently adher to the W3C DOM Level 2 spec
             *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
             *       which suggests that browsers should use HTMLTableCellElement for
             *       both TD and TH elements. WhatWG separates these.
             * Test: Object.prototype.toString.call(document.createElement('th'))
             *  - Chrome === "[object HTMLTableCellElement]"
             *  - Firefox === "[object HTMLTableCellElement]"
             *  - Safari === "[object HTMLTableCellElement]"
             */
            if (obj.tagName === 'TH') {
              return 'HTMLTableHeaderCellElement';
            }
          }
        }

        /* ! Speed optimisation
        * Pre:
        *   Float64Array       x 625,644 ops/sec ±1.58% (80 runs sampled)
        *   Float32Array       x 1,279,852 ops/sec ±2.91% (77 runs sampled)
        *   Uint32Array        x 1,178,185 ops/sec ±1.95% (83 runs sampled)
        *   Uint16Array        x 1,008,380 ops/sec ±2.25% (80 runs sampled)
        *   Uint8Array         x 1,128,040 ops/sec ±2.11% (81 runs sampled)
        *   Int32Array         x 1,170,119 ops/sec ±2.88% (80 runs sampled)
        *   Int16Array         x 1,176,348 ops/sec ±5.79% (86 runs sampled)
        *   Int8Array          x 1,058,707 ops/sec ±4.94% (77 runs sampled)
        *   Uint8ClampedArray  x 1,110,633 ops/sec ±4.20% (80 runs sampled)
        * Post:
        *   Float64Array       x 7,105,671 ops/sec ±13.47% (64 runs sampled)
        *   Float32Array       x 5,887,912 ops/sec ±1.46% (82 runs sampled)
        *   Uint32Array        x 6,491,661 ops/sec ±1.76% (79 runs sampled)
        *   Uint16Array        x 6,559,795 ops/sec ±1.67% (82 runs sampled)
        *   Uint8Array         x 6,463,966 ops/sec ±1.43% (85 runs sampled)
        *   Int32Array         x 5,641,841 ops/sec ±3.49% (81 runs sampled)
        *   Int16Array         x 6,583,511 ops/sec ±1.98% (80 runs sampled)
        *   Int8Array          x 6,606,078 ops/sec ±1.74% (81 runs sampled)
        *   Uint8ClampedArray  x 6,602,224 ops/sec ±1.77% (83 runs sampled)
        */
        var stringTag = symbolToStringTagExists && obj[Symbol.toStringTag];
        if (typeof stringTag === 'string') {
          return stringTag;
        }
        var objPrototype = Object.getPrototypeOf(obj);
        /* ! Speed optimisation
        * Pre:
        *   regex literal      x 1,772,385 ops/sec ±1.85% (77 runs sampled)
        *   regex constructor  x 2,143,634 ops/sec ±2.46% (78 runs sampled)
        * Post:
        *   regex literal      x 3,928,009 ops/sec ±0.65% (78 runs sampled)
        *   regex constructor  x 3,931,108 ops/sec ±0.58% (84 runs sampled)
        */
        if (objPrototype === RegExp.prototype) {
          return 'RegExp';
        }

        /* ! Speed optimisation
        * Pre:
        *   date               x 2,130,074 ops/sec ±4.42% (68 runs sampled)
        * Post:
        *   date               x 3,953,779 ops/sec ±1.35% (77 runs sampled)
        */
        if (objPrototype === Date.prototype) {
          return 'Date';
        }

        /* ! Spec Conformance
         * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)
         * ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be "Promise":
         * Test: `Object.prototype.toString.call(Promise.resolve())``
         *  - Chrome <=47 === "[object Object]"
         *  - Edge <=20 === "[object Object]"
         *  - Firefox 29-Latest === "[object Promise]"
         *  - Safari 7.1-Latest === "[object Promise]"
         */
        if (promiseExists && objPrototype === Promise.prototype) {
          return 'Promise';
        }

        /* ! Speed optimisation
        * Pre:
        *   set                x 2,222,186 ops/sec ±1.31% (82 runs sampled)
        * Post:
        *   set                x 4,545,879 ops/sec ±1.13% (83 runs sampled)
        */
        if (setExists && objPrototype === Set.prototype) {
          return 'Set';
        }

        /* ! Speed optimisation
        * Pre:
        *   map                x 2,396,842 ops/sec ±1.59% (81 runs sampled)
        * Post:
        *   map                x 4,183,945 ops/sec ±6.59% (82 runs sampled)
        */
        if (mapExists && objPrototype === Map.prototype) {
          return 'Map';
        }

        /* ! Speed optimisation
        * Pre:
        *   weakset            x 1,323,220 ops/sec ±2.17% (76 runs sampled)
        * Post:
        *   weakset            x 4,237,510 ops/sec ±2.01% (77 runs sampled)
        */
        if (weakSetExists && objPrototype === WeakSet.prototype) {
          return 'WeakSet';
        }

        /* ! Speed optimisation
        * Pre:
        *   weakmap            x 1,500,260 ops/sec ±2.02% (78 runs sampled)
        * Post:
        *   weakmap            x 3,881,384 ops/sec ±1.45% (82 runs sampled)
        */
        if (weakMapExists && objPrototype === WeakMap.prototype) {
          return 'WeakMap';
        }

        /* ! Spec Conformance
         * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)
         * ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be "DataView":
         * Test: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))``
         *  - Edge <=13 === "[object Object]"
         */
        if (dataViewExists && objPrototype === DataView.prototype) {
          return 'DataView';
        }

        /* ! Spec Conformance
         * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)
         * ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be "Map Iterator":
         * Test: `Object.prototype.toString.call(new Map().entries())``
         *  - Edge <=13 === "[object Object]"
         */
        if (mapExists && objPrototype === mapIteratorPrototype) {
          return 'Map Iterator';
        }

        /* ! Spec Conformance
         * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)
         * ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be "Set Iterator":
         * Test: `Object.prototype.toString.call(new Set().entries())``
         *  - Edge <=13 === "[object Object]"
         */
        if (setExists && objPrototype === setIteratorPrototype) {
          return 'Set Iterator';
        }

        /* ! Spec Conformance
         * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)
         * ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be "Array Iterator":
         * Test: `Object.prototype.toString.call([][Symbol.iterator]())``
         *  - Edge <=13 === "[object Object]"
         */
        if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {
          return 'Array Iterator';
        }

        /* ! Spec Conformance
         * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)
         * ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be "String Iterator":
         * Test: `Object.prototype.toString.call(''[Symbol.iterator]())``
         *  - Edge <=13 === "[object Object]"
         */
        if (stringIteratorExists && objPrototype === stringIteratorPrototype) {
          return 'String Iterator';
        }

        /* ! Speed optimisation
        * Pre:
        *   object from null   x 2,424,320 ops/sec ±1.67% (76 runs sampled)
        * Post:
        *   object from null   x 5,838,000 ops/sec ±0.99% (84 runs sampled)
        */
        if (objPrototype === null) {
          return 'Object';
        }
        return Object.prototype.toString.call(obj).slice(toStringLeftSliceLength, toStringRightSliceLength);
      }
      return typeDetect;
    });
  })(typeDetect$1);
  return typeDetect$1.exports;
}
var typeOf;
var hasRequiredTypeOf;
function requireTypeOf() {
  if (hasRequiredTypeOf) return typeOf;
  hasRequiredTypeOf = 1;
  var type = requireTypeDetect();

  /**
   * Returns the lower-case result of running type from type-detect on the value
   * @param  {*} value
   * @returns {string}
   */
  typeOf = function typeOf(value) {
    return type(value).toLowerCase();
  };
  return typeOf;
}
var valueToString_1;
var hasRequiredValueToString;
function requireValueToString() {
  if (hasRequiredValueToString) return valueToString_1;
  hasRequiredValueToString = 1;

  /**
   * Returns a string representation of the value
   * @param  {*} value
   * @returns {string}
   */
  function valueToString(value) {
    if (value && value.toString) {
      // eslint-disable-next-line @sinonjs/no-prototype-methods/no-prototype-methods
      return value.toString();
    }
    return String(value);
  }
  valueToString_1 = valueToString;
  return valueToString_1;
}
var lib;
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  lib = {
    global: requireGlobal(),
    calledInOrder: requireCalledInOrder(),
    className: requireClassName(),
    deprecated: requireDeprecated(),
    every: requireEvery(),
    functionName: requireFunctionName(),
    orderByFirstCall: requireOrderByFirstCall(),
    prototypes: requirePrototypes(),
    typeOf: requireTypeOf(),
    valueToString: requireValueToString()
  };
  return lib;
}
var hasRequiredFakeTimersSrc;
function requireFakeTimersSrc() {
  if (hasRequiredFakeTimersSrc) return fakeTimersSrc;
  hasRequiredFakeTimersSrc = 1;
  var globalObject = requireLib().global;
  var timersModule, timersPromisesModule;
  if (typeof __vitest_required__ !== 'undefined') {
    try {
      timersModule = __vitest_required__.timers;
    } catch (e) {
      // ignored
    }
    try {
      timersPromisesModule = __vitest_required__.timersPromises;
    } catch (e) {
      // ignored
    }
  }

  /**
   * @typedef {object} IdleDeadline
   * @property {boolean} didTimeout - whether or not the callback was called before reaching the optional timeout
   * @property {function():number} timeRemaining - a floating-point value providing an estimate of the number of milliseconds remaining in the current idle period
   */

  /**
   * Queues a function to be called during a browser's idle periods
   * @callback RequestIdleCallback
   * @param {function(IdleDeadline)} callback
   * @param {{timeout: number}} options - an options object
   * @returns {number} the id
   */

  /**
   * @callback NextTick
   * @param {VoidVarArgsFunc} callback - the callback to run
   * @param {...*} args - optional arguments to call the callback with
   * @returns {void}
   */

  /**
   * @callback SetImmediate
   * @param {VoidVarArgsFunc} callback - the callback to run
   * @param {...*} args - optional arguments to call the callback with
   * @returns {NodeImmediate}
   */

  /**
   * @callback VoidVarArgsFunc
   * @param {...*} callback - the callback to run
   * @returns {void}
   */

  /**
   * @typedef RequestAnimationFrame
   * @property {function(number):void} requestAnimationFrame
   * @returns {number} - the id
   */

  /**
   * @typedef Performance
   * @property {function(): number} now
   */

  /* eslint-disable jsdoc/require-property-description */
  /**
   * @typedef {object} Clock
   * @property {number} now - the current time
   * @property {Date} Date - the Date constructor
   * @property {number} loopLimit - the maximum number of timers before assuming an infinite loop
   * @property {RequestIdleCallback} requestIdleCallback
   * @property {function(number):void} cancelIdleCallback
   * @property {setTimeout} setTimeout
   * @property {clearTimeout} clearTimeout
   * @property {NextTick} nextTick
   * @property {queueMicrotask} queueMicrotask
   * @property {setInterval} setInterval
   * @property {clearInterval} clearInterval
   * @property {SetImmediate} setImmediate
   * @property {function(NodeImmediate):void} clearImmediate
   * @property {function():number} countTimers
   * @property {RequestAnimationFrame} requestAnimationFrame
   * @property {function(number):void} cancelAnimationFrame
   * @property {function():void} runMicrotasks
   * @property {function(string | number): number} tick
   * @property {function(string | number): Promise<number>} tickAsync
   * @property {function(): number} next
   * @property {function(): Promise<number>} nextAsync
   * @property {function(): number} runAll
   * @property {function(): number} runToFrame
   * @property {function(): Promise<number>} runAllAsync
   * @property {function(): number} runToLast
   * @property {function(): Promise<number>} runToLastAsync
   * @property {function(): void} reset
   * @property {function(number | Date): void} setSystemTime
   * @property {function(number): void} jump
   * @property {Performance} performance
   * @property {function(number[]): number[]} hrtime - process.hrtime (legacy)
   * @property {function(): void} uninstall Uninstall the clock.
   * @property {Function[]} methods - the methods that are faked
   * @property {boolean} [shouldClearNativeTimers] inherited from config
   * @property {{methodName:string, original:any}[] | undefined} timersModuleMethods
   * @property {{methodName:string, original:any}[] | undefined} timersPromisesModuleMethods
   * @property {Map<function(): void, AbortSignal>} abortListenerMap
   */
  /* eslint-enable jsdoc/require-property-description */

  /**
   * Configuration object for the `install` method.
   * @typedef {object} Config
   * @property {number|Date} [now] a number (in milliseconds) or a Date object (default epoch)
   * @property {string[]} [toFake] names of the methods that should be faked.
   * @property {number} [loopLimit] the maximum number of timers that will be run when calling runAll()
   * @property {boolean} [shouldAdvanceTime] tells FakeTimers to increment mocked time automatically (default false)
   * @property {number} [advanceTimeDelta] increment mocked time every <<advanceTimeDelta>> ms (default: 20ms)
   * @property {boolean} [shouldClearNativeTimers] forwards clear timer calls to native functions if they are not fakes (default: false)
   * @property {boolean} [ignoreMissingTimers] default is false, meaning asking to fake timers that are not present will throw an error
   */

  /* eslint-disable jsdoc/require-property-description */
  /**
   * The internal structure to describe a scheduled fake timer
   * @typedef {object} Timer
   * @property {Function} func
   * @property {*[]} args
   * @property {number} delay
   * @property {number} callAt
   * @property {number} createdAt
   * @property {boolean} immediate
   * @property {number} id
   * @property {Error} [error]
   */

  /**
   * A Node timer
   * @typedef {object} NodeImmediate
   * @property {function(): boolean} hasRef
   * @property {function(): NodeImmediate} ref
   * @property {function(): NodeImmediate} unref
   */
  /* eslint-enable jsdoc/require-property-description */

  /* eslint-disable complexity */

  /**
   * Mocks available features in the specified global namespace.
   * @param {*} _global Namespace to mock (e.g. `window`)
   * @returns {FakeTimers}
   */
  function withGlobal(_global) {
    var maxTimeout = Math.pow(2, 31) - 1; //see https://heycam.github.io/webidl/#abstract-opdef-converttoint
    var idCounterStart = 1e12; // arbitrarily large number to avoid collisions with native timer IDs
    var NOOP = function NOOP() {
      return undefined;
    };
    var NOOP_ARRAY = function NOOP_ARRAY() {
      return [];
    };
    var isPresent = {};
    var timeoutResult,
      addTimerReturnsObject = false;
    if (_global.setTimeout) {
      isPresent.setTimeout = true;
      timeoutResult = _global.setTimeout(NOOP, 0);
      addTimerReturnsObject = _typeof(timeoutResult) === "object";
    }
    isPresent.clearTimeout = Boolean(_global.clearTimeout);
    isPresent.setInterval = Boolean(_global.setInterval);
    isPresent.clearInterval = Boolean(_global.clearInterval);
    isPresent.hrtime = _global.process && typeof _global.process.hrtime === "function";
    isPresent.hrtimeBigint = isPresent.hrtime && typeof _global.process.hrtime.bigint === "function";
    isPresent.nextTick = _global.process && typeof _global.process.nextTick === "function";
    var utilPromisify = _global.process && _global.__vitest_required__ && _global.__vitest_required__.util.promisify;
    isPresent.performance = _global.performance && typeof _global.performance.now === "function";
    var hasPerformancePrototype = _global.Performance && _typeof(_global.Performance).match(/^(function|object)$/);
    var hasPerformanceConstructorPrototype = _global.performance && _global.performance.constructor && _global.performance.constructor.prototype;
    isPresent.queueMicrotask = _global.hasOwnProperty("queueMicrotask");
    isPresent.requestAnimationFrame = _global.requestAnimationFrame && typeof _global.requestAnimationFrame === "function";
    isPresent.cancelAnimationFrame = _global.cancelAnimationFrame && typeof _global.cancelAnimationFrame === "function";
    isPresent.requestIdleCallback = _global.requestIdleCallback && typeof _global.requestIdleCallback === "function";
    isPresent.cancelIdleCallbackPresent = _global.cancelIdleCallback && typeof _global.cancelIdleCallback === "function";
    isPresent.setImmediate = _global.setImmediate && typeof _global.setImmediate === "function";
    isPresent.clearImmediate = _global.clearImmediate && typeof _global.clearImmediate === "function";
    isPresent.Intl = _global.Intl && _typeof(_global.Intl) === "object";
    if (_global.clearTimeout) {
      _global.clearTimeout(timeoutResult);
    }
    var NativeDate = _global.Date;
    var NativeIntl = isPresent.Intl ? Object.defineProperties(Object.create(null), Object.getOwnPropertyDescriptors(_global.Intl)) : undefined;
    var uniqueTimerId = idCounterStart;
    if (NativeDate === undefined) {
      throw new Error("The global scope doesn't have a `Date` object" + " (see https://github.com/sinonjs/sinon/issues/1852#issuecomment-419622780)");
    }
    isPresent.Date = true;

    /**
     * The PerformanceEntry object encapsulates a single performance metric
     * that is part of the browser's performance timeline.
     *
     * This is an object returned by the `mark` and `measure` methods on the Performance prototype
     */
    var FakePerformanceEntry = /*#__PURE__*/function () {
      function FakePerformanceEntry(name, entryType, startTime, duration) {
        _classCallCheck(this, FakePerformanceEntry);
        this.name = name;
        this.entryType = entryType;
        this.startTime = startTime;
        this.duration = duration;
      }
      return _createClass(FakePerformanceEntry, [{
        key: "toJSON",
        value: function toJSON() {
          return JSON.stringify(_objectSpread({}, this));
        }
      }]);
    }();
    /**
     * @param {number} num
     * @returns {boolean}
     */
    function isNumberFinite(num) {
      if (Number.isFinite) {
        return Number.isFinite(num);
      }
      return isFinite(num);
    }
    var isNearInfiniteLimit = false;

    /**
     * @param {Clock} clock
     * @param {number} i
     */
    function checkIsNearInfiniteLimit(clock, i) {
      if (clock.loopLimit && i === clock.loopLimit - 1) {
        isNearInfiniteLimit = true;
      }
    }

    /**
     *
     */
    function resetIsNearInfiniteLimit() {
      isNearInfiniteLimit = false;
    }

    /**
     * Parse strings like "01:10:00" (meaning 1 hour, 10 minutes, 0 seconds) into
     * number of milliseconds. This is used to support human-readable strings passed
     * to clock.tick()
     * @param {string} str
     * @returns {number}
     */
    function parseTime(str) {
      if (!str) {
        return 0;
      }
      var strings = str.split(":");
      var l = strings.length;
      var i = l;
      var ms = 0;
      var parsed;
      if (l > 3 || !/^(\d\d:){0,2}\d\d?$/.test(str)) {
        throw new Error("tick only understands numbers, 'm:s' and 'h:m:s'. Each part must be two digits");
      }
      while (i--) {
        parsed = parseInt(strings[i], 10);
        if (parsed >= 60) {
          throw new Error("Invalid time ".concat(str));
        }
        ms += parsed * Math.pow(60, l - i - 1);
      }
      return ms * 1000;
    }

    /**
     * Get the decimal part of the millisecond value as nanoseconds
     * @param {number} msFloat the number of milliseconds
     * @returns {number} an integer number of nanoseconds in the range [0,1e6)
     *
     * Example: nanoRemainer(123.456789) -> 456789
     */
    function nanoRemainder(msFloat) {
      var modulo = 1e6;
      var remainder = msFloat * 1e6 % modulo;
      var positiveRemainder = remainder < 0 ? remainder + modulo : remainder;
      return Math.floor(positiveRemainder);
    }

    /**
     * Used to grok the `now` parameter to createClock.
     * @param {Date|number} epoch the system time
     * @returns {number}
     */
    function getEpoch(epoch) {
      if (!epoch) {
        return 0;
      }
      if (typeof epoch.getTime === "function") {
        return epoch.getTime();
      }
      if (typeof epoch === "number") {
        return epoch;
      }
      throw new TypeError("now should be milliseconds since UNIX epoch");
    }

    /**
     * @param {number} from
     * @param {number} to
     * @param {Timer} timer
     * @returns {boolean}
     */
    function inRange(from, to, timer) {
      return timer && timer.callAt >= from && timer.callAt <= to;
    }

    /**
     * @param {Clock} clock
     * @param {Timer} job
     */
    function getInfiniteLoopError(clock, job) {
      var infiniteLoopError = new Error("Aborting after running ".concat(clock.loopLimit, " timers, assuming an infinite loop!"));
      if (!job.error) {
        return infiniteLoopError;
      }

      // pattern never matched in Node
      var computedTargetPattern = /target\.*[<|(|[].*?[>|\]|)]\s*/;
      var clockMethodPattern = new RegExp(String(Object.keys(clock).join("|")));
      if (addTimerReturnsObject) {
        // node.js environment
        clockMethodPattern = new RegExp("\\s+at (Object\\.)?(?:".concat(Object.keys(clock).join("|"), ")\\s+"));
      }
      var matchedLineIndex = -1;
      job.error.stack.split("\n").some(function (line, i) {
        // If we've matched a computed target line (e.g. setTimeout) then we
        // don't need to look any further. Return true to stop iterating.
        var matchedComputedTarget = line.match(computedTargetPattern);
        /* istanbul ignore if */
        if (matchedComputedTarget) {
          matchedLineIndex = i;
          return true;
        }

        // If we've matched a clock method line, then there may still be
        // others further down the trace. Return false to keep iterating.
        var matchedClockMethod = line.match(clockMethodPattern);
        if (matchedClockMethod) {
          matchedLineIndex = i;
          return false;
        }

        // If we haven't matched anything on this line, but we matched
        // previously and set the matched line index, then we can stop.
        // If we haven't matched previously, then we should keep iterating.
        return matchedLineIndex >= 0;
      });
      var stack = "".concat(infiniteLoopError, "\n").concat(job.type || "Microtask", " - ").concat(job.func.name || "anonymous", "\n").concat(job.error.stack.split("\n").slice(matchedLineIndex + 1).join("\n"));
      try {
        Object.defineProperty(infiniteLoopError, "stack", {
          value: stack
        });
      } catch (e) {
        // noop
      }
      return infiniteLoopError;
    }

    //eslint-disable-next-line jsdoc/require-jsdoc
    function createDate() {
      var ClockDate = /*#__PURE__*/function (_NativeDate) {
        /**
         * @param {number} year
         * @param {number} month
         * @param {number} date
         * @param {number} hour
         * @param {number} minute
         * @param {number} second
         * @param {number} ms
         * @returns void
         */
        // eslint-disable-next-line no-unused-vars
        function ClockDate(year, month, date, hour, minute, second, ms) {
          var _this;
          _classCallCheck(this, ClockDate);
          // Defensive and verbose to avoid potential harm in passing
          // explicit undefined when user does not pass argument
          if (arguments.length === 0) {
            _this = _callSuper(this, ClockDate, [ClockDate.clock.now]);
          } else {
            _this = _callSuper(this, ClockDate, arguments);
          }

          // ensures identity checks using the constructor prop still works
          // this should have no other functional effect
          Object.defineProperty(_assertThisInitialized(_this), "constructor", {
            value: NativeDate,
            enumerable: false
          });
          return _assertThisInitialized(_this);
        }
        _inherits(ClockDate, _NativeDate);
        return _createClass(ClockDate, null, [{
          key: Symbol.hasInstance,
          value: function value(instance) {
            return instance instanceof NativeDate;
          }
        }]);
      }(NativeDate);
      ClockDate.isFake = true;
      if (NativeDate.now) {
        ClockDate.now = function now() {
          return ClockDate.clock.now;
        };
      }
      if (NativeDate.toSource) {
        ClockDate.toSource = function toSource() {
          return NativeDate.toSource();
        };
      }
      ClockDate.toString = function toString() {
        return NativeDate.toString();
      };

      // noinspection UnnecessaryLocalVariableJS
      /**
       * A normal Class constructor cannot be called without `new`, but Date can, so we need
       * to wrap it in a Proxy in order to ensure this functionality of Date is kept intact
       * @type {ClockDate}
       */
      var ClockDateProxy = new Proxy(ClockDate, {
        // handler for [[Call]] invocations (i.e. not using `new`)
        apply: function apply() {
          // the Date constructor called as a function, ref Ecma-262 Edition 5.1, section 15.9.2.
          // This remains so in the 10th edition of 2019 as well.
          if (this instanceof ClockDate) {
            throw new TypeError("A Proxy should only capture `new` calls with the `construct` handler. This is not supposed to be possible, so check the logic.");
          }
          return new NativeDate(ClockDate.clock.now).toString();
        }
      });
      return ClockDateProxy;
    }

    /**
     * Mirror Intl by default on our fake implementation
     *
     * Most of the properties are the original native ones,
     * but we need to take control of those that have a
     * dependency on the current clock.
     * @returns {object} the partly fake Intl implementation
     */
    function createIntl() {
      var ClockIntl = {};
      /*
       * All properties of Intl are non-enumerable, so we need
       * to do a bit of work to get them out.
       */
      Object.getOwnPropertyNames(NativeIntl).forEach(function (property) {
        return ClockIntl[property] = NativeIntl[property];
      });
      ClockIntl.DateTimeFormat = function () {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        var realFormatter = _construct(NativeIntl.DateTimeFormat, args);
        var formatter = {};
        ["formatRange", "formatRangeToParts", "resolvedOptions"].forEach(function (method) {
          formatter[method] = realFormatter[method].bind(realFormatter);
        });
        ["format", "formatToParts"].forEach(function (method) {
          formatter[method] = function (date) {
            return realFormatter[method](date || ClockIntl.clock.now);
          };
        });
        return formatter;
      };
      ClockIntl.DateTimeFormat.prototype = Object.create(NativeIntl.DateTimeFormat.prototype);
      ClockIntl.DateTimeFormat.supportedLocalesOf = NativeIntl.DateTimeFormat.supportedLocalesOf;
      return ClockIntl;
    }

    //eslint-disable-next-line jsdoc/require-jsdoc
    function enqueueJob(clock, job) {
      // enqueues a microtick-deferred task - ecma262/#sec-enqueuejob
      if (!clock.jobs) {
        clock.jobs = [];
      }
      clock.jobs.push(job);
    }

    //eslint-disable-next-line jsdoc/require-jsdoc
    function runJobs(clock) {
      // runs all microtick-deferred tasks - ecma262/#sec-runjobs
      if (!clock.jobs) {
        return;
      }
      for (var i = 0; i < clock.jobs.length; i++) {
        var job = clock.jobs[i];
        job.func.apply(null, job.args);
        checkIsNearInfiniteLimit(clock, i);
        if (clock.loopLimit && i > clock.loopLimit) {
          throw getInfiniteLoopError(clock, job);
        }
      }
      resetIsNearInfiniteLimit();
      clock.jobs = [];
    }

    /**
     * @param {Clock} clock
     * @param {Timer} timer
     * @returns {number} id of the created timer
     */
    function addTimer(clock, timer) {
      if (timer.func === undefined) {
        throw new Error("Callback must be provided to timer calls");
      }
      if (addTimerReturnsObject) {
        // Node.js environment
        if (typeof timer.func !== "function") {
          throw new TypeError("[ERR_INVALID_CALLBACK]: Callback must be a function. Received ".concat(timer.func, " of type ").concat(_typeof(timer.func)));
        }
      }
      if (isNearInfiniteLimit) {
        timer.error = new Error();
      }
      timer.type = timer.immediate ? "Immediate" : "Timeout";
      if (timer.hasOwnProperty("delay")) {
        if (typeof timer.delay !== "number") {
          timer.delay = parseInt(timer.delay, 10);
        }
        if (!isNumberFinite(timer.delay)) {
          timer.delay = 0;
        }
        timer.delay = timer.delay > maxTimeout ? 1 : timer.delay;
        timer.delay = Math.max(0, timer.delay);
      }
      if (timer.hasOwnProperty("interval")) {
        timer.type = "Interval";
        timer.interval = timer.interval > maxTimeout ? 1 : timer.interval;
      }
      if (timer.hasOwnProperty("animation")) {
        timer.type = "AnimationFrame";
        timer.animation = true;
      }
      if (timer.hasOwnProperty("idleCallback")) {
        timer.type = "IdleCallback";
        timer.idleCallback = true;
      }
      if (!clock.timers) {
        clock.timers = {};
      }
      timer.id = uniqueTimerId++;
      timer.createdAt = clock.now;
      timer.callAt = clock.now + (parseInt(timer.delay) || (clock.duringTick ? 1 : 0));
      clock.timers[timer.id] = timer;
      if (addTimerReturnsObject) {
        var res = _defineProperty({
          refed: true,
          ref: function ref() {
            this.refed = true;
            return res;
          },
          unref: function unref() {
            this.refed = false;
            return res;
          },
          hasRef: function hasRef() {
            return this.refed;
          },
          refresh: function refresh() {
            timer.callAt = clock.now + (parseInt(timer.delay) || (clock.duringTick ? 1 : 0));

            // it _might_ have been removed, but if not the assignment is perfectly fine
            clock.timers[timer.id] = timer;
            return res;
          }
        }, Symbol.toPrimitive, function () {
          return timer.id;
        });
        return res;
      }
      return timer.id;
    }

    /* eslint consistent-return: "off" */
    /**
     * Timer comparitor
     * @param {Timer} a
     * @param {Timer} b
     * @returns {number}
     */
    function compareTimers(a, b) {
      // Sort first by absolute timing
      if (a.callAt < b.callAt) {
        return -1;
      }
      if (a.callAt > b.callAt) {
        return 1;
      }

      // Sort next by immediate, immediate timers take precedence
      if (a.immediate && !b.immediate) {
        return -1;
      }
      if (!a.immediate && b.immediate) {
        return 1;
      }

      // Sort next by creation time, earlier-created timers take precedence
      if (a.createdAt < b.createdAt) {
        return -1;
      }
      if (a.createdAt > b.createdAt) {
        return 1;
      }

      // Sort next by id, lower-id timers take precedence
      if (a.id < b.id) {
        return -1;
      }
      if (a.id > b.id) {
        return 1;
      }

      // As timer ids are unique, no fallback `0` is necessary
    }

    /**
     * @param {Clock} clock
     * @param {number} from
     * @param {number} to
     * @returns {Timer}
     */
    function firstTimerInRange(clock, from, to) {
      var timers = clock.timers;
      var timer = null;
      var id, isInRange;
      for (id in timers) {
        if (timers.hasOwnProperty(id)) {
          isInRange = inRange(from, to, timers[id]);
          if (isInRange && (!timer || compareTimers(timer, timers[id]) === 1)) {
            timer = timers[id];
          }
        }
      }
      return timer;
    }

    /**
     * @param {Clock} clock
     * @returns {Timer}
     */
    function firstTimer(clock) {
      var timers = clock.timers;
      var timer = null;
      var id;
      for (id in timers) {
        if (timers.hasOwnProperty(id)) {
          if (!timer || compareTimers(timer, timers[id]) === 1) {
            timer = timers[id];
          }
        }
      }
      return timer;
    }

    /**
     * @param {Clock} clock
     * @returns {Timer}
     */
    function lastTimer(clock) {
      var timers = clock.timers;
      var timer = null;
      var id;
      for (id in timers) {
        if (timers.hasOwnProperty(id)) {
          if (!timer || compareTimers(timer, timers[id]) === -1) {
            timer = timers[id];
          }
        }
      }
      return timer;
    }

    /**
     * @param {Clock} clock
     * @param {Timer} timer
     */
    function callTimer(clock, timer) {
      if (typeof timer.interval === "number") {
        clock.timers[timer.id].callAt += timer.interval;
      } else {
        delete clock.timers[timer.id];
      }
      if (typeof timer.func === "function") {
        timer.func.apply(null, timer.args);
      } else {
        /* eslint no-eval: "off" */
        var eval2 = eval;
        (function () {
          eval2(timer.func);
        })();
      }
    }

    /**
     * Gets clear handler name for a given timer type
     * @param {string} ttype
     */
    function getClearHandler(ttype) {
      if (ttype === "IdleCallback" || ttype === "AnimationFrame") {
        return "cancel".concat(ttype);
      }
      return "clear".concat(ttype);
    }

    /**
     * Gets schedule handler name for a given timer type
     * @param {string} ttype
     */
    function getScheduleHandler(ttype) {
      if (ttype === "IdleCallback" || ttype === "AnimationFrame") {
        return "request".concat(ttype);
      }
      return "set".concat(ttype);
    }

    /**
     * Creates an anonymous function to warn only once
     */
    function createWarnOnce() {
      var calls = 0;
      return function (msg) {
        // eslint-disable-next-line
        !calls++ && console.warn(msg);
      };
    }
    var warnOnce = createWarnOnce();

    /**
     * @param {Clock} clock
     * @param {number} timerId
     * @param {string} ttype
     */
    function clearTimer(clock, timerId, ttype) {
      if (!timerId) {
        // null appears to be allowed in most browsers, and appears to be
        // relied upon by some libraries, like Bootstrap carousel
        return;
      }
      if (!clock.timers) {
        clock.timers = {};
      }

      // in Node, the ID is stored as the primitive value for `Timeout` objects
      // for `Immediate` objects, no ID exists, so it gets coerced to NaN
      var id = Number(timerId);
      if (Number.isNaN(id) || id < idCounterStart) {
        var handlerName = getClearHandler(ttype);
        if (clock.shouldClearNativeTimers === true) {
          var nativeHandler = clock["_".concat(handlerName)];
          return typeof nativeHandler === "function" ? nativeHandler(timerId) : undefined;
        }
        warnOnce("FakeTimers: ".concat(handlerName, " was invoked to clear a native timer instead of one created by this library.") + "\nTo automatically clean-up native timers, use `shouldClearNativeTimers`.");
      }
      if (clock.timers.hasOwnProperty(id)) {
        // check that the ID matches a timer of the correct type
        var timer = clock.timers[id];
        if (timer.type === ttype || timer.type === "Timeout" && ttype === "Interval" || timer.type === "Interval" && ttype === "Timeout") {
          delete clock.timers[id];
        } else {
          var clear = getClearHandler(ttype);
          var schedule = getScheduleHandler(timer.type);
          throw new Error("Cannot clear timer: timer created with ".concat(schedule, "() but cleared with ").concat(clear, "()"));
        }
      }
    }

    /**
     * @param {Clock} clock
     * @param {Config} config
     * @returns {Timer[]}
     */
    function uninstall(clock, config) {
      var method, i, l;
      var installedHrTime = "_hrtime";
      var installedNextTick = "_nextTick";
      for (i = 0, l = clock.methods.length; i < l; i++) {
        method = clock.methods[i];
        if (method === "hrtime" && _global.process) {
          _global.process.hrtime = clock[installedHrTime];
        } else if (method === "nextTick" && _global.process) {
          _global.process.nextTick = clock[installedNextTick];
        } else if (method === "performance") {
          var originalPerfDescriptor = Object.getOwnPropertyDescriptor(clock, "_".concat(method));
          if (originalPerfDescriptor && originalPerfDescriptor.get && !originalPerfDescriptor.set) {
            Object.defineProperty(_global, method, originalPerfDescriptor);
          } else if (originalPerfDescriptor.configurable) {
            _global[method] = clock["_".concat(method)];
          }
        } else {
          if (_global[method] && _global[method].hadOwnProperty) {
            _global[method] = clock["_".concat(method)];
          } else {
            try {
              delete _global[method];
            } catch (ignore) {
              /* eslint no-empty: "off" */
            }
          }
        }
        if (clock.timersModuleMethods !== undefined) {
          for (var j = 0; j < clock.timersModuleMethods.length; j++) {
            var entry = clock.timersModuleMethods[j];
            timersModule[entry.methodName] = entry.original;
          }
        }
        if (clock.timersPromisesModuleMethods !== undefined) {
          for (var _j = 0; _j < clock.timersPromisesModuleMethods.length; _j++) {
            var _entry = clock.timersPromisesModuleMethods[_j];
            timersPromisesModule[_entry.methodName] = _entry.original;
          }
        }
      }
      if (config.shouldAdvanceTime === true) {
        _global.clearInterval(clock.attachedInterval);
      }

      // Prevent multiple executions which will completely remove these props
      clock.methods = [];
      var _iterator = _createForOfIteratorHelper(clock.abortListenerMap.entries()),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _slicedToArray(_step.value, 2),
            listener = _step$value[0],
            signal = _step$value[1];
          signal.removeEventListener("abort", listener);
          clock.abortListenerMap.delete(listener);
        }

        // return pending timers, to enable checking what timers remained on uninstall
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      if (!clock.timers) {
        return [];
      }
      return Object.keys(clock.timers).map(function mapper(key) {
        return clock.timers[key];
      });
    }

    /**
     * @param {object} target the target containing the method to replace
     * @param {string} method the keyname of the method on the target
     * @param {Clock} clock
     */
    function hijackMethod(target, method, clock) {
      clock[method].hadOwnProperty = Object.prototype.hasOwnProperty.call(target, method);
      clock["_".concat(method)] = target[method];
      if (method === "Date") {
        target[method] = clock[method];
      } else if (method === "Intl") {
        target[method] = clock[method];
      } else if (method === "performance") {
        var originalPerfDescriptor = Object.getOwnPropertyDescriptor(target, method);
        // JSDOM has a read only performance field so we have to save/copy it differently
        if (originalPerfDescriptor && originalPerfDescriptor.get && !originalPerfDescriptor.set) {
          Object.defineProperty(clock, "_".concat(method), originalPerfDescriptor);
          var perfDescriptor = Object.getOwnPropertyDescriptor(clock, method);
          Object.defineProperty(target, method, perfDescriptor);
        } else {
          target[method] = clock[method];
        }
      } else {
        target[method] = function () {
          return clock[method].apply(clock, arguments);
        };
        Object.defineProperties(target[method], Object.getOwnPropertyDescriptors(clock[method]));
      }
      target[method].clock = clock;
    }

    /**
     * @param {Clock} clock
     * @param {number} advanceTimeDelta
     */
    function doIntervalTick(clock, advanceTimeDelta) {
      clock.tick(advanceTimeDelta);
    }

    /**
     * @typedef {object} Timers
     * @property {setTimeout} setTimeout
     * @property {clearTimeout} clearTimeout
     * @property {setInterval} setInterval
     * @property {clearInterval} clearInterval
     * @property {Date} Date
     * @property {Intl} Intl
     * @property {SetImmediate=} setImmediate
     * @property {function(NodeImmediate): void=} clearImmediate
     * @property {function(number[]):number[]=} hrtime
     * @property {NextTick=} nextTick
     * @property {Performance=} performance
     * @property {RequestAnimationFrame=} requestAnimationFrame
     * @property {boolean=} queueMicrotask
     * @property {function(number): void=} cancelAnimationFrame
     * @property {RequestIdleCallback=} requestIdleCallback
     * @property {function(number): void=} cancelIdleCallback
     */

    /** @type {Timers} */
    var timers = {
      setTimeout: _global.setTimeout,
      clearTimeout: _global.clearTimeout,
      setInterval: _global.setInterval,
      clearInterval: _global.clearInterval,
      Date: _global.Date
    };
    if (isPresent.setImmediate) {
      timers.setImmediate = _global.setImmediate;
    }
    if (isPresent.clearImmediate) {
      timers.clearImmediate = _global.clearImmediate;
    }
    if (isPresent.hrtime) {
      timers.hrtime = _global.process.hrtime;
    }
    if (isPresent.nextTick) {
      timers.nextTick = _global.process.nextTick;
    }
    if (isPresent.performance) {
      timers.performance = _global.performance;
    }
    if (isPresent.requestAnimationFrame) {
      timers.requestAnimationFrame = _global.requestAnimationFrame;
    }
    if (isPresent.queueMicrotask) {
      timers.queueMicrotask = _global.queueMicrotask;
    }
    if (isPresent.cancelAnimationFrame) {
      timers.cancelAnimationFrame = _global.cancelAnimationFrame;
    }
    if (isPresent.requestIdleCallback) {
      timers.requestIdleCallback = _global.requestIdleCallback;
    }
    if (isPresent.cancelIdleCallback) {
      timers.cancelIdleCallback = _global.cancelIdleCallback;
    }
    if (isPresent.Intl) {
      timers.Intl = NativeIntl;
    }
    var originalSetTimeout = _global.setImmediate || _global.setTimeout;

    /**
     * @param {Date|number} [start] the system time - non-integer values are floored
     * @param {number} [loopLimit] maximum number of timers that will be run when calling runAll()
     * @returns {Clock}
     */
    function createClock(start, loopLimit) {
      // eslint-disable-next-line no-param-reassign
      start = Math.floor(getEpoch(start));
      // eslint-disable-next-line no-param-reassign
      loopLimit = loopLimit || 1000;
      var nanos = 0;
      var adjustedSystemTime = [0, 0]; // [millis, nanoremainder]

      var clock = {
        now: start,
        Date: createDate(),
        loopLimit: loopLimit
      };
      clock.Date.clock = clock;

      //eslint-disable-next-line jsdoc/require-jsdoc
      function getTimeToNextFrame() {
        return 16 - (clock.now - start) % 16;
      }

      //eslint-disable-next-line jsdoc/require-jsdoc
      function hrtime(prev) {
        var millisSinceStart = clock.now - adjustedSystemTime[0] - start;
        var secsSinceStart = Math.floor(millisSinceStart / 1000);
        var remainderInNanos = (millisSinceStart - secsSinceStart * 1e3) * 1e6 + nanos - adjustedSystemTime[1];
        if (Array.isArray(prev)) {
          if (prev[1] > 1e9) {
            throw new TypeError("Number of nanoseconds can't exceed a billion");
          }
          var oldSecs = prev[0];
          var nanoDiff = remainderInNanos - prev[1];
          var secDiff = secsSinceStart - oldSecs;
          if (nanoDiff < 0) {
            nanoDiff += 1e9;
            secDiff -= 1;
          }
          return [secDiff, nanoDiff];
        }
        return [secsSinceStart, remainderInNanos];
      }

      /**
       * A high resolution timestamp in milliseconds.
       * @typedef {number} DOMHighResTimeStamp
       */

      /**
       * performance.now()
       * @returns {DOMHighResTimeStamp}
       */
      function fakePerformanceNow() {
        var hrt = hrtime();
        var millis = hrt[0] * 1000 + hrt[1] / 1e6;
        return millis;
      }
      if (isPresent.hrtimeBigint) {
        hrtime.bigint = function () {
          var parts = hrtime();
          return BigInt(parts[0]) * BigInt(1e9) + BigInt(parts[1]); // eslint-disable-line
        };
      }
      if (isPresent.Intl) {
        clock.Intl = createIntl();
        clock.Intl.clock = clock;
      }
      clock.requestIdleCallback = function requestIdleCallback(func, timeout) {
        var timeToNextIdlePeriod = 0;
        if (clock.countTimers() > 0) {
          timeToNextIdlePeriod = 50; // const for now
        }
        var result = addTimer(clock, {
          func: func,
          args: Array.prototype.slice.call(arguments, 2),
          delay: typeof timeout === "undefined" ? timeToNextIdlePeriod : Math.min(timeout, timeToNextIdlePeriod),
          idleCallback: true
        });
        return Number(result);
      };
      clock.cancelIdleCallback = function cancelIdleCallback(timerId) {
        return clearTimer(clock, timerId, "IdleCallback");
      };
      clock.setTimeout = function setTimeout(func, timeout) {
        return addTimer(clock, {
          func: func,
          args: Array.prototype.slice.call(arguments, 2),
          delay: timeout
        });
      };
      if (typeof _global.Promise !== "undefined" && utilPromisify) {
        clock.setTimeout[utilPromisify.custom] = function promisifiedSetTimeout(timeout, arg) {
          return new _global.Promise(function setTimeoutExecutor(resolve) {
            addTimer(clock, {
              func: resolve,
              args: [arg],
              delay: timeout
            });
          });
        };
      }
      clock.clearTimeout = function clearTimeout(timerId) {
        return clearTimer(clock, timerId, "Timeout");
      };
      clock.nextTick = function nextTick(func) {
        return enqueueJob(clock, {
          func: func,
          args: Array.prototype.slice.call(arguments, 1),
          error: isNearInfiniteLimit ? new Error() : null
        });
      };
      clock.queueMicrotask = function queueMicrotask(func) {
        return clock.nextTick(func); // explicitly drop additional arguments
      };
      clock.setInterval = function setInterval(func, timeout) {
        // eslint-disable-next-line no-param-reassign
        timeout = parseInt(timeout, 10);
        return addTimer(clock, {
          func: func,
          args: Array.prototype.slice.call(arguments, 2),
          delay: timeout,
          interval: timeout
        });
      };
      clock.clearInterval = function clearInterval(timerId) {
        return clearTimer(clock, timerId, "Interval");
      };
      if (isPresent.setImmediate) {
        clock.setImmediate = function setImmediate(func) {
          return addTimer(clock, {
            func: func,
            args: Array.prototype.slice.call(arguments, 1),
            immediate: true
          });
        };
        if (typeof _global.Promise !== "undefined" && utilPromisify) {
          clock.setImmediate[utilPromisify.custom] = function promisifiedSetImmediate(arg) {
            return new _global.Promise(function setImmediateExecutor(resolve) {
              addTimer(clock, {
                func: resolve,
                args: [arg],
                immediate: true
              });
            });
          };
        }
        clock.clearImmediate = function clearImmediate(timerId) {
          return clearTimer(clock, timerId, "Immediate");
        };
      }
      clock.countTimers = function countTimers() {
        return Object.keys(clock.timers || {}).length + (clock.jobs || []).length;
      };
      clock.requestAnimationFrame = function requestAnimationFrame(func) {
        var result = addTimer(clock, {
          func: func,
          delay: getTimeToNextFrame(),
          get args() {
            return [fakePerformanceNow()];
          },
          animation: true
        });
        return Number(result);
      };
      clock.cancelAnimationFrame = function cancelAnimationFrame(timerId) {
        return clearTimer(clock, timerId, "AnimationFrame");
      };
      clock.runMicrotasks = function runMicrotasks() {
        runJobs(clock);
      };

      /**
       * @param {number|string} tickValue milliseconds or a string parseable by parseTime
       * @param {boolean} isAsync
       * @param {Function} resolve
       * @param {Function} reject
       * @returns {number|undefined} will return the new `now` value or nothing for async
       */
      function doTick(tickValue, isAsync, resolve, reject) {
        var msFloat = typeof tickValue === "number" ? tickValue : parseTime(tickValue);
        var ms = Math.floor(msFloat);
        var remainder = nanoRemainder(msFloat);
        var nanosTotal = nanos + remainder;
        var tickTo = clock.now + ms;
        if (msFloat < 0) {
          throw new TypeError("Negative ticks are not supported");
        }

        // adjust for positive overflow
        if (nanosTotal >= 1e6) {
          tickTo += 1;
          nanosTotal -= 1e6;
        }
        nanos = nanosTotal;
        var tickFrom = clock.now;
        var previous = clock.now;
        // ESLint fails to detect this correctly
        /* eslint-disable prefer-const */
        var timer, firstException, oldNow, nextPromiseTick, compensationCheck, postTimerCall;
        /* eslint-enable prefer-const */

        clock.duringTick = true;

        // perform microtasks
        oldNow = clock.now;
        runJobs(clock);
        if (oldNow !== clock.now) {
          // compensate for any setSystemTime() call during microtask callback
          tickFrom += clock.now - oldNow;
          tickTo += clock.now - oldNow;
        }

        //eslint-disable-next-line jsdoc/require-jsdoc
        function doTickInner() {
          // perform each timer in the requested range
          timer = firstTimerInRange(clock, tickFrom, tickTo);
          // eslint-disable-next-line no-unmodified-loop-condition
          while (timer && tickFrom <= tickTo) {
            if (clock.timers[timer.id]) {
              tickFrom = timer.callAt;
              clock.now = timer.callAt;
              oldNow = clock.now;
              try {
                runJobs(clock);
                callTimer(clock, timer);
              } catch (e) {
                firstException = firstException || e;
              }
              if (isAsync) {
                // finish up after native setImmediate callback to allow
                // all native es6 promises to process their callbacks after
                // each timer fires.
                originalSetTimeout(nextPromiseTick);
                return;
              }
              compensationCheck();
            }
            postTimerCall();
          }

          // perform process.nextTick()s again
          oldNow = clock.now;
          runJobs(clock);
          if (oldNow !== clock.now) {
            // compensate for any setSystemTime() call during process.nextTick() callback
            tickFrom += clock.now - oldNow;
            tickTo += clock.now - oldNow;
          }
          clock.duringTick = false;

          // corner case: during runJobs new timers were scheduled which could be in the range [clock.now, tickTo]
          timer = firstTimerInRange(clock, tickFrom, tickTo);
          if (timer) {
            try {
              clock.tick(tickTo - clock.now); // do it all again - for the remainder of the requested range
            } catch (e) {
              firstException = firstException || e;
            }
          } else {
            // no timers remaining in the requested range: move the clock all the way to the end
            clock.now = tickTo;

            // update nanos
            nanos = nanosTotal;
          }
          if (firstException) {
            throw firstException;
          }
          if (isAsync) {
            resolve(clock.now);
          } else {
            return clock.now;
          }
        }
        nextPromiseTick = isAsync && function () {
          try {
            compensationCheck();
            postTimerCall();
            doTickInner();
          } catch (e) {
            reject(e);
          }
        };
        compensationCheck = function compensationCheck() {
          // compensate for any setSystemTime() call during timer callback
          if (oldNow !== clock.now) {
            tickFrom += clock.now - oldNow;
            tickTo += clock.now - oldNow;
            previous += clock.now - oldNow;
          }
        };
        postTimerCall = function postTimerCall() {
          timer = firstTimerInRange(clock, previous, tickTo);
          previous = tickFrom;
        };
        return doTickInner();
      }

      /**
       * @param {string|number} tickValue number of milliseconds or a human-readable value like "01:11:15"
       * @returns {number} will return the new `now` value
       */
      clock.tick = function tick(tickValue) {
        return doTick(tickValue, false);
      };
      if (typeof _global.Promise !== "undefined") {
        /**
         * @param {string|number} tickValue number of milliseconds or a human-readable value like "01:11:15"
         * @returns {Promise}
         */
        clock.tickAsync = function tickAsync(tickValue) {
          return new _global.Promise(function (resolve, reject) {
            originalSetTimeout(function () {
              try {
                doTick(tickValue, true, resolve, reject);
              } catch (e) {
                reject(e);
              }
            });
          });
        };
      }
      clock.next = function next() {
        runJobs(clock);
        var timer = firstTimer(clock);
        if (!timer) {
          return clock.now;
        }
        clock.duringTick = true;
        try {
          clock.now = timer.callAt;
          callTimer(clock, timer);
          runJobs(clock);
          return clock.now;
        } finally {
          clock.duringTick = false;
        }
      };
      if (typeof _global.Promise !== "undefined") {
        clock.nextAsync = function nextAsync() {
          return new _global.Promise(function (resolve, reject) {
            originalSetTimeout(function () {
              try {
                var timer = firstTimer(clock);
                if (!timer) {
                  resolve(clock.now);
                  return;
                }
                var err;
                clock.duringTick = true;
                clock.now = timer.callAt;
                try {
                  callTimer(clock, timer);
                } catch (e) {
                  err = e;
                }
                clock.duringTick = false;
                originalSetTimeout(function () {
                  if (err) {
                    reject(err);
                  } else {
                    resolve(clock.now);
                  }
                });
              } catch (e) {
                reject(e);
              }
            });
          });
        };
      }
      clock.runAll = function runAll() {
        var numTimers, i;
        runJobs(clock);
        for (i = 0; i < clock.loopLimit; i++) {
          if (!clock.timers) {
            resetIsNearInfiniteLimit();
            return clock.now;
          }
          numTimers = Object.keys(clock.timers).length;
          if (numTimers === 0) {
            resetIsNearInfiniteLimit();
            return clock.now;
          }
          clock.next();
          checkIsNearInfiniteLimit(clock, i);
        }
        var excessJob = firstTimer(clock);
        throw getInfiniteLoopError(clock, excessJob);
      };
      clock.runToFrame = function runToFrame() {
        return clock.tick(getTimeToNextFrame());
      };
      if (typeof _global.Promise !== "undefined") {
        clock.runAllAsync = function runAllAsync() {
          return new _global.Promise(function (resolve, reject) {
            var i = 0;
            /**
             *
             */
            function doRun() {
              originalSetTimeout(function () {
                try {
                  runJobs(clock);
                  var numTimers;
                  if (i < clock.loopLimit) {
                    if (!clock.timers) {
                      resetIsNearInfiniteLimit();
                      resolve(clock.now);
                      return;
                    }
                    numTimers = Object.keys(clock.timers).length;
                    if (numTimers === 0) {
                      resetIsNearInfiniteLimit();
                      resolve(clock.now);
                      return;
                    }
                    clock.next();
                    i++;
                    doRun();
                    checkIsNearInfiniteLimit(clock, i);
                    return;
                  }
                  var excessJob = firstTimer(clock);
                  reject(getInfiniteLoopError(clock, excessJob));
                } catch (e) {
                  reject(e);
                }
              });
            }
            doRun();
          });
        };
      }
      clock.runToLast = function runToLast() {
        var timer = lastTimer(clock);
        if (!timer) {
          runJobs(clock);
          return clock.now;
        }
        return clock.tick(timer.callAt - clock.now);
      };
      if (typeof _global.Promise !== "undefined") {
        clock.runToLastAsync = function runToLastAsync() {
          return new _global.Promise(function (resolve, reject) {
            originalSetTimeout(function () {
              try {
                var timer = lastTimer(clock);
                if (!timer) {
                  runJobs(clock);
                  resolve(clock.now);
                }
                resolve(clock.tickAsync(timer.callAt - clock.now));
              } catch (e) {
                reject(e);
              }
            });
          });
        };
      }
      clock.reset = function reset() {
        nanos = 0;
        clock.timers = {};
        clock.jobs = [];
        clock.now = start;
      };
      clock.setSystemTime = function setSystemTime(systemTime) {
        // determine time difference
        var newNow = getEpoch(systemTime);
        var difference = newNow - clock.now;
        var id, timer;
        adjustedSystemTime[0] = adjustedSystemTime[0] + difference;
        adjustedSystemTime[1] = adjustedSystemTime[1] + nanos;
        // update 'system clock'
        clock.now = newNow;
        nanos = 0;

        // update timers and intervals to keep them stable
        for (id in clock.timers) {
          if (clock.timers.hasOwnProperty(id)) {
            timer = clock.timers[id];
            timer.createdAt += difference;
            timer.callAt += difference;
          }
        }
      };

      /**
       * @param {string|number} tickValue number of milliseconds or a human-readable value like "01:11:15"
       * @returns {number} will return the new `now` value
       */
      clock.jump = function jump(tickValue) {
        var msFloat = typeof tickValue === "number" ? tickValue : parseTime(tickValue);
        var ms = Math.floor(msFloat);
        for (var _i2 = 0, _Object$values = Object.values(clock.timers); _i2 < _Object$values.length; _i2++) {
          var timer = _Object$values[_i2];
          if (clock.now + ms > timer.callAt) {
            timer.callAt = clock.now + ms;
          }
        }
        clock.tick(ms);
      };
      if (isPresent.performance) {
        clock.performance = Object.create(null);
        clock.performance.now = fakePerformanceNow;
      }
      if (isPresent.hrtime) {
        clock.hrtime = hrtime;
      }
      return clock;
    }

    /* eslint-disable complexity */

    /**
     * @param {Config=} [config] Optional config
     * @returns {Clock}
     */
    function install(config) {
      if (arguments.length > 1 || config instanceof Date || Array.isArray(config) || typeof config === "number") {
        throw new TypeError("FakeTimers.install called with ".concat(String(config), " install requires an object parameter"));
      }
      if (_global.Date.isFake === true) {
        // Timers are already faked; this is a problem.
        // Make the user reset timers before continuing.
        throw new TypeError("Can't install fake timers twice on the same global object.");
      }

      // eslint-disable-next-line no-param-reassign
      config = typeof config !== "undefined" ? config : {};
      config.shouldAdvanceTime = config.shouldAdvanceTime || false;
      config.advanceTimeDelta = config.advanceTimeDelta || 20;
      config.shouldClearNativeTimers = config.shouldClearNativeTimers || false;
      if (config.target) {
        throw new TypeError("config.target is no longer supported. Use `withGlobal(target)` instead.");
      }

      /**
       * @param {string} timer/object the name of the thing that is not present
       * @param timer
       */
      function handleMissingTimer(timer) {
        if (config.ignoreMissingTimers) {
          return;
        }
        throw new ReferenceError("non-existent timers and/or objects cannot be faked: '".concat(timer, "'"));
      }
      var i, l;
      var clock = createClock(config.now, config.loopLimit);
      clock.shouldClearNativeTimers = config.shouldClearNativeTimers;
      clock.uninstall = function () {
        return uninstall(clock, config);
      };
      clock.abortListenerMap = new Map();
      clock.methods = config.toFake || [];
      if (clock.methods.length === 0) {
        clock.methods = Object.keys(timers);
      }
      if (config.shouldAdvanceTime === true) {
        var intervalTick = doIntervalTick.bind(null, clock, config.advanceTimeDelta);
        var intervalId = _global.setInterval(intervalTick, config.advanceTimeDelta);
        clock.attachedInterval = intervalId;
      }
      if (clock.methods.includes("performance")) {
        var proto = function () {
          if (hasPerformanceConstructorPrototype) {
            return _global.performance.constructor.prototype;
          }
          if (hasPerformancePrototype) {
            return _global.Performance.prototype;
          }
        }();
        if (proto) {
          Object.getOwnPropertyNames(proto).forEach(function (name) {
            if (name !== "now") {
              clock.performance[name] = name.indexOf("getEntries") === 0 ? NOOP_ARRAY : NOOP;
            }
          });
          // ensure `mark` returns a value that is valid
          clock.performance.mark = function (name) {
            return new FakePerformanceEntry(name, "mark", 0, 0);
          };
          clock.performance.measure = function (name) {
            return new FakePerformanceEntry(name, "measure", 0, 100);
          };
          // `timeOrigin` should return the time of when the Window session started
          // (or the Worker was installed)
          clock.performance.timeOrigin = getEpoch(config.now);
        } else if ((config.toFake || []).includes("performance")) {
          return handleMissingTimer("performance");
        }
      }
      if (_global === globalObject && timersModule) {
        clock.timersModuleMethods = [];
      }
      if (_global === globalObject && timersPromisesModule) {
        clock.timersPromisesModuleMethods = [];
      }
      for (i = 0, l = clock.methods.length; i < l; i++) {
        var nameOfMethodToReplace = clock.methods[i];
        if (!isPresent[nameOfMethodToReplace]) {
          handleMissingTimer(nameOfMethodToReplace);
          // eslint-disable-next-line
          continue;
        }
        if (nameOfMethodToReplace === "hrtime") {
          if (_global.process && typeof _global.process.hrtime === "function") {
            hijackMethod(_global.process, nameOfMethodToReplace, clock);
          }
        } else if (nameOfMethodToReplace === "nextTick") {
          if (_global.process && typeof _global.process.nextTick === "function") {
            hijackMethod(_global.process, nameOfMethodToReplace, clock);
          }
        } else {
          hijackMethod(_global, nameOfMethodToReplace, clock);
        }
        if (clock.timersModuleMethods !== undefined && timersModule[nameOfMethodToReplace]) {
          var original = timersModule[nameOfMethodToReplace];
          clock.timersModuleMethods.push({
            methodName: nameOfMethodToReplace,
            original: original
          });
          timersModule[nameOfMethodToReplace] = _global[nameOfMethodToReplace];
        }
        if (clock.timersPromisesModuleMethods !== undefined) {
          if (nameOfMethodToReplace === "setTimeout") {
            clock.timersPromisesModuleMethods.push({
              methodName: "setTimeout",
              original: timersPromisesModule.setTimeout
            });
            timersPromisesModule.setTimeout = function (delay, value) {
              var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
              return new Promise(function (resolve, reject) {
                var _abort = function abort() {
                  options.signal.removeEventListener("abort", _abort);
                  clock.abortListenerMap.delete(_abort);

                  // This is safe, there is no code path that leads to this function
                  // being invoked before handle has been assigned.
                  // eslint-disable-next-line no-use-before-define
                  clock.clearTimeout(handle);
                  reject(options.signal.reason);
                };
                var handle = clock.setTimeout(function () {
                  if (options.signal) {
                    options.signal.removeEventListener("abort", _abort);
                    clock.abortListenerMap.delete(_abort);
                  }
                  resolve(value);
                }, delay);
                if (options.signal) {
                  if (options.signal.aborted) {
                    _abort();
                  } else {
                    options.signal.addEventListener("abort", _abort);
                    clock.abortListenerMap.set(_abort, options.signal);
                  }
                }
              });
            };
          } else if (nameOfMethodToReplace === "setImmediate") {
            clock.timersPromisesModuleMethods.push({
              methodName: "setImmediate",
              original: timersPromisesModule.setImmediate
            });
            timersPromisesModule.setImmediate = function (value) {
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              return new Promise(function (resolve, reject) {
                var _abort2 = function abort() {
                  options.signal.removeEventListener("abort", _abort2);
                  clock.abortListenerMap.delete(_abort2);

                  // This is safe, there is no code path that leads to this function
                  // being invoked before handle has been assigned.
                  // eslint-disable-next-line no-use-before-define
                  clock.clearImmediate(handle);
                  reject(options.signal.reason);
                };
                var handle = clock.setImmediate(function () {
                  if (options.signal) {
                    options.signal.removeEventListener("abort", _abort2);
                    clock.abortListenerMap.delete(_abort2);
                  }
                  resolve(value);
                });
                if (options.signal) {
                  if (options.signal.aborted) {
                    _abort2();
                  } else {
                    options.signal.addEventListener("abort", _abort2);
                    clock.abortListenerMap.set(_abort2, options.signal);
                  }
                }
              });
            };
          } else if (nameOfMethodToReplace === "setInterval") {
            clock.timersPromisesModuleMethods.push({
              methodName: "setInterval",
              original: timersPromisesModule.setInterval
            });
            timersPromisesModule.setInterval = function (delay, value) {
              var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
              return _defineProperty({}, Symbol.asyncIterator, function () {
                var createResolvable = function createResolvable() {
                  var resolve, reject;
                  var promise = new Promise(function (res, rej) {
                    resolve = res;
                    reject = rej;
                  });
                  promise.resolve = resolve;
                  promise.reject = reject;
                  return promise;
                };
                var done = false;
                var hasThrown = false;
                var returnCall;
                var nextAvailable = 0;
                var nextQueue = [];
                var handle = clock.setInterval(function () {
                  if (nextQueue.length > 0) {
                    nextQueue.shift().resolve();
                  } else {
                    nextAvailable++;
                  }
                }, delay);
                var _abort3 = function abort() {
                  options.signal.removeEventListener("abort", _abort3);
                  clock.abortListenerMap.delete(_abort3);
                  clock.clearInterval(handle);
                  done = true;
                  for (var _i3 = 0, _nextQueue = nextQueue; _i3 < _nextQueue.length; _i3++) {
                    var resolvable = _nextQueue[_i3];
                    resolvable.resolve();
                  }
                };
                if (options.signal) {
                  if (options.signal.aborted) {
                    done = true;
                  } else {
                    options.signal.addEventListener("abort", _abort3);
                    clock.abortListenerMap.set(_abort3, options.signal);
                  }
                }
                return {
                  next: function () {
                    var _next = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
                      var _options$signal, _options$signal2;
                      var resolvable;
                      return _regeneratorRuntime.wrap(function (_context2) {
                        while (1) switch (_context2.prev = _context2.next) {
                          case 0:
                            if (!((_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted && !hasThrown)) {
                              _context2.next = 1;
                              break;
                            }
                            hasThrown = true;
                            throw options.signal.reason;
                          case 1:
                            if (!done) {
                              _context2.next = 2;
                              break;
                            }
                            return _context2.abrupt("return", {
                              done: true,
                              value: undefined
                            });
                          case 2:
                            if (!(nextAvailable > 0)) {
                              _context2.next = 3;
                              break;
                            }
                            nextAvailable--;
                            return _context2.abrupt("return", {
                              done: false,
                              value: value
                            });
                          case 3:
                            resolvable = createResolvable();
                            nextQueue.push(resolvable);
                            _context2.next = 4;
                            return resolvable;
                          case 4:
                            if (returnCall && nextQueue.length === 0) {
                              returnCall.resolve();
                            }
                            if (!((_options$signal2 = options.signal) !== null && _options$signal2 !== void 0 && _options$signal2.aborted && !hasThrown)) {
                              _context2.next = 5;
                              break;
                            }
                            hasThrown = true;
                            throw options.signal.reason;
                          case 5:
                            if (!done) {
                              _context2.next = 6;
                              break;
                            }
                            return _context2.abrupt("return", {
                              done: true,
                              value: undefined
                            });
                          case 6:
                            return _context2.abrupt("return", {
                              done: false,
                              value: value
                            });
                          case 7:
                          case "end":
                            return _context2.stop();
                        }
                      }, _callee2);
                    }));
                    function next() {
                      return _next.apply(this, arguments);
                    }
                    return next;
                  }(),
                  return: function () {
                    var _return2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
                      return _regeneratorRuntime.wrap(function (_context3) {
                        while (1) switch (_context3.prev = _context3.next) {
                          case 0:
                            if (!done) {
                              _context3.next = 1;
                              break;
                            }
                            return _context3.abrupt("return", {
                              done: true,
                              value: undefined
                            });
                          case 1:
                            if (!(nextQueue.length > 0)) {
                              _context3.next = 2;
                              break;
                            }
                            returnCall = createResolvable();
                            _context3.next = 2;
                            return returnCall;
                          case 2:
                            clock.clearInterval(handle);
                            done = true;
                            if (options.signal) {
                              options.signal.removeEventListener("abort", _abort3);
                              clock.abortListenerMap.delete(_abort3);
                            }
                            return _context3.abrupt("return", {
                              done: true,
                              value: undefined
                            });
                          case 3:
                          case "end":
                            return _context3.stop();
                        }
                      }, _callee3);
                    }));
                    function _return() {
                      return _return2.apply(this, arguments);
                    }
                    return _return;
                  }()
                };
              });
            };
          }
        }
      }
      return clock;
    }

    /* eslint-enable complexity */

    return {
      timers: timers,
      createClock: createClock,
      install: install,
      withGlobal: withGlobal
    };
  }

  /**
   * @typedef {object} FakeTimers
   * @property {Timers} timers
   * @property {createClock} createClock
   * @property {Function} install
   * @property {withGlobal} withGlobal
   */

  /* eslint-enable complexity */

  /** @type {FakeTimers} */
  var defaultImplementation = withGlobal(globalObject);
  fakeTimersSrc.timers = defaultImplementation.timers;
  fakeTimersSrc.createClock = defaultImplementation.createClock;
  fakeTimersSrc.install = defaultImplementation.install;
  fakeTimersSrc.withGlobal = withGlobal;
  return fakeTimersSrc;
}
var fakeTimersSrcExports = requireFakeTimersSrc();
var FakeTimers = /*#__PURE__*/function () {
  function FakeTimers(_ref5) {
    var global = _ref5.global,
      config = _ref5.config;
    _classCallCheck(this, FakeTimers);
    _defineProperty(this, "_global", void 0);
    _defineProperty(this, "_clock", void 0);
    // | _fakingTime | _fakingDate |
    // +-------------+-------------+
    // | false       | falsy       | initial
    // | false       | truthy     | vi.setSystemTime called first (for mocking only Date without fake timers)
    // | true        | falsy       | vi.useFakeTimers called first
    // | true        | truthy     | unreachable
    _defineProperty(this, "_fakingTime", void 0);
    _defineProperty(this, "_fakingDate", void 0);
    _defineProperty(this, "_fakeTimers", void 0);
    _defineProperty(this, "_userConfig", void 0);
    _defineProperty(this, "_now", RealDate.now);
    this._userConfig = config;
    this._fakingDate = null;
    this._fakingTime = false;
    this._fakeTimers = fakeTimersSrcExports.withGlobal(global);
    this._global = global;
  }
  return _createClass(FakeTimers, [{
    key: "clearAllTimers",
    value: function clearAllTimers() {
      if (this._fakingTime) this._clock.reset();
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.useRealTimers();
    }
  }, {
    key: "runAllTimers",
    value: function runAllTimers() {
      if (this._checkFakeTimers()) this._clock.runAll();
    }
  }, {
    key: "runAllTimersAsync",
    value: function () {
      var _runAllTimersAsync = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
        return _regeneratorRuntime.wrap(function (_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              if (!this._checkFakeTimers()) {
                _context4.next = 1;
                break;
              }
              _context4.next = 1;
              return this._clock.runAllAsync();
            case 1:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function runAllTimersAsync() {
        return _runAllTimersAsync.apply(this, arguments);
      }
      return runAllTimersAsync;
    }()
  }, {
    key: "runOnlyPendingTimers",
    value: function runOnlyPendingTimers() {
      if (this._checkFakeTimers()) this._clock.runToLast();
    }
  }, {
    key: "runOnlyPendingTimersAsync",
    value: function () {
      var _runOnlyPendingTimersAsync = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {
        return _regeneratorRuntime.wrap(function (_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              if (!this._checkFakeTimers()) {
                _context5.next = 1;
                break;
              }
              _context5.next = 1;
              return this._clock.runToLastAsync();
            case 1:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function runOnlyPendingTimersAsync() {
        return _runOnlyPendingTimersAsync.apply(this, arguments);
      }
      return runOnlyPendingTimersAsync;
    }()
  }, {
    key: "advanceTimersToNextTimer",
    value: function advanceTimersToNextTimer() {
      var steps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      if (this._checkFakeTimers()) for (var i = steps; i > 0; i--) {
        this._clock.next();
        // Fire all timers at this point: https://github.com/sinonjs/fake-timers/issues/250
        this._clock.tick(0);
        if (this._clock.countTimers() === 0) break;
      }
    }
  }, {
    key: "advanceTimersToNextTimerAsync",
    value: function () {
      var _advanceTimersToNextTimerAsync = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {
        var steps,
          i,
          _args6 = arguments;
        return _regeneratorRuntime.wrap(function (_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              steps = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : 1;
              if (!this._checkFakeTimers()) {
                _context6.next = 4;
                break;
              }
              i = steps;
            case 1:
              if (!(i > 0)) {
                _context6.next = 4;
                break;
              }
              _context6.next = 2;
              return this._clock.nextAsync();
            case 2:
              // Fire all timers at this point: https://github.com/sinonjs/fake-timers/issues/250
              this._clock.tick(0);
              if (!(this._clock.countTimers() === 0)) {
                _context6.next = 3;
                break;
              }
              return _context6.abrupt("continue", 4);
            case 3:
              i--;
              _context6.next = 1;
              break;
            case 4:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function advanceTimersToNextTimerAsync() {
        return _advanceTimersToNextTimerAsync.apply(this, arguments);
      }
      return advanceTimersToNextTimerAsync;
    }()
  }, {
    key: "advanceTimersByTime",
    value: function advanceTimersByTime(msToRun) {
      if (this._checkFakeTimers()) this._clock.tick(msToRun);
    }
  }, {
    key: "advanceTimersByTimeAsync",
    value: function () {
      var _advanceTimersByTimeAsync = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee7(msToRun) {
        return _regeneratorRuntime.wrap(function (_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              if (!this._checkFakeTimers()) {
                _context7.next = 1;
                break;
              }
              _context7.next = 1;
              return this._clock.tickAsync(msToRun);
            case 1:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function advanceTimersByTimeAsync(_x) {
        return _advanceTimersByTimeAsync.apply(this, arguments);
      }
      return advanceTimersByTimeAsync;
    }()
  }, {
    key: "advanceTimersToNextFrame",
    value: function advanceTimersToNextFrame() {
      if (this._checkFakeTimers()) this._clock.runToFrame();
    }
  }, {
    key: "runAllTicks",
    value: function runAllTicks() {
      if (this._checkFakeTimers())
        // @ts-expect-error method not exposed
        this._clock.runMicrotasks();
    }
  }, {
    key: "useRealTimers",
    value: function useRealTimers() {
      if (this._fakingDate) {
        resetDate();
        this._fakingDate = null;
      }
      if (this._fakingTime) {
        this._clock.uninstall();
        this._fakingTime = false;
      }
    }
  }, {
    key: "useFakeTimers",
    value: function useFakeTimers() {
      if (this._fakingDate) throw new Error("\"setSystemTime\" was called already and date was mocked. Reset timers using `vi.useRealTimers()` if you want to use fake timers again.");
      if (!this._fakingTime) {
        var _this$_userConfig, _this$_userConfig2;
        var toFake = Object.keys(this._fakeTimers.timers).filter(function (timer) {
          return timer !== "nextTick" && timer !== "queueMicrotask";
        });
        if ((_this$_userConfig = this._userConfig) !== null && _this$_userConfig !== void 0 && (_this$_userConfig = _this$_userConfig.toFake) !== null && _this$_userConfig !== void 0 && _this$_userConfig.includes("nextTick") && isChildProcess()) throw new Error("process.nextTick cannot be mocked inside child_process");
        this._clock = this._fakeTimers.install(_objectSpread(_objectSpread({
          now: Date.now()
        }, this._userConfig), {}, {
          toFake: ((_this$_userConfig2 = this._userConfig) === null || _this$_userConfig2 === void 0 ? void 0 : _this$_userConfig2.toFake) || toFake,
          ignoreMissingTimers: true
        }));
        this._fakingTime = true;
      }
    }
  }, {
    key: "reset",
    value: function reset() {
      if (this._checkFakeTimers()) {
        var now = this._clock.now;
        this._clock.reset();
        this._clock.setSystemTime(now);
      }
    }
  }, {
    key: "setSystemTime",
    value: function setSystemTime(now) {
      var date = typeof now === "undefined" || now instanceof Date ? now : new Date(now);
      if (this._fakingTime) this._clock.setSystemTime(date);else {
        this._fakingDate = date !== null && date !== void 0 ? date : new Date(this.getRealSystemTime());
        mockDate(this._fakingDate);
      }
    }
  }, {
    key: "getMockedSystemTime",
    value: function getMockedSystemTime() {
      return this._fakingTime ? new Date(this._clock.now) : this._fakingDate;
    }
  }, {
    key: "getRealSystemTime",
    value: function getRealSystemTime() {
      return this._now();
    }
  }, {
    key: "getTimerCount",
    value: function getTimerCount() {
      if (this._checkFakeTimers()) return this._clock.countTimers();
      return 0;
    }
  }, {
    key: "configure",
    value: function configure(config) {
      this._userConfig = config;
    }
  }, {
    key: "isFakeTimers",
    value: function isFakeTimers() {
      return this._fakingTime;
    }
  }, {
    key: "_checkFakeTimers",
    value: function _checkFakeTimers() {
      if (!this._fakingTime) throw new Error("Timers are not mocked. Try calling \"vi.useFakeTimers()\" first.");
      return this._fakingTime;
    }
  }]);
}();
function copyStackTrace(target, source) {
  if (source.stack !== void 0) target.stack = source.stack.replace(source.message, target.message);
  return target;
}
function waitFor(callback) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _getSafeTimers2 = getSafeTimers(),
    setTimeout = _getSafeTimers2.setTimeout,
    setInterval = _getSafeTimers2.setInterval,
    clearTimeout = _getSafeTimers2.clearTimeout,
    clearInterval = _getSafeTimers2.clearInterval;
  var _ref6 = typeof options === "number" ? {
      timeout: options
    } : options,
    _ref6$interval = _ref6.interval,
    interval = _ref6$interval === void 0 ? 50 : _ref6$interval,
    _ref6$timeout = _ref6.timeout,
    timeout = _ref6$timeout === void 0 ? 1e3 : _ref6$timeout;
  var STACK_TRACE_ERROR = new Error("STACK_TRACE_ERROR");
  return new Promise(function (resolve, reject) {
    var lastError;
    var promiseStatus = "idle";
    var timeoutId;
    var intervalId;
    var onResolve = function onResolve(result) {
      if (timeoutId) clearTimeout(timeoutId);
      if (intervalId) clearInterval(intervalId);
      resolve(result);
    };
    var handleTimeout = function handleTimeout() {
      if (intervalId) clearInterval(intervalId);
      var error = lastError;
      if (!error) error = copyStackTrace(new Error("Timed out in waitFor!"), STACK_TRACE_ERROR);
      reject(error);
    };
    var checkCallback = function checkCallback() {
      if (vi.isFakeTimers()) vi.advanceTimersByTime(interval);
      if (promiseStatus === "pending") return;
      try {
        var result = callback();
        if (result !== null && _typeof(result) === "object" && typeof result.then === "function") {
          var thenable = result;
          promiseStatus = "pending";
          thenable.then(function (resolvedValue) {
            promiseStatus = "resolved";
            onResolve(resolvedValue);
          }, function (rejectedValue) {
            promiseStatus = "rejected";
            lastError = rejectedValue;
          });
        } else {
          onResolve(result);
          return true;
        }
      } catch (error) {
        lastError = error;
      }
    };
    if (checkCallback() === true) return;
    timeoutId = setTimeout(handleTimeout, timeout);
    intervalId = setInterval(checkCallback, interval);
  });
}
function waitUntil(callback) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _getSafeTimers3 = getSafeTimers(),
    setTimeout = _getSafeTimers3.setTimeout,
    setInterval = _getSafeTimers3.setInterval,
    clearTimeout = _getSafeTimers3.clearTimeout,
    clearInterval = _getSafeTimers3.clearInterval;
  var _ref7 = typeof options === "number" ? {
      timeout: options
    } : options,
    _ref7$interval = _ref7.interval,
    interval = _ref7$interval === void 0 ? 50 : _ref7$interval,
    _ref7$timeout = _ref7.timeout,
    timeout = _ref7$timeout === void 0 ? 1e3 : _ref7$timeout;
  var STACK_TRACE_ERROR = new Error("STACK_TRACE_ERROR");
  return new Promise(function (resolve, reject) {
    var promiseStatus = "idle";
    var timeoutId;
    var intervalId;
    var onReject = function onReject(error) {
      if (intervalId) clearInterval(intervalId);
      if (!error) error = copyStackTrace(new Error("Timed out in waitUntil!"), STACK_TRACE_ERROR);
      reject(error);
    };
    var onResolve = function onResolve(result) {
      if (!result) return;
      if (timeoutId) clearTimeout(timeoutId);
      if (intervalId) clearInterval(intervalId);
      resolve(result);
      return true;
    };
    var checkCallback = function checkCallback() {
      if (vi.isFakeTimers()) vi.advanceTimersByTime(interval);
      if (promiseStatus === "pending") return;
      try {
        var result = callback();
        if (result !== null && _typeof(result) === "object" && typeof result.then === "function") {
          var thenable = result;
          promiseStatus = "pending";
          thenable.then(function (resolvedValue) {
            promiseStatus = "resolved";
            onResolve(resolvedValue);
          }, function (rejectedValue) {
            promiseStatus = "rejected";
            onReject(rejectedValue);
          });
        } else return onResolve(result);
      } catch (error) {
        onReject(error);
      }
    };
    if (checkCallback() === true) return;
    timeoutId = setTimeout(onReject, timeout);
    intervalId = setInterval(checkCallback, interval);
  });
}
function createVitest() {
  var _config = null;
  var workerState = getWorkerState();
  var _timers;
  var timers = function timers() {
    return _timers || (_timers = new FakeTimers({
      global: globalThis,
      config: workerState.config.fakeTimers
    }));
  };
  var _stubsGlobal = /* @__PURE__ */new Map();
  var _stubsEnv = /* @__PURE__ */new Map();
  var _envBooleans = ["PROD", "DEV", "SSR"];
  var utils = {
    useFakeTimers: function useFakeTimers(config) {
      if (isChildProcess()) {
        var _config$toFake, _workerState$config;
        if (config !== null && config !== void 0 && (_config$toFake = config.toFake) !== null && _config$toFake !== void 0 && _config$toFake.includes("nextTick") || (_workerState$config = workerState.config) !== null && _workerState$config !== void 0 && (_workerState$config = _workerState$config.fakeTimers) !== null && _workerState$config !== void 0 && (_workerState$config = _workerState$config.toFake) !== null && _workerState$config !== void 0 && _workerState$config.includes("nextTick")) throw new Error("vi.useFakeTimers({ toFake: [\"nextTick\"] }) is not supported in node:child_process. Use --pool=threads if mocking nextTick is required.");
      }
      if (config) timers().configure(_objectSpread(_objectSpread({}, workerState.config.fakeTimers), config));else timers().configure(workerState.config.fakeTimers);
      timers().useFakeTimers();
      return utils;
    },
    isFakeTimers: function isFakeTimers() {
      return timers().isFakeTimers();
    },
    useRealTimers: function useRealTimers() {
      timers().useRealTimers();
      return utils;
    },
    runOnlyPendingTimers: function runOnlyPendingTimers() {
      timers().runOnlyPendingTimers();
      return utils;
    },
    runOnlyPendingTimersAsync: function runOnlyPendingTimersAsync() {
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {
        return _regeneratorRuntime.wrap(function (_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _context8.next = 1;
              return timers().runOnlyPendingTimersAsync();
            case 1:
              return _context8.abrupt("return", utils);
            case 2:
            case "end":
              return _context8.stop();
          }
        }, _callee8);
      }))();
    },
    runAllTimers: function runAllTimers() {
      timers().runAllTimers();
      return utils;
    },
    runAllTimersAsync: function runAllTimersAsync() {
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {
        return _regeneratorRuntime.wrap(function (_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              _context9.next = 1;
              return timers().runAllTimersAsync();
            case 1:
              return _context9.abrupt("return", utils);
            case 2:
            case "end":
              return _context9.stop();
          }
        }, _callee9);
      }))();
    },
    runAllTicks: function runAllTicks() {
      timers().runAllTicks();
      return utils;
    },
    advanceTimersByTime: function advanceTimersByTime(ms) {
      timers().advanceTimersByTime(ms);
      return utils;
    },
    advanceTimersByTimeAsync: function advanceTimersByTimeAsync(ms) {
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee0() {
        return _regeneratorRuntime.wrap(function (_context0) {
          while (1) switch (_context0.prev = _context0.next) {
            case 0:
              _context0.next = 1;
              return timers().advanceTimersByTimeAsync(ms);
            case 1:
              return _context0.abrupt("return", utils);
            case 2:
            case "end":
              return _context0.stop();
          }
        }, _callee0);
      }))();
    },
    advanceTimersToNextTimer: function advanceTimersToNextTimer() {
      timers().advanceTimersToNextTimer();
      return utils;
    },
    advanceTimersToNextTimerAsync: function advanceTimersToNextTimerAsync() {
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee1() {
        return _regeneratorRuntime.wrap(function (_context1) {
          while (1) switch (_context1.prev = _context1.next) {
            case 0:
              _context1.next = 1;
              return timers().advanceTimersToNextTimerAsync();
            case 1:
              return _context1.abrupt("return", utils);
            case 2:
            case "end":
              return _context1.stop();
          }
        }, _callee1);
      }))();
    },
    advanceTimersToNextFrame: function advanceTimersToNextFrame() {
      timers().advanceTimersToNextFrame();
      return utils;
    },
    getTimerCount: function getTimerCount() {
      return timers().getTimerCount();
    },
    setSystemTime: function setSystemTime(time) {
      timers().setSystemTime(time);
      return utils;
    },
    getMockedSystemTime: function getMockedSystemTime() {
      return timers().getMockedSystemTime();
    },
    getRealSystemTime: function getRealSystemTime() {
      return timers().getRealSystemTime();
    },
    clearAllTimers: function clearAllTimers() {
      timers().clearAllTimers();
      return utils;
    },
    spyOn: spyOn,
    fn: fn,
    waitFor: waitFor,
    waitUntil: waitUntil,
    hoisted: function hoisted(factory) {
      assertTypes(factory, "\"vi.hoisted\" factory", ["function"]);
      return factory();
    },
    mock: function mock(path, factory) {
      if (typeof path !== "string") throw new TypeError("vi.mock() expects a string path, but received a ".concat(_typeof(path)));
      var importer = getImporter("mock");
      _mocker().queueMock(path, importer, typeof factory === "function" ? function () {
        return factory(function () {
          return _mocker().importActual(path, importer, _mocker().getMockContext().callstack);
        });
      } : factory);
    },
    unmock: function unmock(path) {
      if (typeof path !== "string") throw new TypeError("vi.unmock() expects a string path, but received a ".concat(_typeof(path)));
      _mocker().queueUnmock(path, getImporter("unmock"));
    },
    doMock: function doMock(path, factory) {
      if (typeof path !== "string") throw new TypeError("vi.doMock() expects a string path, but received a ".concat(_typeof(path)));
      var importer = getImporter("doMock");
      _mocker().queueMock(path, importer, typeof factory === "function" ? function () {
        return factory(function () {
          return _mocker().importActual(path, importer, _mocker().getMockContext().callstack);
        });
      } : factory);
    },
    doUnmock: function doUnmock(path) {
      if (typeof path !== "string") throw new TypeError("vi.doUnmock() expects a string path, but received a ".concat(_typeof(path)));
      _mocker().queueUnmock(path, getImporter("doUnmock"));
    },
    importActual: function importActual(path) {
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {
        return _regeneratorRuntime.wrap(function (_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              return _context10.abrupt("return", _mocker().importActual(path, getImporter("importActual"), _mocker().getMockContext().callstack));
            case 1:
            case "end":
              return _context10.stop();
          }
        }, _callee10);
      }))();
    },
    importMock: function importMock(path) {
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {
        return _regeneratorRuntime.wrap(function (_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              return _context11.abrupt("return", _mocker().importMock(path, getImporter("importMock")));
            case 1:
            case "end":
              return _context11.stop();
          }
        }, _callee11);
      }))();
    },
    mockObject: function mockObject(value) {
      return _mocker().mockObject({
        value: value
      }).value;
    },
    mocked: function mocked(item) {
      return item;
    },
    isMockFunction: function isMockFunction$1(fn) {
      return isMockFunction(fn);
    },
    clearAllMocks: function clearAllMocks() {
      _toConsumableArray(mocks).reverse().forEach(function (spy) {
        return spy.mockClear();
      });
      return utils;
    },
    resetAllMocks: function resetAllMocks() {
      _toConsumableArray(mocks).reverse().forEach(function (spy) {
        return spy.mockReset();
      });
      return utils;
    },
    restoreAllMocks: function restoreAllMocks() {
      _toConsumableArray(mocks).reverse().forEach(function (spy) {
        return spy.mockRestore();
      });
      return utils;
    },
    stubGlobal: function stubGlobal(name, value) {
      if (!_stubsGlobal.has(name)) _stubsGlobal.set(name, Object.getOwnPropertyDescriptor(globalThis, name));
      Object.defineProperty(globalThis, name, {
        value: value,
        writable: true,
        configurable: true,
        enumerable: true
      });
      return utils;
    },
    stubEnv: function stubEnv(name, value) {
      if (!_stubsEnv.has(name)) _stubsEnv.set(name, process.env[name]);
      if (_envBooleans.includes(name)) process.env[name] = value ? "1" : "";else if (value === void 0) delete process.env[name];else process.env[name] = String(value);
      return utils;
    },
    unstubAllGlobals: function unstubAllGlobals() {
      _stubsGlobal.forEach(function (original, name) {
        if (!original) Reflect.deleteProperty(globalThis, name);else Object.defineProperty(globalThis, name, original);
      });
      _stubsGlobal.clear();
      return utils;
    },
    unstubAllEnvs: function unstubAllEnvs() {
      _stubsEnv.forEach(function (original, name) {
        if (original === void 0) delete process.env[name];else process.env[name] = original;
      });
      _stubsEnv.clear();
      return utils;
    },
    resetModules: function resetModules$1() {
      resetModules(workerState.moduleCache);
      return utils;
    },
    dynamicImportSettled: function dynamicImportSettled() {
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {
        return _regeneratorRuntime.wrap(function (_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              return _context12.abrupt("return", waitForImportsToResolve());
            case 1:
            case "end":
              return _context12.stop();
          }
        }, _callee12);
      }))();
    },
    setConfig: function setConfig(config) {
      if (!_config) _config = _objectSpread({}, workerState.config);
      Object.assign(workerState.config, config);
    },
    resetConfig: function resetConfig() {
      if (_config) Object.assign(workerState.config, _config);
    }
  };
  return utils;
}
var vitest = createVitest();
var vi = vitest;
function _mocker() {
  // @ts-expect-error injected by vite-nide
  return typeof __vitest_mocker__ !== "undefined" ? __vitest_mocker__ : new Proxy({}, {
    get: function get(_, name) {
      throw new Error("Vitest mocker was not initialized in this environment. vi.".concat(String(name), "() is forbidden."));
    }
  });
}
function getImporter(name) {
  var stackTrace = createSimpleStackTrace({
    stackTraceLimit: 5
  });
  var stackArray = stackTrace.split("\n");
  // if there is no message in a stack trace, use the item - 1
  var importerStackIndex = stackArray.findIndex(function (stack) {
    return stack.includes(" at Object.".concat(name)) || stack.includes("".concat(name, "@"));
  });
  var stack = parseSingleStack(stackArray[importerStackIndex + 1]);
  return (stack === null || stack === void 0 ? void 0 : stack.file) || "";
}

export { describe as d, globalExpect as g, it as i, vi as v };
//# sourceMappingURL=dep-f93ad091.js.map
