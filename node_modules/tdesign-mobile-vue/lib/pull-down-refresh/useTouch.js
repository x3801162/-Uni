/**
 * tdesign v1.11.1
 * (c) 2025 TDesign Group
 * @license MIT
 */

import { ref } from 'vue';

var isElement = function isElement(node) {
  var ELEMENT_NODE_TYPE = 1;
  return node.nodeType === ELEMENT_NODE_TYPE;
};
function useTouch() {
  var startX = ref(0);
  var startY = ref(0);
  var diffX = ref(0);
  var diffY = ref(0);
  var start = function start(event) {
    var _event$touches$ = event.touches[0],
      clientX = _event$touches$.clientX,
      clientY = _event$touches$.clientY;
    startX.value = clientX;
    startY.value = clientY;
    diffY.value = 0;
    diffX.value = 0;
  };
  var move = function move(event) {
    var _event$touches$2 = event.touches[0],
      clientX = _event$touches$2.clientX,
      clientY = _event$touches$2.clientY;
    diffY.value = clientY - startY.value;
    diffX.value = clientX - startX.value;
  };
  return {
    startX: startX,
    startY: startY,
    diffX: diffX,
    diffY: diffY,
    start: start,
    move: move
  };
}
var easeDistance = function easeDistance(distance, pullDistance) {
  if (distance > pullDistance) {
    if (distance < pullDistance * 2) {
      distance = pullDistance + (distance - pullDistance) / 2;
    } else {
      distance = pullDistance * 1.5 + (distance - pullDistance * 2) / 4;
    }
  }
  return Math.round(distance);
};
function getScrollParent(node) {
  var res = node;
  while (res && isElement(res)) {
    var style = window.getComputedStyle(res);
    var isScrollableY = /auto|scroll/i.test(style.overflowY);
    var canScrollY = ["hidden", "visible"].includes(style.overflowY) && res.scrollHeight > res.clientHeight;
    if (isScrollableY || canScrollY) {
      return res;
    }
    res = res.parentNode;
  }
  return null;
}
var isReachTop = function isReachTop(e) {
  var scrollParent = getScrollParent(e.target);
  return !scrollParent || !scrollParent.scrollTop;
};

export { easeDistance, getScrollParent, isReachTop, useTouch };
//# sourceMappingURL=useTouch.js.map
