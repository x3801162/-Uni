/// <reference types="node" />
import { ComputedRef } from 'vue';
import { TdUploadProps, UploadFile, UploadRemoveContext } from '../type';
export declare type ValidateParams = Parameters<TdUploadProps['onValidate']>[0];
export default function useUpload(props: TdUploadProps): {
    toUploadFiles: import("vue").Ref<{
        [x: string]: any;
        lastModified?: number;
        name?: string;
        percent?: number;
        raw?: {
            readonly lastModified: number;
            readonly name: string;
            readonly webkitRelativePath: string;
            readonly size: number;
            readonly type: string;
            arrayBuffer: {
                (): Promise<ArrayBuffer>;
                (): Promise<ArrayBuffer>;
            };
            slice: {
                (start?: number, end?: number, contentType?: string): Blob;
                (start?: number, end?: number, contentType?: string): Blob;
            };
            stream: {
                (): ReadableStream<Uint8Array>;
                (): NodeJS.ReadableStream;
            };
            text: {
                (): Promise<string>;
                (): Promise<string>;
            };
        };
        response?: {
            [key: string]: any;
        };
        size?: number;
        status?: "progress" | "waiting" | "success" | "fail";
        type?: string;
        uploadTime?: string;
        url?: string;
    }[]>;
    uploadValue: import("vue").Ref<UploadFile[]>;
    displayFiles: ComputedRef<UploadFile[]>;
    sizeOverLimitMessage: import("vue").Ref<string>;
    uploading: import("vue").Ref<boolean>;
    inputRef: import("vue").Ref<HTMLInputElement>;
    disabled: import("vue").Ref<boolean>;
    xhrReq: import("vue").Ref<{
        files: {
            [x: string]: any;
            lastModified?: number;
            name?: string;
            percent?: number;
            raw?: {
                readonly lastModified: number;
                readonly name: string;
                readonly webkitRelativePath: string;
                readonly size: number;
                readonly type: string;
                arrayBuffer: {
                    (): Promise<ArrayBuffer>;
                    (): Promise<ArrayBuffer>;
                };
                slice: {
                    (start?: number, end?: number, contentType?: string): Blob;
                    (start?: number, end?: number, contentType?: string): Blob;
                };
                stream: {
                    (): ReadableStream<Uint8Array>;
                    (): NodeJS.ReadableStream;
                };
                text: {
                    (): Promise<string>;
                    (): Promise<string>;
                };
            };
            response?: {
                [key: string]: any;
            };
            size?: number;
            status?: "progress" | "waiting" | "success" | "fail";
            type?: string;
            uploadTime?: string;
            url?: string;
        }[];
        xhrReq: {
            onreadystatechange: (this: XMLHttpRequest, ev: Event) => any;
            readonly readyState: number;
            readonly response: any;
            readonly responseText: string;
            responseType: XMLHttpRequestResponseType;
            readonly responseURL: string;
            readonly responseXML: Document;
            readonly status: number;
            readonly statusText: string;
            timeout: number;
            readonly upload: {
                addEventListener: {
                    <K extends keyof XMLHttpRequestEventTargetEventMap>(type: K, listener: (this: XMLHttpRequestUpload, ev: XMLHttpRequestEventTargetEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
                    (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
                };
                removeEventListener: {
                    <K_1 extends keyof XMLHttpRequestEventTargetEventMap>(type: K_1, listener: (this: XMLHttpRequestUpload, ev: XMLHttpRequestEventTargetEventMap[K_1]) => any, options?: boolean | EventListenerOptions): void;
                    (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
                };
                onabort: (this: XMLHttpRequest, ev: ProgressEvent<EventTarget>) => any;
                onerror: (this: XMLHttpRequest, ev: ProgressEvent<EventTarget>) => any;
                onload: (this: XMLHttpRequest, ev: ProgressEvent<EventTarget>) => any;
                onloadend: (this: XMLHttpRequest, ev: ProgressEvent<EventTarget>) => any;
                onloadstart: (this: XMLHttpRequest, ev: ProgressEvent<EventTarget>) => any;
                onprogress: (this: XMLHttpRequest, ev: ProgressEvent<EventTarget>) => any;
                ontimeout: (this: XMLHttpRequest, ev: ProgressEvent<EventTarget>) => any;
                dispatchEvent: (event: Event) => boolean;
            };
            withCredentials: boolean;
            abort: () => void;
            getAllResponseHeaders: () => string;
            getResponseHeader: (name: string) => string;
            open: {
                (method: string, url: string | URL): void;
                (method: string, url: string | URL, async: boolean, username?: string, password?: string): void;
            };
            overrideMimeType: (mime: string) => void;
            send: (body?: Document | XMLHttpRequestBodyInit) => void;
            setRequestHeader: (name: string, value: string) => void;
            readonly DONE: number;
            readonly HEADERS_RECEIVED: number;
            readonly LOADING: number;
            readonly OPENED: number;
            readonly UNSENT: number;
            addEventListener: {
                <K_2 extends keyof XMLHttpRequestEventMap>(type: K_2, listener: (this: XMLHttpRequest, ev: XMLHttpRequestEventMap[K_2]) => any, options?: boolean | AddEventListenerOptions): void;
                (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
            };
            removeEventListener: {
                <K_3 extends keyof XMLHttpRequestEventMap>(type: K_3, listener: (this: XMLHttpRequest, ev: XMLHttpRequestEventMap[K_3]) => any, options?: boolean | EventListenerOptions): void;
                (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
            };
            onabort: (this: XMLHttpRequest, ev: ProgressEvent<EventTarget>) => any;
            onerror: (this: XMLHttpRequest, ev: ProgressEvent<EventTarget>) => any;
            onload: (this: XMLHttpRequest, ev: ProgressEvent<EventTarget>) => any;
            onloadend: (this: XMLHttpRequest, ev: ProgressEvent<EventTarget>) => any;
            onloadstart: (this: XMLHttpRequest, ev: ProgressEvent<EventTarget>) => any;
            onprogress: (this: XMLHttpRequest, ev: ProgressEvent<EventTarget>) => any;
            ontimeout: (this: XMLHttpRequest, ev: ProgressEvent<EventTarget>) => any;
            dispatchEvent: (event: Event) => boolean;
        };
    }[]>;
    uploadFilePercent: (params: {
        file: UploadFile;
        percent: number;
    }) => void;
    uploadFiles: (toFiles?: UploadFile[]) => void;
    onFileChange: (files: File[]) => void;
    onNormalFileChange: (e: Event) => void;
    onInnerRemove: (p: UploadRemoveContext) => void;
    cancelUpload: (context?: {
        file?: UploadFile;
        e?: MouseEvent;
    }) => void;
};
