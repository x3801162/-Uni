/**
 * tdesign v1.11.1
 * (c) 2025 TDesign Group
 * @license MIT
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var Vue = require('vue');
var _arrayMap = require('../../_chunks/dep-2ab29468.js');
var _cacheHas = require('../../_chunks/dep-5f870597.js');
var _arrayIncludesWith = require('../../_chunks/dep-df60c8fb.js');
var _baseUnary = require('../../_chunks/dep-159c7a94.js');
var isArrayLikeObject = require('../../_chunks/dep-4b045875.js');
require('../../_chunks/dep-b633ec9e.js');
require('../../_chunks/dep-7aa6341b.js');
require('../../_chunks/dep-0bd122a0.js');
require('../../_chunks/dep-53383176.js');
require('@babel/runtime/helpers/typeof');
require('../../_chunks/dep-b999c3d4.js');
require('../../_chunks/dep-b8e8d654.js');
require('../../_chunks/dep-a6a4534e.js');
require('../../_chunks/dep-5cf8bf50.js');
require('../../_chunks/dep-0c11c462.js');
require('../../_chunks/dep-f84e6e17.js');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * The base implementation of methods like `_.intersection`, without support
 * for iteratee shorthands, that accepts an array of arrays to inspect.
 *
 * @private
 * @param {Array} arrays The arrays to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of shared values.
 */
function baseIntersection(arrays, iteratee, comparator) {
  var includes = comparator ? _arrayIncludesWith.arrayIncludesWith : _arrayIncludesWith.arrayIncludes,
    length = arrays[0].length,
    othLength = arrays.length,
    othIndex = othLength,
    caches = Array(othLength),
    maxLength = Infinity,
    result = [];
  while (othIndex--) {
    var array = arrays[othIndex];
    if (othIndex && iteratee) {
      array = _arrayMap.arrayMap(array, _baseUnary.baseUnary(iteratee));
    }
    maxLength = nativeMin(array.length, maxLength);
    caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new _cacheHas.SetCache(othIndex && array) : undefined;
  }
  array = arrays[0];
  var index = -1,
    seen = caches[0];
  outer: while (++index < length && result.length < maxLength) {
    var value = array[index],
      computed = iteratee ? iteratee(value) : value;
    value = comparator || value !== 0 ? value : 0;
    if (!(seen ? _cacheHas.cacheHas(seen, computed) : includes(result, computed, comparator))) {
      othIndex = othLength;
      while (--othIndex) {
        var cache = caches[othIndex];
        if (!(cache ? _cacheHas.cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
          continue outer;
        }
      }
      if (seen) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

/**
 * Casts `value` to an empty array if it's not an array like object.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array|Object} Returns the cast array-like object.
 */
function castArrayLikeObject(value) {
  return isArrayLikeObject.isArrayLikeObject(value) ? value : [];
}

/**
 * Creates an array of unique values that are included in all given arrays
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. The order and references of result values are
 * determined by the first array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of intersecting values.
 * @example
 *
 * _.intersection([2, 1], [2, 3]);
 * // => [2]
 */
var intersection = isArrayLikeObject.baseRest(function (arrays) {
  var mapped = _arrayMap.arrayMap(arrays, castArrayLikeObject);
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
});
var intersection$1 = intersection;

var setCheckAllStatus = function setCheckAllStatus(optionList, innerValue, checkedSet) {
  var isArray = Array.isArray;
  var intersectionLen = Vue.computed(function () {
    var _optionList$value;
    var values = (_optionList$value = optionList.value) === null || _optionList$value === void 0 ? void 0 : _optionList$value.map(function (item) {
      return item.value;
    });
    if (isArray(innerValue.value)) {
      return intersection$1(innerValue.value, values).length;
    }
    return 0;
  });
  var isAllChecked = Vue.computed(function () {
    if (checkedSet.value.size !== optionList.value.length - 1) {
      return false;
    }
    return intersectionLen.value === optionList.value.length - 1;
  });
  var indeterminate = Vue.computed(function () {
    return !isAllChecked.value && intersectionLen.value < optionList.value.length && intersectionLen.value > 0;
  });
  return Vue.computed(function () {
    if (isAllChecked.value) return "checked";
    if (indeterminate.value) return "indeterminate";
    return "uncheck";
  });
};

exports.setCheckAllStatus = setCheckAllStatus;
//# sourceMappingURL=setCheckAllStatus.js.map
