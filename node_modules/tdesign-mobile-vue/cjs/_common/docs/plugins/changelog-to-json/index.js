/**
 * tdesign v1.11.1
 * (c) 2025 TDesign Group
 * @license MIT
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var _asyncToGenerator = require('@babel/runtime/helpers/asyncToGenerator');
var _regeneratorRuntime = require('@babel/runtime/regenerator');
var fs = require('fs');
var _common_docs_plugins_changelogToJson_libs = require('./libs.js');
require('@babel/runtime/helpers/slicedToArray');
require('../../../js/components.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);
var _asyncToGenerator__default = /*#__PURE__*/_interopDefaultLegacy(_asyncToGenerator);
var _regeneratorRuntime__default = /*#__PURE__*/_interopDefaultLegacy(_regeneratorRuntime);

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty__default["default"](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var LOG_TYPES = ["\uD83D\uDEA8 Breaking Changes", "\uD83D\uDE80 Features", "\uD83D\uDC1E Bug Fixes"];
var targetPlatform = "web";
function generateChangelogJson(_x, _x2) {
  return _generateChangelogJson.apply(this, arguments);
}
function _generateChangelogJson() {
  _generateChangelogJson = _asyncToGenerator__default["default"](/*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(changelogPath, platform) {
    var logMd, detailedLogs, compMap, _t;
    return _regeneratorRuntime__default["default"].wrap(function (_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.prev = 0;
          _context.next = 1;
          return fs.promises.readFile(changelogPath, "utf-8");
        case 1:
          logMd = _context.sent;
          targetPlatform = platform;
          detailedLogs = parseMd2Json(logMd);
          compMap = formatJson2CompMap(detailedLogs);
          console.log("\x1B[32m%s\x1B[0m", "\u2705 Sync CHANGELOG.md to changelog.json");
          return _context.abrupt("return", compMap);
        case 2:
          _context.prev = 2;
          _t = _context["catch"](0);
          console.error("\x1B[31m%s\x1B[0m", "\u274C Fail to generate changelog.json", "\x1B[33m", _t);
          return _context.abrupt("return", {});
        case 3:
        case "end":
          return _context.stop();
      }
    }, _callee, null, [[0, 2]]);
  }));
  return _generateChangelogJson.apply(this, arguments);
}
function parseMd2Json(logMd) {
  var headerRegex = /^\s*##\s*ðŸŒˆ\s*(\d+\.\d+\.\d+)\s+`(\d{4}-\d{2}-\d{2})`\s*$/gm;
  var matches = Array.from(logMd.matchAll(headerRegex));
  var logs = matches.map(function (match, i) {
    var version = match[1];
    var date = match[2];
    var start = match.index + match[0].length;
    var end = i < matches.length - 1 ? matches[i + 1].index : logMd.length;
    var log = logMd.slice(start, end).trim();
    return {
      version: version,
      date: date,
      log: parseLogByType(log)
    };
  });
  return logs;
}
function parseLogByType(logBlock) {
  var logs = {};
  LOG_TYPES.forEach(function (type) {
    var typeRegex = new RegExp("### ".concat(type, "\\r?\\n([\\s\\S]+?)(?=### |$)"), "g");
    var matches = Array.from(logBlock.matchAll(typeRegex));
    if (matches.length > 0) {
      var logBlock2 = matches.map(function (match) {
        return match[1];
      }).join("\n");
      var entries = extractLogEntries(logBlock2);
      logs[type] = groupLogByComponent(entries);
    }
  });
  return logs;
}
function extractLogEntries(logBlock) {
  var lines = logBlock.split("\n").filter(function (line) {
    return line.trim() !== "";
  });
  var logs = [];
  var currEntry = "";
  for (var i = 0; i < lines.length; i++) {
    var line = lines[i].trim();
    if (!line) continue;
    var isChildEntry = /^\s+-/.test(lines[i]);
    var isParentEntry = line.startsWith("-") && !isChildEntry;
    if (isParentEntry) {
      if (currEntry) {
        logs.push(currEntry.trim());
      }
      currEntry = line.substring(1).trim();
    } else if (isChildEntry) {
      var childContent = line.replace(/^\s*-\s*/, "").trim();
      currEntry += "\n".concat(childContent);
    }
  }
  logs.push(currEntry.trim());
  return logs;
}
function groupLogByComponent(entries) {
  var logs = [];
  entries.forEach(function (entry) {
    var nameRegex = /`([^`]+)`:/;
    var match = entry.match(nameRegex);
    if (!match) return;
    var rawName = match[1];
    var compName = _common_docs_plugins_changelogToJson_libs.mapToParentName(rawName, targetPlatform);
    if (!compName) return;
    if (rawName === compName) {
      var logWithoutPrefix = entry.replace(nameRegex, "").trim();
      var lines = logWithoutPrefix.split("\n").map(function (line) {
        return line.trim();
      });
      var isGroupedLog = lines[0].startsWith("@");
      if (isGroupedLog) {
        logs.push({
          component: compName,
          description: logWithoutPrefix
        });
      } else {
        lines.forEach(function (line) {
          logs.push({
            component: compName,
            description: line
          });
        });
      }
    } else {
      logs.push({
        component: compName,
        description: entry
      });
    }
  });
  return logs;
}
function formatJson2CompMap(logJson) {
  var compMap = {};
  logJson.forEach(function (entry) {
    var version = entry.version,
      date = entry.date,
      log = entry.log;
    Object.keys(log).forEach(function (type) {
      var _log$type;
      (_log$type = log[type]) === null || _log$type === void 0 || _log$type.forEach(function (item) {
        var component = item.component,
          description = item.description;
        if (!compMap[component]) {
          compMap[component] = [];
        }
        var versionEntry = compMap[component].find(function (v) {
          return v.version === version;
        });
        if (!versionEntry) {
          versionEntry = {
            version: version,
            date: date
          };
          compMap[component].push(versionEntry);
        }
        if (!versionEntry[type]) {
          versionEntry[type] = [];
        }
        versionEntry[type].push(description);
      });
    });
  });
  var sortedCompMap = Object.keys(compMap).sort(function (a, b) {
    return a.localeCompare(b);
  }).reduce(function (acc, key) {
    return _objectSpread(_objectSpread({}, acc), {}, _defineProperty__default["default"]({}, key, compMap[key]));
  }, {});
  return sortedCompMap;
}

exports.LOG_TYPES = LOG_TYPES;
exports["default"] = generateChangelogJson;
//# sourceMappingURL=index.js.map
